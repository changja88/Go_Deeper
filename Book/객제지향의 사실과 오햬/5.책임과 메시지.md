## 책임과 메시지

- `의도는 '메시징이다'. 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤니케이션하는가에 달려있다`

### 자율적인 책임

- 자율성 &rarr; 자기 스스로의 원칙에 따라 어떤 일을 하거나 자신을 통제해서 절제하는 성질이나 특성
- 타율성 &rarr; 자신의 의지와 관계없이 정해진 규율이나 원칙에 따라서만 움직이는 성질
- `따라서 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 개체이다`
- `객체지향을 설계하는 가장 널리 알려진 방법을 책임-주도 설계라고 부르는 이유는 적절한 책임의 선택이 전체 설계의 방향을 결정하기 때문이다`
- 자신의 의지에 따라 증언할 수 있는 자유
    - 1> 판사 -(증언하라)->
    - 2> 판사 -(목격했던 장면을 떠올려라)-> | -(기억을 시간 순서로 재구성 하라)-> | -(간결하게 표현하라)->
    - 1번 방식이 '증언'이라는 책임을 더 자율적으로 수행할 수 있다
- 너무나 추상적인 책임
    - 책임이 수행 방법을 제한할 정도로 구체적인 것도 문제지만 협력의 의도를 명확하게 표현하지 못할 정도로 추상적인 것 역시 문제다
    - 판사 -(설명하라)->
        - 이 경우 무엇을 설명하라는 건지 너무 추상적이다
    - `추상적이고 포괄적인 책임은 협력을 재사용할 수 있도록 유연성을 확보해주지만 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다`
- '어떻게'가 아니라 '무엇'을
    - `자율적인 책임의 특징은 객체가 '어떻게(how)'해야 하는가가 아니라 '무엇(what'을 해야 하는가를 설명한다`

### 메시지와 메서드

- 메시지
    - 메시지 전송은 수신자, 메시지 이름, 인자의 조합이 된다 &rarr; 모자장수. 증언하라(어제,왕국)
    - 메시지는 객체들이 서로 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다
- 메서드
    - 메시지를 처리하기 위해 내부적으로 선택하는 방법을 '메서드'라고 한다
    - 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언얼을 구분 짓는 핵심적인 특징 중 하나다
    - 이것은 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확인히 구분되는 특징이다
- 다형성
    - `다형성이란 서로 다른 유형은 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다`
    - 다형성은 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 한다 &rarr; `대체 가능성을 의미`
    - `즉, 다형성은 수신자의 종류를 캡슐화한다`
- 유연하고 확장 가능하고 재사용성이 높은 협력의 의미
    - 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다
        - 1> 협력이 유연해진다
            - 송신자는 수신자가 메시지를 이해한다면 누구라도 상관하지 않는다. 송신자에 대한 파급효과 없이 유연하게 협력을 변경할 수 있다
        - 2> 협력이 수행되는 방식으로 확장할 수 있다
            - 송신자에게 아무런 영향도 미치지 않고 서도 수신자를 교체할 수 있다
        - 3> 협력이 수행되는 방식을 재사용할 수 있다
            - 협력에 영향을 미치지 않고서도 다양한 객체들이 수신자의 자리를 대체할 수 있기 때문에 다양한 문맥에서 재사용할 수 있다

### 메시지를 따라라

- 객체지향의 핵심, 메시지
    - `객체지향 패러다임으로의 전환은 시스템을 정적인 클래스들의 집합이 아니라 메시지를 주고받는 동적인 객체들의 집합으로 바라보는 것에서 시작된다`
    - 메시지가 아니라 데이터를 중심으로 객체를 설계하는 방식은 객체의 내부 구조를 객체정의의 일부로 만들기 때문에 객체의 자율성을 저해한다
        - 객체의 내부 구조는 감춰져야 한다
        - 외부의 객체가 객체의 내부를 마음대로 주무를 수 있다면 객체가 자신의 의지에 따라 판단하고 행동할 수 있는 자율성이 저해된다
    - `객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다`
- 책임-주도 설계 다시 살펴보기
    - What/Who 사이클
        - `책임-주도 설계의 핵심은 어떤 행위(메시지)가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다 -> what/hwo 사이클`
        - 책임-주도 설계의 관점에서는 어떤 객체가 어떤 특성을 가지고 있다고 해서 반드시 그와 관련된 행위를 수행할 것이라고 가정 하지 않는다
            - 반대로 행위를 먼저 식별한 후에 행위를 수행할 적절할 객체를 찾는다
        - 결과적으로 시스템이 수행해야 하는 전체 행위는 협력하는 객체들의 책임으로 분배된다
        - `수신 가능한 메시지가 모여 객체의 인터페이스를 구성한다`
            - `메시지를 먼저 결정하고 메시지를 수신할 객체들을 선택하는 과정은 객체의 인터페이스가 어떤 방식으로 결정되는지를 명확하게 보여준다`
- 묻지 말고 시켜라
    - 메시지를 먼져 결정하고 객체가 메시지를 따르게 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 한다
        - 이 스타일을 묻지 말고 시켜라(Tell, Don't Ask)스타일 또는 데메테르 법칙(Law of Demeter)이라고 한다
    - 묻지 말고 시켜라 스타일은 객체를 자율적으로 만들고 캡슈화를 보장하며 결합도를 낮게 유지시켜 주기 때문에 설계를 유연하게만든다
        - 이를 위해서는 어떻게 해야 하는지 말고 무엇을 해야 하는지를 요청해야 한다 &rarr; 인터페이스의 크기를 급격하게 감소시킨다
        - 인터페이스 크기의 감소는 외부에서 해당 객체에게 의존해야 하는 부분의 감소를 의미하며 결합도의 감소와 유연성 증가를 의미한다

### 객체 인터페이스

- 인터페이스
    - 인터페이스의 특징
        - 1> 인터페이스의 사용법만 알고 있으면 대상의 내부 구조나 동작 방법을 몰라도 상호작용이 가능하다
        - 2> 인터페이스가 변경되지 않고 단순히 내부 구성이나 작동 방식이 변경되는 것은 인터페이스 사용자에게 아무런 영향도 미치치 않는다
        - 3> 인터페이스가 동일하기만 하다면 어떤 대상과도 상호작용할 수 있다
    - 메시지가 인터페이스를 결정한다
        - 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이다. 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 객체가
          제공하는 인터페이스의 모양을 만든다
    - 공용 인터페이스
        - 인터페이스는 외부에 공개된 인터페이스와 내부에서만 접근할 수 있는 감춰진 인터페이스로 구분된다
        - 공용 인터페이스는 외부에서 호출, 사적 인터페이스는 셀프 호출

### 인터페이스와 구현의 분리

- 객체 관점에서 생각하는 방법
    - 객체지향적인 사고 방식을 이해하기 위해서는 다음의 세가지 원칙이 중요하다
        - 좀 더 추상적인 인터페이스 &rarr; 추상화는 적당 해야 한다는 말
        - 최소 인터페이스 &rarr; 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말라
        - 인터페이스와 구현 간에 차이가 있다는 점을 인식 &rarr; 아래 설명
- 구현
    - 객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현(implementation)이다
        - `객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현이 포함된다 `
    - `객체는 상태를 가진다. 상태는 어떤 식으로는 객체에 포함되겠지만 객체 외부에 노출되는 공용 인터페이스의 일부는 아니다. 따라서 상태를 어떻게 표현할 것인가는 객체의 구현에 해당한다`
    - `객체는 행동을 가진다. 행동은 메시지를 수신했을 때만 실행되는 일종의 메시지 처리 방법이다. 이 처리 방법을 메서드라고 한다. 메서드를 구성하는 코드 자체는 객체 외부에 노출되는 공용 인터퍼ㅔ이스의 일부는 아니기 때문에 객체의 구현 부분에 포함된다 `
    - 즉, 객체의 외부와 내부를 분리하라는 것은 결국 객체의 공용 인터페이스와 구현을 명확헥 분리하라는 말과 동일하다
- 인터페이스와 구현의 분리 원칙
    - 훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다
    - 이는 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확헥 분리해서 고려해야 한다는 것을 이미한다
    - 일을 인터페이스와 구현의 분리(seperartion of interface and implementation)원칙이라고 부른다 
    - 결론적으로 객체의 설계의 핵심은 객체를 두개의 분리된 요소로 분해해 설계하는 것이다. 그것은 바로 외부에 공개되는 인터페이스와 내부에 감춰지는 구현이다 