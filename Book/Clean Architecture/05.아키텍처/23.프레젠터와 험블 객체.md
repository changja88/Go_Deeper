## 프레젠터와 험블 객체

- 프레젠터는 험블 객체(Humble Object)를 따른 형태로, 아키텍처 경계를 식별하고 보호하는데 도움이 된다
- 실제로 '클린 아키텍처'는 헌블 객체 구현체들로 가득 차 있었다

### 험블 객체 패턴

- 험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 어려운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다
- 방법은 단순하다 행위들을 두 개의 모듈 또는 클래스로 나누고 이 모듈 중 하나가 험블이다
    - 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위로 모두 험블 객체로 옮긴다
    - 나머지 모듈에는 헌블 객체에 속하지 않은 테스트하기 쉬운 행위를 모두 옮긴다
    - 예를 들어 GUI의 경우 단위 테스트가 어려운데, 화면을 보면서 각 요소가 필요한 위치에 적절히 표ㅕ시되었는지 검사하는 테스트는 작성하기 매우 어렵기 때문이다
    - 하지만 GUI에서 수행하는 행위의 대다수는 쉽게 테스트할 수 있다
    - 험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다

### 프레젠터와 뷰

- 뷰는 험블 객체이고 테스트하기 어렵다 -> 이 객체에 포함된 코드는 가능한 간단하게 유지한다
- 프레젠터는 테스트하기 쉬운 객체다
    - 프레젠터의 역할은 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다
    - 예를 들어 애플리케이션에서 어떤 필드에 날짜를 표시하고자 한다면,
    - 애플리케이션은 프레젠터에 Date 객체를 전달하고 프레젠터는 이를 적절한 포맷의 문자열로 만들고, 이 문자열을 뷰 모델이라고 부르는 간단한
      데이터 구조에 담는다. 그러면 뷰는 뷰 모델에서 이 데이터를 찾는다
- 즉, 뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없다. 따라서 뷰는 보잘것 없다(humble)

### 텍스트와 아키텍처

- 테스트 용이성은 좋은 아키텍처가 가져야할 속성이다
- `험블 객체 패턴이 좋은 에인데, 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의도기 때문이다`
    - 프레젠터와 뷰 사이의 경계는 이러한 경계 중 하나이다

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터베이스 사이에는 테이터베이스 게이트웨이(database gateway)가 위치한다
- 데이터베이스 게이트웨이는 닿형적 인터페이스로, 애플리케이션이 데이터베이스에 수행하는 CRUD 작업과 관련된 모든 메서드를 포함한다
    - 예를 들어 애플리케이션에서 어제 로그인한 모든 사용자의 이름을 알 수 있어야 한다면, UserGateway인터페이스는 getNameOfUserWhoLoggedInAfter라는 메서드를 제공할 것이다
- `유스케이스 계청은 절대 SQL을 허용하지 않는다`
    - 따라서 유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다
    - `그리고 인터페이스의 구현체는 데이터베이스 계층에 위치하며 이 객체는 험블 객체이다`
- 데이터베이스 게이트웨이와 달리 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 떄문에 험블 객체가 아니다
    - 따라서 테스트하기 쉬운데, 게이트웨이는 스텁(stub)이나 테스트 더블(test-double)로 적당히 교체할 수 있기 때문이다

### 데이터 매퍼

- `객체 관리 매퍼(ORM, Object Relation Mapper)같은 건 사실 존재하지 않는다`
    - 객체는 데이터 구조가 아니기 때문이다
    - 최소한 객체를 사용하는 사람 관점에서 객체는 데이터 구조가 아니다 &rarr; 데이터는 모두 private으로 선언되므로 객체의 사용자는 데이터를 볼 수 없기 떄문
    - 객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다
- 이러한 ORM 시스템은 어디에 위치해야 하는가? &rarr; 물론 데이터베이스 계층이다
    - 실제로 ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체를 형성한다

### 서비스 리스너

- 애플리케이션이 다른 서비스와 반드시 통신해야 한다면, 또는 일련의 서비스를 제공해야 한다면, 여기에서도 서비스 경계를 생성하는 험블 객체를 패턴을 발견할 수 있다
- 애플리케이션은 데이터를 모듈로 전달한다 &rarr; 모듈은 데이터를 가공하여 외부 서비스로 전송한다 &rarr; 서비스 리스너가 서비스 인테페이스로 부터 데이터를 수신한다 &rarr; 내부로 전달 된다

### 결론

- 각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다
- 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 쉬운 무언가로 분리될 것이다
- 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다 