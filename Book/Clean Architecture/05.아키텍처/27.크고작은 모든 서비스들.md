## 크고작은 모든 서비스들

- 서비스 지향 아키텍처와 마이크로서비스 아키텍처는 다음과 같은 이유로 최근 인기를 끌고 있다
    - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다 (나중에 보면 알겠지만 일부만 맞는 말이다)
    - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다 (나중에 보면 알겠지만 일부만 맞는 말이다)

### 서비스 아키텍처?

- 서비스를 사용한다는 것은 본질적으로 아키텍처에 해당하는 것은 아니다
- 아키텍처는 의존성 규칙을 준수하며 고수준 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다
- 단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 수 는 없다
- 아키텍처를 정의하는 요소는 바로 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다
    - 반면 시스템의 나머지 많은 함수들은 행위를 서로 분리할 뿐이며, 아키텍처적으로는 전혀 중요하지 않다
    - 서비스도 마찬가지다 &rarr; 서비스도 결국 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않느다
    - 즉, 아키텍처적으로 중요한 서비스도 있지만 그렇지 않은 서비스도 있다 (우리의 관심의 전자이다)

### 서비스의 이점?

- 물음표가 있는 이유는 이의를 제기할 것이기 떄문이다
- 결합 분리의 오류
    - 시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다
    - 어쨋든 서비스는 서로 다른 프로세스에서 실행된다. 따라서 서비스는 다른 서비의 변수에 직접 접근할 수 없다
    - 하지만 반드시 그런 것은 아니다
        - 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다
        - 예를 들어 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면, 이 필드를 사용해 동작하는 모든 서비스는 반드시 변경되어야 한다
        - 또한 이 서비스들은 이 필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하게 조율해야 한다
        - 따라서 서비스들은 이 데이터 레코드에 강하게 결합되고, 서비스들 사이는 서로 간접적으로 결합되어 버린다
- 개발 및 배포 독립성의 오류
    - 서비스를 사용함에 따라서 예측되는 또 다른 이점은 전담팀이 서비스를 소유하고 운영한다는 점이다
    - 시스템의 개발, 유지보수, 운영 또한 독립적인 팀 단위로 분할할 수 있다고 여긴다
    - 하지만 실제로는 일부만 해당한다
        - 우선 역사적으로 대규모 엔터프라이즈도 모노리틱 서스템이나 컴포넌트 기반 시스템으로 구축할 수 있다는 사실이 역사적으로 증명 되었다 &rarr; 서비스가 유일한 선택지가 아니다
        - 데이터나 행위에서 어느 정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다 &rarr; 독립적으로 개발, 배포, 운영이 가능 하지 않다

### 야옹이 문제(마이크로서비스가 가지고 있는 문제)

<img src = "./IMG_5488.jpg" width = "600" height = "300">

- 확장 가능한 시스템을 구축하기 위해 수많은 작은 마이크로 서비스를 기반으로 구축했다
- 현재 상황에서 야옹이를 배달하는 서비스를 제공하기로 했다
    - 회사는 도시 전역에 야옹이를 태울 다수의 승차 지점을 설정 해야하고
    - 야옹이 배달 주문이 오면, 근처의 택시가 선택되고, 승차 지점 중 한곳에서 야옹이를 태운 후, 올바른 주소로 야옹이를 배달해야 한다
    - 참열을 동의하는 택시 업체도 있고 그렇지 않은 업체도 있을 것이다
    - 가능한 운전자가 있을 수도 있고 불가능한 운전자가 있을 수도 있다. 승객도 마찬가지 이다
- 야옹이 배달 기능을 추가하기 위해서 어떤 부분들이 변경이 되어야 할까?
    - 다시 말해 이 서비스들은 모두 결합되어 있어서 독립적으로 개발하고, 배포하거나, 유지될 수 없다
    - `이게 바로 횡단 관심사(cross-cutrting concern)이 가진 문제다`
    - 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이 문제에 직면하기 마련이다
- `위 이미지에 나온 다이어글앰 처럼 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약하다`

### 객체가 구출하다

<img src = "./IMG_5489.jpg" width = "600" height = "400">

- 마이크로서비스에서 이렇게 해결할 수 있다는 뜻이 아니라 컴포넌트 기반에서는 이렇게 해결할 수 있는 뜻임
- 컴포넌트 기반 아키텍처에서는 이 문제를 어떻게 해결했을까?
    - 위 그림처럼 SOLID 설계 원칙을 잘 들여다보면, 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함을 알 수 있다
    - 이전 그림과 거의 일치한다
    - Rides, Kittens 커포넌트를 주목해야한다
        - 배차에 특화된 로직 부분은 Rides 컴포넌트로 추출되고, 야옹이에 대한 신규 기능은 Kittens컴포넌트에 들어 갔다
        - 이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴등을 이용해서 오버라이드 한다
        - 또한 이 둘을 구현하는 클래스들은 UJI의 제어하에 팩토리가 생성한다

### 컴포넌트 기반 서비스

<img src = "./IMG_5490.jpg" width = "600" height = "400">

- 서비스에서도 이렇게 할 수 있을까? &rarr; 물론 할 수 있다
- 서비스가 반드시 소규모 단일체(monolith)여야 할 이유는 없다
    - 서비스는 SOLID 원칙대로 설계할 수 있으면 컴포넌트 구조를 갖출 수도 있다
    - 이를 통해서 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다
- 위 이미지는 서비스 다이어그램의 구조를 보여준다
    - 서비스들의 존재는 이전과 달라진게 없지만, 각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다
    - 파생 클래스들은 각자의 컴포넌트 내부에 놓인다

### 횡단 관심사

<img src = "./IMG_5491.jpg" width = "600" height = "300">

- `아키텍처 경계가 서비스 사이에 있지 않다는 사실! 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다`
- 횡단 관심사를 처리하려면 위 이미지처럼 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다
    - 이 서비스들은 시스템의 아키텍처 경계를 정의하지 않는다
    - 아키텍처 경계를 정의하는 것은 서비스 내의 위치한 컴포넌트이다

### 결론

- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다
- 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다. 시스템의 구성 요소가 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍처가 정의도는 것이 아니다