## 부분적 경계

- 아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다
- 이렇게 선행적인 설계를 탐탁지 않게 여길수도 있다(에자일 진형의 YAGNI에 위반 되기도 함)
- 이럴 경우 부분적 경계(partical boundary)를 구현해볼 수 있다

### 마지막 단계를 건너뛰기

- 부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다
    - 쌍방향 인터페이스도 그 컴포넌트에 있고, 입/출력 데이터 구조도 거기에 있으며, 모든 것이 완전히 준비되어 있다. 하지만 모두 단일 컴포넌트로 배포한다
- `이럴 경우 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다. 하지만 다수의 컴포넌트를 관리하는 작업은 하지 않아도 된다`
    - 추적을 위한 버전 번호도 없으며, 배포 관리 부담도 없고 이차이는 가볍지 않다

### 일차원 경계

<img src = "../img/IMG_5451.jpg" width = "600" height = "300">

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 바운더리 인터페이스를 사용한다
- 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 떄도 비용이 많이 든다
- 위 그림은 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 구조이다
    - 이는 전통적인 전략 패턴(strategy pattern)을 사용한 전형적인 사례다
    - ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceImple 클래스가 구현한다
    - Client를 ServiceImple로부터 격리시키는 의존성 역전이 이미 적용이 되었기 때문에 미래를 준비하고 있다고 볼 수 있다
- 이 방법은 단점은 다이어그램의 위험천만한 점선 화살표에서 보듯이 이러한 분리는 매우 빠르게 붕괴될 수 있다
    - 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면, 이 점선과 같은 비밀 통로가 생기는 일을 막을 방법이 없다

### 퍼사드

<img src = "../img/IMG_5452.jpg" width = "600" height = "300">

- 위 보다 더 단순한 경계는 퍼사드 패턴(Facade)이다
- 이 경에는 심지어 의존성 역전까지도 희생한다 &rarr; 경계는 Facade클래스로만 간단히 정의 된다
    - 퍼사드 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다
    - 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다 (퍼사드를 통해야한다)
- 하지만 클라이언트가 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다 (단점)
    - 정적 언어였다면 서비스 클래스 중 하나에서 소스 코드가 변경되면 클라이언트도 무조건 재컴파일해야 할 것이다
    - 이러한 구조라면 비밀 통로 또한 쉽게 만들 수 있다

### 결론

- 아키텍처 경게를 부분적으로 구현하는 세가지 방법을 살펴봤다 (다른 방버도 많다)
- 각 방법은 장단점이 다르며 적절하게 사용할 수 있는 상황이 서로 다르다 