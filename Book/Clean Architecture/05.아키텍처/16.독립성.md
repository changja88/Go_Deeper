## 독립성

- 좋은 아키텍처는 다음을 지원해야 한다
    - 시스템의 유스케이스
    - 시스템의 운영
    - 시스템의 개발
    - 시스템의 배포

### 유스케이스

- `시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다`
    - 실제로 아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에도 유스케이스가 최우선 이다
    - 하지만 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다. 행위와 관련하여 아키텍처가 열어 둘 수 있는 선택사항은 거의 없다
    - `아키틱처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 들어내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다`
        - 장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것이다
        - 해당 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 드러날 것이다
        - 이들 행위는 일급 요소(first-entity)이며 시스템 최상위 수준에서 알아볼 수 있으므로 개발자가 일일이 찾아 해메지 않아도 된다
        - 이들 요소는 클래스이거나 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라, 자신의 기능을 분명하게 설명하는 이름을 가질 것ㅇ디ㅏ

### 운영

- 시스템의 운영 지원 관점에서 볼 떄 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다
- 이런 결정은 뛰어난 아키텍트라면 열어 두어야 하는 선택사항 이다
    - 만약 시스템이 단일체(monolith)로 작성되어 모노리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로 서비스 형태가 필요해질 때 개선하기가 어렵다
    - 이에 비해 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않느다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 전환이 쉬워진다

### 개발

- `아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다`
- 콘웨이의 법칙이 적용하는 지점도 바로 여기이다
    - `시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다`
    - 예를 들어 많은 팀으로 구성되었다면 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보해야 한다

### 배포

- `아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다 &rarr; 이때 목표는 즉각적인 베포(immediate deployment)이다`
- 마스터 컴포너트도 포함 되는데, 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다

### 선택사항 열어 놓기

- 좋은 아키텍처는 컴포넌트 구조와 과련된 이 관심사들 사이에서 균현을 맞추고 각 관심사 모두를 만족 시킨다
- 하지만 현실에서는 균형을 잡기가 매우 어렵다 &arr; 때문에 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경 할 수 있도록 선택사항을 열어 둬야 한다

### 계층 결합 분리

- 유스케이스 측면에서 보면, 아키텍처는 모든 유스케이스를 지원하기를 원하지만 모든 유스케이스를 알 수 는 없다
    - 하지만 아키텍트는 시스켐의 기본적인 의도는 분명히 알고 있다. (시스템이 장바구니인지 자재 명세서 시스템인지 ..)
    - 따라서 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에서 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들을 묶는다
- 서로 다른 이유로 변경되는 것은 무엇일까?
    - 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다.
    - 만약 유스케이스가 두 가지 요소를 모두 포함한다면, 아키텍트는 유스케이스에서 UI부분과 업무 규칙 부분을 서로 분리해야한다
    - 이렇게 함으로써 서로 독립적으로 변경할 수 있을 뿐만 아니라, 유스케이스는 여전히 가시적이며 분명하게 유지할 수 있다
    - `예를 들어, UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과는 독립적인 업무규칙, 데이터베이스등의 게층으로 나루 수 있다`
        - 입력 필드 유효성 검사는 애플리케이션 자체와 관련된 업무, 계좌의 이자 계산이나 재고품 집계는 도메인 관련된 업무

### 유스케이스 결합 분리

<img src = "/Users/hyun/Desktop/Master/Book/Clean Architecture/05.아키텍처/IMG_5425.jpg" width = "600" height = "300">

- 서로 다른 이유로 변경되는 것에는 유스케이스 자체도 포함된다
    - 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 틀림없이 다른 속도로, 그리고 다른 이유로 변경된다
- `유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조가이기도 하다`
    - 각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스 기능의 일부를 사용한다
    - `따라서 시스템을 수평적 계층으로 분할하면서 동시에 계층을 가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다`
    - 이와 같이 결합을 분리하려면 주문 추가 유스케이스의 UI와 주문 삭제 유스케이스의 UI를 분리해야 한다 &rarr; 이런 식으로 시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들의 각 계층에서 서롭
      겹치지 않게 한다
    - 즉, 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고 새로운 유스케이스를 계속해서 추가활 수 있다

### 결합 분리 모드

- 결합을 분리하면 운영 관점에서 어떤 의미가 있을까?
    - 유스케이스에서 서로 다른 관점이 분리되었다면, 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다
    - UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스 업무 규칙과는 다른 서버에서 실행될 수 있다
    - 높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행할 수 있다

### 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다
- 유스케이스 자체도 서로 결합이 분리되면 addOrder유스케이스에 중점을 둔 팀이 deleteOrder유스케이스에 중점을 둔 팀에 개입할 가능성은 거의 없다

### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다
- 실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)할 수 있다
    - 새로운 유스케이스를 추가하는 일은 시스템의 나머지는 그대로 둔 채 새로운 jar 파일이나 서비스 몇개를 추가하는 정도로 단순한 일이 된다

### 중복

- 소프트웨어에서 중복은 일반적으로 나쁜 것이다
    - 하지만 중복에도 여러 종류가 있다. 그중 하나는 진짜 중복이다
    - 이 경우 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에도 반드시 적용해야한다
    - 또 다른 중복은 거짓된 또는 우발적인 중복이다
        - 중복으로 보이는 두 코드의 영역이 각자의 경로로 발전한다면, 이 두 코드는 진짜 중복이 아니다.
        - 예를 들어 유스케이스의 화면 구조고 매우 비슷하다고 가정을 해보자
            - 아키텍트는 이 구조에 사용할 코드를 통합하고 ㅅ깊은 유혹을 강하게 느낄 것이다
            - 하지만 이경우 우발적 중복일 가능성이 높다 &rarr; 시간이 지나면 두 화면은 서로 다른 방향으로 분기하며, 결국 에는 매우 다른 모습을 가질 가능성이 높다
- 유스케이스를 수직으로 분리할 때 이러한 문제와 마주칠 테고, 이들 유스케이스를 통합하고 싶다는 유혹을 받게 될 것이다. 왜냐하면 이들 유스케이스가 서로 비슷한 화면 구조, 비슷한 알고리즘, 그리고 비슷한
  데이터베이스 쿼리와 스키마를 가직 떄문이다
    - `하지만 자동반사적으로 중복을 제거해버리는 잘못을 저지르는 유혹을 떨쳐내라. 진짜 중복인지 확인하라`
- 마찬가지로 계층을 수평으로 분리하는 경우, 특정 데이터베이스 레코드의 데이터 구조가 특정 화면의 데이터 구조와 상당히 비슷하다는 점을 발견 할 수도 있다
    - `이때 데이터베이스 레코드와 동일한 형태의 뷰 모델을 만들어서 각 항목을 복사하는게 아니라 데이터베이스 케코드를 있는 그대로 UI까지 전달하고 싶다는 유혹을 받을 수도 있다`
    - 하지만 조심해야 한다 이런 중복은 우발적 중복이다
    - 뷰 모델을 별도로 만드는 일은 그다지 많은 노력이 들지 않을 뿐만 아니라, 계층 간 결합을 적절하게 분리하여 유지하는 데도 도움이 될 것이다

### 결합 분리 모드(다시)

- 계층과 유스케이스의 결합을 분리하는 방법은 다양하다
- 소스 수준 분리 모드
    - 소스 코드 모듈 사이의 의존성을 제어할 수 있다
    - 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일 하지 않도록 만들 수 있다
    - 이 모드에서는 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신 할 때는 간단한 함수 호출을 사용한다
    - 컴퓨터 메모리에느 ㄴ하나의 실행 파일만 로드 된다
    - `모노리틱 구조라고 부른다`
- 배포 수준 분리 모드
    - 배포 가능한 단위들 사이의 의존성을 제어할 수 있다
    - 이를 통해 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포 하지 않도록 만들 수 있다
    - 많은 컴포넌트가 여전히 같은 주소 공간에 상무하며, 단순한 함수 호출을 통해 통신할 수 있다. 어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고 프로세스가 통신, 소켓, 또는 공유 메모리를 통해
      통신 할 수 있다
- 서비스 수준 분리 모드
    - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다
    - 실행 가능한 단위는 소스와 바이너르 변경에 대해 서로 완전히 독립적이게 된다
    - `마이크로 서비스 구조라고 부른다`
- 프로젝트 초기 단계는 어떤 모드가 최선인지 알기 어렵다. 사실 프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다
    - 현시점에서 가장 인기 있어보이는 해결책은 단순히 서비스 수준에서의 분리를 기본 정책으로 삼는 것이다
    - 이 방식은 비용이 많이 들고, 결합이 큰 단위에서 분리된다는 문제가 있다 &rarr; 마이크로서비스가 아무리 마이크로 하더라도 충분히 작은 단위에서 분리될 가능성은 거의 없다
    - 또 다른 문제는 시간 측면뿐 아니라 시스템 자원 측면에서도 비용이 많이 든다는 사실이다
- 저자가 추천하는 방향
    - 모놀리틱으로 진행하다가 필요해지는 순간이 오면 배포수준 분리, 서비스 수준 분리로 진화시켜라
    - 이렇게 하기 위해서는 처음부터 준비를 해놓는 것이 좋다 