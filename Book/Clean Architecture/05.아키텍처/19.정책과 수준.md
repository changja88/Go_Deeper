## 정책과 수준

- `시스템이란 정책을 기술한 것이다. 실제로 프로그램의 핵심부는 이게 전부다`
- 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 조깰 수 있다
    - 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다
    - 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다
    - 마찬가지로 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분리해야 한다
- 흔히 아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래포(directed acyclic graph)로 구성하는 기술을 포함한다
- 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다
    - 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다

### 수준

- `수준(level)을 엄밀하게 정의하자면 '입력과 출력까지의 거리'다`
    - 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.
    - 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다
    -

<img src = "./IMG_5438.jpg" width = "600" height = "300">

- 데이터의 흐름은 굽은 실선
- 시스템을 제대로 설계했다면 의존성은 곧은 점선처럼 표시되어야 한다
- 번역 컴포넌트는 이 시스템에서 최고 수준의 텀포넌트인데, 입력과 출력에서 부터 가장 멀리 떨어져 있기 떄문이다
- `주목할 점은 데이터 흐름과 소스코드 의존성이 항상 같은 방향을 가리키지는 않는다는 사실이다 &rarr; 이게 아키텍터의 예술이다`

```
function encrypt(){
  while(true)
    writeChar(translate(readChar()));
}
```

- 위 코드는 잘못된 아키텍처이다
    - 고수준인 encrypt 함수가 저수준인 readChar와 writeChar함수에 의존하기 때문이다

<img src = "./IMG_5439.jpg" width = "600" height = "300">

- 위 다이어그램은 코드의 문제를 개선한 모이다
- 주목할 점은 Encrypt 클래스 CharWrite와 CharReader 인터페이스를 둘러싸고 있는 점선으로 된 경계다
    - 이 경계를 횡단하는 의존성은 모두 경계 안쪽으로 향한다
    - 경계로 묶인 영역이 이 시스템에서 최고 수준의 구성요소다 
    - ConsoleReader, ConsoleWriter 클래스는 입력과 출력에 가깝기 때문에 저수준이다
- `정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다는 사실이다 &rarr; Encrypt, CharReader, CharWriter가 나뉜 기준`


### 결론
- 정책은, 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다