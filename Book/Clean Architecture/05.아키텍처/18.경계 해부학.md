## 경계 해부학

- 아키텍처는 컴포넌트와 컴포넌트들을 분리하는 경계에 의해 정의되며 다양한 형태로 정의 된다

### 경계 횡단하기

- `적절한 위치에서 경계를 횡단하는 비결은 소스코드 의존성 관리에 있다`
- 왜 소스 코드일까?
    - 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소크 코드 모듈도 변경해야 하기 때문이다
    - 경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다

### 두려운 단일체

- 가장 단순하며 가장 흔항 형태는 물리적으로 엄격하게 구분되지 않는 형태이다
    - 이 형태에서는 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에따라 분리되어 있을 뿐이다 &rarr; 소스 수준의 분리 모드
    - 배포 관점에서 보면 이는 단일체(monolith)이라고 불리는 단일 실행 파일에 지나지 않는다
    - 이 처럼 배포 관점에서 볼 때 단일체는 경계가 드러나지는 않지만 실제로 존재하지 않거나 무의미 하지는 않다
- `이런한 아키텍처는 거의 모든 경우에 특정한 동적 다형성에 의존하여 내부 의존성을 관리한다`
    - 동적 다형성 : 런타임에 존재하는 다형성
    - 정적 다형성 : 컴파일 시간에 존재하는 다형성
- 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다

  <img src = "./IMG_5436.jpg" width = "600" height = "300">

    - 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향한다

  <img src = "./IMG_5437.jpg" width = "600" height = "300">

    - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 `동적 다형성`을 사용하여 제어 흐름과는 반대 방향으로 의존성을 역전시킬 수 있다
    - 이렇게 하면 런타임 의존성은 컴파일 타임 의존성과는 반대가 된다
        - 컴파일 흐름 : client -> service -> serviceimpl
        - 의존성 흐름 : client -> service <- serviceimpl
- `중요한 점은 경계(고/저 수준을 나누는)를 넘어 갈 때는 의존성은 저수준에서 고수준으로 화살표가 향한다`
- 모노리틱 구조라도 이처럼 규칙적인 방식으로 구조를 분리하면 개발, 테스트, 배포하는 작업에 큰 도움이 된다
    - 팀들은 서로의 영역에 침범하지 않은 채 자신만의 컴포넌트를 독립적으로 작업할 수 있다
    - 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지가 된다

### 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드럴날 수 있는 가장 단순한 형태는 동적 링크 라이브러리이다
    - 이는 배포 수준 결합 분리 모드에 해당한다
    - 배포 작업은 이들 배포 가능한 단위를 좀 더 편리한 형태로 묶는 일에 지나지 않는다
    - 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일하다
    - 일반적으로 모든 함수가 동일한 프로세서와 주소 공간에 위치하며, 컴포넌트를 분리하거나 컴포넌트 간 의존성을 관리하는 전략도 단일체와 동일핟
- 정적 링크(Static Link)
    - 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하는 방식
    - 즉, 프로그램에서 A라는 외부 함수를 사용했다면, A라는 외부 함수에 대한 정보를 자신이 작성한 프로그램의 실행 파일을 만들 때 복사 해온다
- 동적 링크(Dynamic Link)
    - 실행가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고 해당 모듈의 주소만을 가지고 있다
    - 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로가서 필요한 것을 들고 오는 방식이며, 런타임에 운영체제에 의하여 이루어진다
    - 동적 링킹을 사용하면 A라는 함수에 변화가 생겨도, 그 변화를 적용하기 위해 다시 컴파일하여 다시 링킹할 필요가 없다
    - 즉, 컴포넌트를 동적 링킹을 한다는 말

### 서비스

- 아키텍처의 경계가 물리적으로 가장 강력한 형태가 서비스다
    - 서비스는 자신의 물리적 위치에 구애받지 않는다
    - 서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코에서 동작할 수도 있고, 아닐 수도있다
    - 서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정한다
    - 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느라다 &rarr; 따라서 빈번하게 통신하는 일을 피해야한다
    - `지연에 따른 문제를 고수준에서 처리할 수 있어야 한다`
    - `고수준 서비스의 소스코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예를 들면 URI)도 절대 포함해서는 안된다`
