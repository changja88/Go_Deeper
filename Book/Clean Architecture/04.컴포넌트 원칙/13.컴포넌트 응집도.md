## 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야 할까?
- 원칙
    - REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
    - CCP : 공동 폐쇄 원칙 (Common Closure Principle)
    - CRP : 공통 재사용 원칙 (Common Reuse Principle)

### REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)

- `재사용 단위는 릴리스 단위와 같다`
- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다
    - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다
    - 새로운 버젼이 언제 출시되고 무엇이 변했는지 소프트웨어 개발자들이 알아야 하기 떄문
- `단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 함을 뜻한다`
    - 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다
- '이치에 맞다'라는 격이기 때문에 약한 조언이다
    - 이 조언만으로는 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들기에 약하다는 뜻이다
    - 하지만 원칙 자체는 중요하다
    - 이 원칙은 다음 두가지 원칙에 의해서 보완될 수 있다 &rarr; CCP, CRP는 REP를 엄격하게 제약을 가하는 측명에서 정의한다

### CCP : 공통 폐쇄 원칙 (Common Closure Principle)

- `동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에서 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라`
    - 이 원칙은 '단일 책임 원칙'을 컴포넌트 관점에서 다시 쓴 것이다
    - SRP 에서 단일 클래스는 변경이 이유가 여러 개 있어서는 안된다고 말하듯이, 공통 폐쇄 원칙에서도 만찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다
- 대다수의 애플리케이션에서 유지보수성(maintainability)은 재사용성보다 훨씬 중요하다
    - 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다
- `물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다`
- OCP원칙 과도 밀접하게 관련되어 있다 같은 폐쇄(Closure)뜻이다
- SRP와의 유사성
    - CCP는 컴포넌트 수준의 SRP이다
    - SRP에서는 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다
    - CCP에서는 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라고 말한다
    - 즉, `동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라`

### CRP : 공통 재사용 원칙 (Common Reuse Principle)

- `컴포넌트 사용자들이 필요하지 않은 것에 의존하게 강요하지 말라`
- 공통 재사용 원칙도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할때 도움되는 원칙이다
- CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들을 같은 컴포넌트에 포함해야 한다라고 말한다
    - 이런 컴포넌트 내부에서는 클래스들 사이에 수많은 의존성이 있으리라고 예상할 수 있다
- CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명해준다 그런데 이게 전부가 이니다 &rarr; CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다

- `컴포넌트 A가 컴포넌트 B의 하나의 클래스만 사용하더라도 의존성은 조금도 약해지지 않는다 &rarr; 컴포넌트 끼리는 여전히 의존관계이다`
    - 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다
    - 따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다
    - 바꿔 말하면 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다
        - 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지 해야한다
- 따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기 한다
    - `CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다고 말한다`
- ISP(인터페이스 분리 원칙)와의 관계
    - CRP는 인터페이스 분리원칙의 포괄적인 버전이다.
    - `ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다 CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다`
    - `어잿든 둘다 필요하지 않은 것에 의존하지 말라!`

### 컴포넌트 응집도에 대한 균형 다이어그램

- 응집도에 관한 세 원칙이 서로 상충된다
    - REP와 CCP는 포함(inclusive)원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만단다
    - CRP는 배제 (exclusive)원칙이며, 컴포넌트를 더욱 작게 만든다
- REP (재사용성을 위한 그룹) / 화살표 왼쪽은 포기하는것, 오른쪽은 포기했을 때의 비용
    - CRP(불필요한 릴리스를 피하기 위해 분리하기) &rarr; 불필요한 릴리스가 너무 빈번함
    - CCP(유지보수성을 위한 그룹) &rarr; 컴포넌트 변경이 너무 빈번함
    - REP(재사용성을 위한 그룹) &rarr; 재사용이 어려움

### 결론

- 위 다이어글앰에서 균현을 잡는 일이 중요하다. 심지어 이 균형점은 거의 항상 유동적이다
- `결과적으로 시간이 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다` 