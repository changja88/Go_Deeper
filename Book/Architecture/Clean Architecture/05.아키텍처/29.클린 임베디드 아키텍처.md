## 클린 임베디드 아키텍처 (필요 없음)

- `소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다`
    - 펌웨어(firmware)
        - 하드웨어 발전에 맞춰 수정하기가 어려운 코드
        - ex) 코드에 SQL을 심어 놓은 경우
        - 개발하는 코드 전반에 플랫폼 의존성을 퍼뜨려 놓는 경우
        - 안드로이드 앱 개발자가 업무 로직을 안드로이드 API로부터 분리하지 않는 경우
- `즉, 펌웨어라는 것은 하드웨어 의존성이 있는 코드이고 소프트웨어는 하드웨어 의존성이 없는 코드이며 우리가 추구 해야하는 것은 소프트웨어이다`

### 앱-티튜드 테스트(App-titude test)

- 왜 잠재적인 임베디드 소프트웨어는 펌웨어로 변하는 경우가 많은가?
    - 아마도 동작하게 하는데에만 관심이 있기 때문이다
    - 앱-티튜드 테스트 &rarr; 앱이 동작하는 것만 확인 하는 테스트
- 앱이 동작하는 것은 1차적인 목표이고 하드웨어에 의존하지 않도록 클린 임베디드 아키텍처를 가지도록 설계하는 것이 중요하다

### 타깃-하드웨어 병목현상

- 임베드드 엔지니어는 특별하다
    - 임베디드는 제한된 메모리 공간, 실시간성 제약, 처리완료 시간, 제한된 입출력, 특이한 사용자 인터페이스, 여러 센서와 실제 세상과의 상호작용등 으로 특별하다
    - 하지만 원칙을 적용 못할 정도로 특별하지는 않다
- `임베디드가 지닌 특수한 문제 중 하나는 타깃-하드웨어 병목 현상(target-hardware bottelneck)이다`
    - 임베디드 코드가 클린 아키텍처 원칙을 따르지 않는다면 테스트할 수 있는 환경이 특정 타깃으로 국한 된다
    - 그리고 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목 현상이 발생하여 진척이 느려질 것이다
- 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다
    - 다음 원칙을 따르면 타깃 하드웨어 병목현상을 줄일 수 있다
    - 계층
        - 기본적으로 세 개의 계층이 있다. 하드웨어 &rarr; 펌웨어 &rarr; 소프트웨어
        - 하드웨어가 정의된 이후라면 하드웨어와 나머지 시스템 사이를 분리 해야한다 