## 함수형 프로그래밍

- 함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다
- 이 패러다임에서 핵심이 되는 기반은 람다 계산법이다

### 정수를 제곱하기

```java
public class Squnit {
  public static void main(String args[]) {
    for (int i = 0; i < 25; i++) {
      System.out.println(i * i);
    }
  }
}

```

- 리스프에서 파생한 클로저는 함수형 언어로, 클로저를 이용하면 위 코드를 아래와 같이 구현할 수 있다
    - (println (take 25 (map (fn [x] (* xx)) (range))))
    - println &rarr; 출력한다
    - take 25 &rarr; 처음부터 25까지
    - (map (fn [x] (* xx)) (range)) &rarr; 제곱을
    - (range))))) &rarr; 정수의
- println, take, map, range는 모두 함수다
    - 리스프에서는 함수를 괄호안에 넣는 방식으로 호출한다 (range)는 range함수를 호출한다
    - 표현식 (fn [x] (* xx))는 익명 함수로 곱셈 함수를 호출하면서 인자를 두 번 전달한다
- 자바 프로그램은 가변 변수(mutable variable)을 사용하는데 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다
    - 클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다
    - 즉 함수형 언어에서 변수는 변경되지 않는다

### 불변성과 아키텍처

- 가변 변수가 염려되는 이유
    - 경합(race) 조건
    - 교착상태 (deadlock)
    - 동시업데이트(concurrent udpate)
    - 위 모두 가변 변수로 인해 발생하기 때문

### 가변성의 분리

- OOP는 가변변수를 사용하기 때문에 타협을 해야한다
- 불변성과 관련하여 가장 중요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다
    - 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다
    - 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다
- 상태변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로 부터 가변 변수를 보호한다
    - 트랜잭션 메모리는 데이터베이스가 레코드를 다르는 방식과 동일한 방식으로 메모리의 변수를 처리한다

### 이벤트 소싱

- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다
    - 은행에서 입금 출금을 처리할때 바로바로 처리하는게 아니라 입금/출금 트랜잭션말을 저장한다
    - 상태가 필요할 경우(잔액 확인)단순히 상태의 시작점부터 모든 트랜잭션을 처리한다
    - 위 상태를 영원히 지속 시킬 필요는 없다 예를 들어 매일 자정에 상태를 계산한 후 저장하게 할 수 있따
- 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다
    - 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다
    - 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다
    - 저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다
    - 이는 소스 코드 버전 관리 시스템이 작동하는 방식과 같다 