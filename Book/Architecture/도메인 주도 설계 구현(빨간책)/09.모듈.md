## 모듈

- 자바에선 모듈을 패키지라 부르고 C#에선 네임스페이스라 한다

### 로드맵

- 전통적인 모듈과 배포 모듈성이라는 새로운 접근법의 차이점
- 유비쿼터스 언어에 따라 모듈 이름을 짓는 일의 중요성
- 기계적인 모듈 설계가 실제로 모델링의 창의성을 억누르는 상황
- 도메인 모델 밖에서 모듈이 수행하는 역할과, 새로운 바운디드 컨텍스트보다 새로운 모듈을 선호해야 할 때가 언지 인지 알아보자

## 모듈로 설계하기

- DDD 컨텍스트에서 모델 안의 모듈은 서로 간에 높은 응집도를 갖고 있는 도메인 객체를 담는 이름이 붙여진 컨테이너 역할을 수행하며, 각기 다른 모듈에 있는 클래스 사이에 낮은 결합도를 유지하는 것이 목표가 돼야
  한다
- DDD에서 모듈은 유비쿼터스 언어의 중요한 부분이기 때문에 적절하게 이름 짓는 일이 중요하다

#### 모듈 설계 규칙

| 해야 할 일과 하지 말아야 할 일                                                                             | 이유                                                                                                                                                        |
|------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 모델링 개념에 맞춰 모듈을 설계하자                                                                            | 일반적으로 하나나 그 이상의 애그리게잇당 하나의 모듈을 갖게 된다                                                                                                                      |
| 유비쿼터스 언어에 맞춰 모듈을 명명하자                                                                          | DDD의 기본 목적이기도 하지만, 모델링을 하고 있는 개념에 관해 생각하면 자연스럽게 다다르는 결과이기도 하다                                                                                             |
| 모델에서 사용하는 일반적인 컴포넌트 타입이나 패턴에 따라서 기게적으로 모델을 생성하지 말자                                             | 예를 들어 모든 애그리게잇을 하나의 모듈로, 모든 서비스를 다른 하나의 모듈로, 모든 팩토리를 하나의 모듈로 분리 한다면 모듈의 장점을 전혀 취할 수 없다. DDD적 사고 방식이 아니라 단순히 현재 문제를 풀기 위해 사용할 컴포넌트의 유형이나 패턴에 관해서만 생각하게 만든다 |
| 느슨하게 결합된 모듈을 설계하자                                                                              | 모듈 사이에 독립성을 최대한 보장한다면 느슨하게 결합된 클래스와 같은 이점을 취할 수 있다. 이를 통해 모델링 개념을 유지 관리하고 리팩토링하는 일이 쉬워진다                                                                  |
| 결합이 필요하다면 짝이 되는 모듈 사이에서 비순환적 의존성이 형성되도록 노력하자(짝이 되는 모듈은 설게의 측면에서 같은 '수준'에 있거나, 크기나 미치는 영향이 유사하다 | 모듈이 상호 간에 완전히 독립적이기란 거의 불가능하며 실용적이지도 않다. 결국 도메인 모델이라는 자체가 어느 정도의 결합도를 내포한다. 그러나 짝이 되는 두 모델 사이의 의존성을 단순히 단방향적으로 만든다면, 컴포넌트의 커플링을 줄일 수 있다                   |
| 자식 모듈과 부모 모듈 사이에 규칙은 느슨하게 하자                                                                   | 부모 모듈과 자식 모듈 사이의 의존성을 방지하기란 정말 어렵다. 만약 가능하다면 비순화적 의존성을 갖도록 노력해보고, 피할 방법이 없다면 순환적 의존성을 허용토록 하자(예를 들어 부모는 자식을 생성하고, 자식은 식별자를 통해서만 부모를 참조해야한다)               |
| 모듈을 모델의 정적인 개념에 따라 만들지 말고, 모듈이 담고 있는 객체에 맞추도록 하자                                               | 모델의 개념이 시간의 흐름에 따라 변화하면서 여러 모습과 행동과 이름을 갖게 된다면, 이와 같은 개념을 담는 모듈 역시도 생성되거나 이름을 변경하거나 삭제돼야만 할 가능성이 높다. 필수적이진 않지만, 되도록이면 해당하는 이름이 맞지 않음을 발견했다면 리팩토링하자        |

- 논리적으로 응집도는 하나의 배포 단위로 패키징하는 방법과 관련 있다
    - 자바 에코시스템에선 여전히 JAR 파일을 배포의 단위로 생각하지만, 새로운 접근법에 따르면 버전에 따라 조립할 수 있게 된다 (OSGI번들이나 JIGSAQ모듈)
    - 이런 종류의 모듈/번들은 DDD모듈과는 조금 다르지만 서로를 보완해줄 수 있다. 결국 느슨하게 결합된 설계의 DDD모듈은 OSGI 번들을 만들거나 직소를 통해 모듈화할 때 기여하게 된다

## 기본 모듈 명명 규칙

- 자바와 C# 모두에서 모듈의 이름은 계층적 형태를 반영한다. 해당 계층의 각 단계는 마침표에 의해 구분된다
    - 이름을 사용할 때는 최상위 도메인에서 시작되며, 해당 조직의 도메인 이름이 그 뒤를 있는다
    - 자바 : com.sassovation | C# : SaaSOvation
- 고유한 최상위 수준 이름을 사용함으로써 프로젝트에서 사용하고 있는 써드파티 모듈과의 네임스페이스 충돌을 방지하고, 다른 사용자가 모듈을 사용할 떄 겪을 수 있는 충돌을 막아준다

## 모델을 위한 모듈 명명 규칙

- 모듈 이름에서 다음으로 이어지는 부분은 바운디드 컨텍스트를 나타낸다
    - com.sassovation.identityaccess
    - com.sassovation.collaboration
    - com.sassovation.agilepm

- 전통적인 계층 아키텍처와 핵사고날 아키텍처에서 사용할 수 있다
    - 특정 모듈이 도메인 안에 있다는 점을 나타낸다
    - 요즘 계층을 사용하는 시스템에 일반적으로 주입 스타일의 핵사고날을 사용해 계층을 관리한다
    - 핵사고날에선 애플리케이션의 '안쪽' 영역이 있으며, 여기엔 도메인에 해당하는 부분이 포함된다
    - domain에 해당하는 구획에는 인터페이스/클래스가 전혀 없고, 더 낮은 수준의 모듈을 위한 컨테이너 역할만을 수행한다
    - com.sassovation.identityaccess.domain
    - com.sassovation.collaboration.domain
    - com.sassovation.agilepm.domain
- 여기서 모델의 클래스가 정의되기 시작한다. 이 패키지 수준은 재사용 가능한 인터페이스와 추상 클래스를 포함할 수 있다
    - com.sassovation.identityaccess.domain.model
    - com.sassovation.collaboration.domain.model
    - com.sassovation.agilepm.domain.model
    - 엔티티와 값 객체를 위한 추상 기본 클래스를 둘 수 있다
        - ConcurrencySafeEntity
        - DomainEvent
        - DomainEventPublisher
        - DomainEvenySubscriber
        - DomainRegistry
        - Entity
- 도메인 서비스를 domain.model 모듈 밖에 두기를 선호한다면 여기에 짝을 만들어줄 수도 있다
    - com.sassovation.identityaccess.domain.service
    - com.sassovation.collaboration.domain.service
    - com.sassovation.agilepm.domain.service
    - 여기에 도메인 서비스를 둬야 한다는 요구사항은 없다. 이를 모델에서 중간 단위 서비스를 담는 작은 게층이라 생각하거나 이런 계층을 둘러싸고 있다고 생각한다면 여기에 둘 수 있다
- 모델과 서비스를 두 패키지로 나누지 않을 떈, model 모듈을 버리고 모든 모델 모듈을 domain 아래에 바로 둘 수도 있다
    - com.sassovation.identityaccess.domain.conceptname
    - 이는 확실히 불필요해 보이는 한 단게를 제거해준다
    - 하지만 추후에 domain.service 하위 모듈에 몇 가지 도메인 서비스를 두기로 결정한다면 어떻게 될까?
        - 그런 시점이 오면 domain.model이란 하위 모듈을 생성해두지 않았다는 점이 실망하게 될 것이다
- 이름에 영향을 주는 요소 중 가장 중요하게 고려해야 하는 부분이 있다
    - 우리가 도메인을 개발하지 않았다는 점을 잊지 말아야 한다
    - 도메인이란 우리가 일하고 있는 비즈니스에 해당하는 노하우를 담고 있는 영역 일부다
    - 우리가 설계하고 구현하는 대상은 도메인의 모델이다
    - `따라서 최종적으로 모델의 모듈에 대해 이름을 지을 땐 domain.model이 가장 적절해 보인다`

## 애자일 프로젝트 관리 컨텍스트의 모듈

- 현재 사스오베이션의 핵심 도메인은 애자일 프로젝트 관리 컨텍스트이므로, 그에 해당하는 모듈이 어떻게 설계되는지 살펴보다
- 우선 프로젝트오베이션 팀은 tenant, team, product와 같은 세 가지 최상위 수준 모듈을 선택했다
    - com.sassovation.agilepm.domain.model.tenant
        - [value object] TenantId
    - 여기엔 식별자와 액세스 컨텍스트에서 비롯됀 특정 테넌트의 고유 식별자를 담게되는 단순한 값 객체인 TenantId가 들어 있다.
- team 모듈은 제품 팀을 관리하기 위해 사용할 애그리게잇과 도메인 서비스를 담고 있다
    - com.sassovation.agilepm.domain.model.team
        - [service] MemberService
        - [aggregate root] ProductOwner
        - [aggregate root] Team
        - [aggregate root] TeamMember
        - 세 가지의 애그리게잇과 하나의 도메인 서비스 인터페이스가 있다

## 다른 계층 속의 모듈

- 어떤 아키텍처를 선택하든, 항상 모델에 해당하지 않는 컴포넌트의 모듈을 생성하고 이름을 붙여야 한다
    - 여기선 기존의 계층 아키텍처에서 사용할 수 있는 옵션은 무엇인지 논의하는데, 이는 계층 아키텍처뿐만 아니라 그 밖의 다른 아키텍처 스타일에도 적용할 수 있다
- 도메인 모델을 다루는 애플리케이션에서 사용되는 전형적인 계층적 아키텍처에선 `사용자 인터페이스 | 애플리케이션 | 도메인 | 인프라`와 같이 계층을 쌓게 된다
    - 애플리케이션의 필요에 맞춘 각 계층별 컴포넌트의 유형에 따라 각 계층에 속하는 모듈도 달라지게 된다
- 사용자 인터페이스 계층
    - 리소스는 XML, JSON, HTML 등의 표현 상태를 만들어서 GUI와 시스템 클라이언트에게 서비스를 제공할 수 있다
    - 그러나 GUI지원의 경우, 레스트풀 리소스는 표현을 만들 때 프레젠테이션 레이아웃을 포함시켜선 안 된다
    - 그 대신, 다양한 마크업(XML, HTML)과 직렬화 포맷(XML, JSON, 프로토콜 버퍼)으로 작성된 단순한 표현만을 만들어야 한다
    - 따라서 REST를 지원하는 사용자 인터페이스 게층에선 적어도 다음과 유사한 이름의 두 가지 모듈을 마련하게 된다
        - com.sassovation.agilepm.resource
        - com.sassovation.agilepm.resource.view
    - 레스트풀 리소스는 resource 패키지 안에서 유지 관리돼야 한다
    - 표현에 관한 순수한 관심사는 하위 패키지인 view(선호에 따라 presentation)내의 컴포넌트로서 제공돼야 한다
- 애플리케이션 계층에선 다른 모듈을 포함할 수 있으며, 이때는 각 모듈마다 하나의 서비스 타입을 다루도록 구성할 수 있따
    - com.sassovation.agilepm.application.team
    - com.sassovation.agilepm.application.product
    - com.sassovation.agilepm.application.tenant
    - 레스트풀 서비스 리소의 설계 원칙과 마찬가지로 애플리케이션 계층의 서비스는 도움이 될 경우에만 하위 모듈로 나눈다
    - 예를 들어 식별자와 액세스 컨텍스트에 소수의 애플리케이션 서비스만 있다면 팀은 이를 주 모듈 안에 두기로 결정 한다
        - com.sassovation.identityacces.application

## 바운디드 컨텍스트보다 모듈

- 응집도 있는 도메인 모델 객체를 여러 모델로 나눌지, 하나로 유지할지 결정해야 할 때 신중해야 한다
    - 때론 올바른 실제 도메인의 언어가 확실하게 보일 수도 있지만, 어떨 땐 용어가 애매할 수도 있다
    - 용어가 애매하고 컨텍스트적 경계를 만들지 여부가 분명치 않을 땐, 우선 이를 나누지 않고 하나로 유지하는 편을 고려하자
    - 이 접근법은 분리를 위해 두꺼운 바운디드 컨텍스트를 사용하는 대신, 좀 더 얇은 모듈의 경계를 활용한다
- 응집도 높은 도메인 객체를 모듈화하고 응집력이 없거나 낮은 객체를 분리하기 위해 모듈을 사용하자 
      