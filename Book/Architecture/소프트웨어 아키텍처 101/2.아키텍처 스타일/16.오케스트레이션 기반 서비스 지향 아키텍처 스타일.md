## 오케스트레이션 기반 서비스 지향 아키텍처 스타일

- 아키텍처 스타일은 예술 활동처럼 그것이 진화한 시대의 맥락에서 이해해야 한다
- 특히 이 아키텍처에 꼭 해당되는 말이다. 아키텍처 결정에 영향을 주는 외부 요인들이 조합되어, 얼핏 논리적으로 보이지만 궁극적으로는 재앙과도 같은 조직 철학과 결부되어 얼토당토 않은 이 아키텍처가 탄생하게 되었다
- 실로 이 아키텍처는 한 조직의 아이디어가 개발 프로세스에서 가장 중요한 부분을 어떻게 망쳐놓는지 잘 나타낸 사례이다

### 역사와 철학

- 이 아이텍처가 나왔던 1900년대 후반에는 다양한 외부 여건 탓에 어쩔 수 없이 제약이 많은 분산 아키텍처를 구축했다
    - 오픈 소스 운영 체제를 프로덕션에 사용하기에는 신뢰감이 부족했으므로 운영 체제는 많은 비용을 들여 시스템 단위로 라이센스를 구매했다
    - 데이터베이스 역시 라이센스 체계가 복잡했다
    - 그 결과, 아키텍트는 최대한 재사용하는 것을 목표로 삼게 되었고, 실제로 모든 형태의 재사용은 이 아키텍처의 중심 철학이 되었다
- 이 아키텍처 스타일은 아키텍트가 기술 분할에 집착하면 어떻게 되는지 잘 보여주는 사례이다

### 토폴로지

<img src = "../img/IMG_5864.jpg" width = "900" height = "400">

- 모든 아키텍처가 위 이미지와 동일한 레이어가 있는 건 아니지만, 내부에 서비스 택소노미(분류체계)를 정립하여 레이어별로 책임을 지운다는 아이디어는 동일하다
- 서비스 지향 아키텍처는 분산 아키텍처이다. 분산 아키텍처는 조직마다 다양하므로 정확한 경계선은 이미지에 표시하지 않았다

### 택소노미

- 이 아키텍처의 핵심은 엔터프라이즈 레벨의 재사용이고 택소노미의 각 레이어를 통해 실현할 수 있다

#### 비즈니스 서비스

- 최상단의 비즈니스 서비스는 진입점 역할을 한다
    - 예를 들어 ExecuteTrade, PlaceOrder 등의 서비스 도메인 행위(domain behavior)를 나타낸다
- 당시에는 각 서비스 바다 "우리가... 비즈니스를 하고 있나요?"라는 질문에 아키텍트가 확답을 할 수 있는지 여부가 일반적인 리트머스 시험지였다
- 이 서비스 정의는 코드는 전혀 없고 입력, 출력, 스키마 정보만 갖고 있다. 서비스는 대부분 비즈니스 유저가 정의하기 때문에 이름도 비즈니스 서비스이다

### 엔터프라이즈 서비스

- 엔터프라이즈 서비스는 세분화된 공유 구현체를 포함한다
    - 일반적으로 개발팀은 특정 비즈니스 도메인(예: CreateCustomer, CalculateQuote)에 관한 원자적 행위를 구현하는 업무를 담당한다
    - 이런 서비스는 오케스트레이션 엔진을 통해 묶인, 단위가 큰 비즈니스 서비스를 구성하는 요솓ㄹ이다
- 이 아키텍처의 재사용 목표 때문에 이렇게 책임을 분리한 것이다
    - 개발자가 정확한 세분도에 맞게 엔터프라이즈 서비스를 구축할 수 있다면 비즈니스 워크플로의 해당 파트를 재작성할 필요가 없다
    - 비즈니스는 재사용 가능한 엔터프라이즈 서비스 형태로 재사용 가능한 자산을 구축할 수 있을 거라고 믿었다
    - 하지만 이런 시도는 실패했다

### 애플리케이션 서비스

- 아키텍처의 모든 서비스에서 엔터프라이즈 서비스와 동일한 레벨의 세분화 또는 재사용이 필요한 것은 아니다
    - 애플리케이션 서비스는 한 번만 사용 가능한 단일 구현체 서비스 이다
    - 예를 들어 어떤 애플리케이션에 자리 공간(geo-lcoation)정보가 필요하지만 조직은 이 애플리케이션을 재사용 가능한 서비스로 구착하는 데 시간과 노력을 쏟길 원하지 않을 수 있다. 이럴 때 어느 한
      애플리케이션 팀이 소유한 애플리케이션 서비스로 문제를 해결할 수 있다

### 인프라 서비스

- 인프라 서비스는 모니터링, 로깅, 인증/인가 등의 운영 관심사를 지원한다
- 이런 서비스는 운영팀과 긴밀하게 협업하는 공유 인프라팀이 소유한 실질적인 구현체인 경우가 많다

### 오케이스트레이션 엔진

- 오케스트레이션 엔진은 이 분산 아키텍처의 요체이다
    - 이 엔진은 비즈니스 서비스 구현체를 서로 엮어주며 트랜잭션 조정과 메지지 변환 등의 기능을 수행한다
    - 마이크로 서비스 아키텍처처럼 서비스마다 데이터베이스가 있는 것은 아니며, 일반적으로 단일 관계형 데이터베이스를 사용한다
    - 따라서 트랜잭셔널 로직은 데이터베이스가 아닌 오케스트레이션 엔진에서 선언적으로 처리된다
- 오케스트레이션 엔진은 비즈니스와 엔터프라이즈 서비스의 관계, 이 둘을 매핑하는 방법, 트랜잭션 경계는 어디까지인지 등을 정의한다
- 이 엔진은 통합 허브(integration hub)역할도 겸하므로 아키텍트가 커스텀 코드를 패키지와 레거시 소프트웨어 시스템에 통합할 수 있다
- 트랜잭셔널 로직을 오케스트레이션 도구에 윔한다는 아이디어는 그럴듯 했다. 하지만 재앙에 가까웠다
    - 트랜잭션을 정확히 어느 레벨까지 세분화해야 할지 알아내기가 더욱 어려워 졌다
    - 3,4개 서비스를 분산 트랜잭션으로 감싸 개발하는 것은 가능했지만, 서비스 간의 적절한 트랜잭션 경계가 어디쯤인지 개발자가 직접 알아내야 했기 떄문에 한층 복잡해 졌다

### 메시지 흐름

<img src = "../img/IMG_5865.jpg" width = "500" height = "700">

- 모든 요청은 오케스트레이션 엔진을 통해 간다. 모든 로직은 오케스트레이션 엔진에 있으므로 심지어 내부 호출을 할 때에도 메시지는 엔진을 경유한다
- 위 이미지에서 서비스 버스는 아키텍터 내부의 모든 호출을 중계하면서 통합 허브와 오케스트레이션 엔진, 두 가지 역할을 한다

### 재사용... 그리고 커플링

- 이 아키텍처의 주된 목표는 서비스 레벨의 재사용, 즉 시간이 지남에 따라 재사용 가능한 비즈니스 행위를 점진적으로 구축하는 능력이다
    - 따라서 아키텍트는 어떻게 하든지 재사용할 기회를 찾아내는게 목표이다

<img src = "../img/IMG_5866.jpg" width = "600" height = "400">

- 위 이미지에서 아키텍트는 보험 회사의 모든 부서에 Customer라는 개념이 포함되어 있다는 사실을 알아낸다
    - 서비스 지향 아키텍처 관점에서는 고객과 관련된 부분을 재사용 가능한 서비스로 빼내 원래 서비스가 표준 고객 서비스를 참조하도록 만든게 최선의 전략이다

<img src = "../img/IMG_5867.jpg" width = "600" height = "400">

- 따라서 위 이미지 처럼 표현할 수 있다
    - 고객의 모든 행위를 하나의 Customer 서비스로 분리함으로써 재사용 목표를 확실하게 달성했다
- 하지만 문제가 발생한다
    - 1> 재사용 위주로 시스템을 구축하다 보니 컴포넌트 간의 커플링이 심하게 발생한다. Customer 서비스를 함부로 변경하면 다른 모든 서비스에 영향을 미치므로 위험하다
    - 2> 하나의 Customer서비스에 고객에 관한 모든 상세 정보를 담아야 한다. 자동차 보험에 가입하려면 운전 면허증이 필요한데 면허증은 사람이 소유한 것이지 차의 소유물이 아니다. 따라서
      Customer서비스는 가령 장애 보험팀에게는 전혀 관심사가 아닌 운전 면허증의 세부 정보까지 갖고 있어야 한다. 즉, 장애 문제를 관리하는 팀이 부가적인 고객 정의의 복잡성까지 떠안을 수밖에 없는
      구조이다

### 아키텍처 특성 등급

- 가장 기술적으로 분할된 범용 아키텍처이고, 실제로 이 구조의 단점에 대한 반발로 인해 마이크로서비스 같은 보다 현대적인 아키텍처가 탄생했다
- 배포성, 시험성 같은 요즘의 엔지니어링 목표는 이 아키텍처에서 점수가 낮다 (이 당시에는 중요한 목표가 아니었다)
- 탄력성 확정성 같은 특성을 일부 지원하지만 구현하기는 상당히 까다롭다


