## 리팩토링

- 이 패턴들은 시스템의 설계를 작은 단계를 통해(아무리 큰 변화라도)변화 시키는 방법에 대해 설명한다
- TDD에서는 리팩토링을 특이한 방법으로 사용한다

### 차이점 일치시키기

- 비슷해 보이는 두 코드 조각을 합치려면 어떻게 해야 할까?
    - 두 코드가 단계적으로 닮아가게끔 수정한다. 이 둘이 완전히 동일해지면 둘을 합친다

### 변화 격리하기

- 객체나 메서드의 일부만 바꾸려면 어떻게 해야 할까?
    - 일단, 바꿔야 할 부분을 격리한다
- 일단 바꿀 부분을 격리하고 나서 바꾸는 작업을 수행하면 작업을 되돌리기도 매우 수월하다는 사실을 알게 될 것이다
- 변화를 격리하기 위해 사용할 수 있는 몇 가지 방법에는 메서드 추출하기(가장 일반적이), 객체 추출하기, 메서드 객체(Method Object)등이 있다

### 데이터 이주 시키기

- 표현 양식을 변경하려면 어떻게 해야 할까?
    - 일시적으로 데이터를 중복시킨다
- 방법
    - 내부에서 외부로 변화시키는 방법은 다음과 같다
    - 내부에서 외부로의 변화라 내부의 표현 양식을 변경한 후 외부 인터페이스를 변화시키는 방벙을 말한다
    - 1> 새로운 포맷의 인스턴스 변수를 추가한다
    - 2> 기존 포맷의 인스턴스 변수를 세팅하는 모든 부분에세 새로운 인스턴스 변수도 세팅하게 만든다
    - 3> 기존 변수를 사용하는 모든 곳에서 새 변수를 사용하게 만든다
    - 4> 기존 포맷을 제거한다
    - 5> 새 포맷에 맞게 외부 인터페이스를 변경한다
    - 때로는 API를 먼저 변화시키기를 원할 때도 있다 그럴 땐 다음과 같이 한다
    - 1> 새 포맷으로 인자를 하나 추가한다
    - 2> 새 포맷 인자에서 이전 포맷의 내부적 표현양식으로 번역한다
    - 3> 이전 포맷 인자를 삭제한다
    - 4> 이전 포맷을 사용하는 것들을 새 포맷으로 바꾼다
    - 5> 이전 포맷을 지운다
- 이유
    - '하나에서 여럿으로'는 항상 데이터 이주시키키 문제를 만들어 낸다
    - TestSutie에서 하나에서 여럿으로 를 적용하려고 하는 상황을 가정해보자 (아래코드)

```
def testSuite(self):
    suite = TesutSuite()
    suite.add(WasRun("testMethod"))
    suite.run(self.result)
    assert("1 run, 0 failed" == self.result.summart())
```

- 이는 아래와 같이 구현될 수 있따 (하나에서 여럿으로 문제의 하나에서에 해당하는 부분)

```
class TestSuite:
    def add(self, test):
        self.test = test
    def run(self, result):
        self.test.run(result)
```

- 이제 데이터를 중복시킬 차례다. 일단 테스틑 컬렉션을 초기화 한다

```
TestSuite
def __init__(self):
    self.tests=[]
    
// test 변수를 설정하는 모든 부분에서 컬렉션도 설정하게 만든다

TestSuite
def add(self, test):
    self.test = test
    self.tests.append(test)
```

- 이제 단일 테스트 대신 테스트 목록을 사용할 수 있게 됐다. 현제 테스트 케이스의 입장에서 볼 떄 이것은 리팩토링이다. 왜냐하면 현재 컬렉션안에는 하나의 요소만 들어갈 수 있기 때문이다

```
TestSuite
def run(self, result):
  for test in self.tests:
      test.run(result)
```

- 이제 쓰이지 않는 인스턴스 변수인 test를 제거한다

```
TestSuite
def add(self, test):
    self.tests.append(test)
```

### 메서드 추출하기

- 길고 복잡한 메서드를 읽기 쉽게 만들려면 어떻게 할까?
    - 긴 메서드의 일부분을 별도의 메서드로 분리해내고 이를 호출하게 한다

### 메서드 인라인

- 너무 꼬여있거나 산재한 제어 흐름을 단순화하려면 어떻게 할까?
    - 메서드를 호출하는 부분을 호출될 메서드의 본문으로 교체한다
- 방법
    - 1> 메서드를 복사한다
    - 2> 메서드 호출하는 부분을 지우고 복사한 코드를 붙인다
    - 3> 모든 형식 매개 변수를 실제 매개 변수로 변경한다

```
public void testSimpleAddition(){
    Money five = Money.dollar(5);
    expression sum - five.plus(five);
    Bank bank = new Bank();
    Money reduced = bank.reduce(sum, "USD");
    assertEquals(Money.dollar(10, reduced);
}

public void testSimpleAddition(){
    Money five = Money.dollar(5);
    expression sum - five.plus(five);
    Bank bank = new Bank();
    Money reduced = sum.reduce(bank, "USD") // 이부분이 다르고 어느게 더 좋은지는 모른다. 중요한건 제어 흐름을 이리저리 바꿔가며 시럼해보기 위해서 메서드 인라인 할 수 있다는 점이다
    assertEquals(Money.dollar(10, reduced);
}
```

### 인터페이스 추출하기

- 자바 오퍼레이션에 대한 두 번째 구현을 추가하려면 어떻게 해야 할까?
    - 공통되는 오퍼레이션을 담고 있는 인터페이스를 만들면 된다
- 방법
    - 1> 인터페이스를 선언한다. 때론 새로 추가될 인터페이스의 이름으로 기존 클래스의 이름을 사용해야 하는 경우가 있는데, 그런 경우라면 인터페이스를 우가하기 전에 기존 클래스의 이름을 변경해주어야 한다
    - 2> 기존 클래스가 인터페이스를 구현하도록 만든다
    - 3> 필요한 메서드를 인터페이스에 추가한다. 필요하다면 클래스에 존재하는 메서드들의 가시성을 높여준다
    - 4> 가능한 모든 곳의 타입 선언부에서 클래스 이름 대신 인터페이스 이름을 사용하게 바꾼다

### 메서드 옮기기

- 메서드를 원래 있어야 할 장소로 옮기려면 어떻게 해야 할까?
    - 어울리는 클래스에 메서드를 추가해주고 그것을 호출하게 하라

### 메서드 객체

- 여러 개의 매개 변수와 지역 변수를 갖는 복잡한 메서드를 어떻게 표현할까?
    - 메서드를 꺼내서 객체로 만든다

