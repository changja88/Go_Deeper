## 프로그래밍 이론

- 프로그래밍 이론은 새로운 문제가 발생해도 해결책을 찾을 수 있도록 도와준다

## 가치

- 훌륭한 프로그래밍에 있어서 공통적인 가치는 커뮤니케이션, 단순성, 유연성이다

### 커뮤니케이션

- 개발자가 코드를 쉽게 이해하고, 수정하고, 사용할 수 있다면, 그 코드는 개발자가 커뮤니케이션을 하고 있다고 이야기할 수 있다

### 단순성

- 복잡도를 낮추면 프로그램을 읽고 사용할고 수정하는 사람들이 프로그램을 훨씬 빨리 이해할 수 있다
- 어떤 경우 해결하려는 문제 자체가 복잡해서 일정 수준 이상의 복잡도가 불가피한 경우도 있다.
- 때로는 드물게 과도한 단순화가 커뮤니케이션을 저해하는 경우도 있다. 단순성보다는 커뮤니케이션이 좀 더 중요하다

### 유연성

- 유연성은 비효율적인 코딩이나 설계를 정당화해주는 가치이다
- 유연성은 복잡도를 증가시킨다. 예를 들어 사용자 설정 옵션을 제공하게 되면, 설정 파일을 사용해야 하고 프로그램에 여러 옵션을 처리하는 로직이 들어가야 한다

## 원칙

- 구현 패턴은 그냥 나온 것이 아니다. 각 패턴은 커뮤니케이션, 단순성, 유연성의 가치 중 하나 이상을 내포하고 있다
- 원칙은 가치에 비해 좀더 프로그래밍에 특화된 개념이지만, 가치와 마찬가지로 일반적인 생각을 담고 있으며 패턴의 근간을 이룬다
- 원칙을 명확하게 알고 있다면 새로운 패턴을 만들 수 있다

### 지역적 변화 (Local Consequences)

- 코드를 수정할 때 함께 바꿔야 하는 부분을 최소화 하라
- 구현 패턴을 사용하는 중요한 이유는 프로그램 수정 비용을 낮추기 위함이므로, 지역적 변화의 원칙은 여러 패턴의 근간이 된다

### 최소 중복(Minimize Repetition)

- 지역적 변화를 돕는 다른 원칙은 최소 중복의 원칙이다
- 같은 코드가 여러 곳에서 반복된다면, 그 중 하나를 바꿀 때 다른 중복된 코드들도 모두 바꿔야 할지 여부를 결정해야 한다
- 중복을 없애는 한 가지 방법은 프로그램을 여러 작은 부분-짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지-으로 나누는 것이다
- 프로그램에서 동일한 부분, 유사한 부분, 다른 부분을 명확히 표현한다면, 프로그램을 읽고 이해하기 쉽고, 따라서 프로그램 수정 비용도 낮아질 것이다

### 로직과 데이터의 결합

- 지역적 변화의 원칙에 근거한 다른 원칙은 로직과 데이터를 함께 유지하는 것이다
- 데이터와 그 데이터를 처리하는 로직을 밀접하게, 가급적 같은 메소드 혹은 같은 객체 내에, 최소한 같은 패키지 내부에 배치하라
- 프로그램을 수정하는 경우, 로직과 데이터를 모두 고쳐야 할 경우가 많기 때문

### 대칭성(Summetry)

- add()메소드가 있는 곳에 remove()메소드가 있다
- 프로그램에서 대칭성을 찾아내서 명확히 표현해주면 코드를 읽기가 수월해진다
- 대칭성 예시
    - input(), count++, output()
    - input(), incrementCount(), output()
    - input(), tally(), output()
    - 위 세개 중에서 세번째가 대칭성이 가장 좋다
    - incrementCount 는 메소드 구현을 반영한다. 대칭성을 따르면 왜 카운터를 증가시키는지 생각해봐야 한다

### 선언적 표현

- 명령형 프로그래밍(imperative programming)은 강력하고 유연하지만 프로그램을 이해하기 위해서는 수행 흐름을 따라가야 한다
    - 즉, 머릿속에 컴퓨터의 수행 상태를 생각하면서 제어 흐름과 데이터 흐름을 추적해야 프로그램을 이해할 수 있다
- 수행 순서가 중요한 구문이나 주건부 구문이 없는 일반 구문의 경우, 선언적 표현을 통해 코드를 작성하는 것이 이해하기 쉽다

### 변화율

- 함께 변하는 로직과 데이터를 함께 관리하고, 변화율이 다른 로직과 데이터는 분리하는 것이다
- 변화율을 시간적 대칭성으로 볼 수 있다
- 예를 들어 세금 관련 소프트웨어를 작성한다면, 일반 세금 계산 루틴을 특정 년도 세금 계산 루틴과는 별도로 구현해야 한다
- 변화율은 데이터에도 적용된다
    - 하나의 객체에 있는 모든 필드는 가급적 함께 변해야 한다
    - 예를 들어 특정 메소드가 수행될 때만 사용되는 필드는 그 메소드의 지역 변수로 선언되어야 한다
- `어떤 객체에 다른 필드와는 독립적이지만 서로 의존적인 2개의 필드가 있다면, 그 두개의 필드는 별도의 도우미 객체에 넣는 편이 낫다`

```
setAmount(int value,String currency){
    this.value=value;
    this.current=currency;
}
```

```
setAmount(int value,String currency){
    this.value=new Money(value,currency);
}
```

```
setAmount(Money value){
    this.value=value
}
```

- 위에서 아래로 점점 발전 시킬 수 있다
- 위 예에서 value필드와 currency 필드는 대칭적으로 함께 변화하지만, 객체 내의 다른 필드와는 대칭적이지 않다
- `대칭적인 필드를 별도의 객체에 묶어서 대칭성을 표현하면, 코드를 읽는 다른 사람에게 의도를 잘 전달할 수 있고 중복을 줄일 수 있으면 코드 수정에 대한 영햐을 제어하기 쉬워진다`