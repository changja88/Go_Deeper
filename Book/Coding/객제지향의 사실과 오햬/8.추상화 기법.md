## 추상화 기법

<img src = "./img/IMG_5659.jpg" width = "900" height = "400">

- 다음은 추상화 기법의 종류를 나타낸 것이며, 각 추상화 기법은 복잡성을 낮추기 위해 사물의 특정한 측면을 감춘다
    - 분류와 인스턴스화(타입의 종류!! &rarr; 타입의 종류를 만들때 사용, A타입, B타입)
        - 분류는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다
        - 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다
    - 일반화와 특수화 (타입의 계층!! &rarr; 타입의 계층을 만들때 사용, 슈퍼타입/서브타입)
        - 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다.
        - 일반화의 역을 특수화라고 한다
    - 집합과 분해
        - 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다
        - 집합의 반대 과전은 전체를 부분으로 분리하는 분해 과정이다

### 분류와 인스턴스화

- 개념과 범주
    - 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다
    - 개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다
    - 자동차 범주에 적용되는 개념은 '바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단'이다
    - 범주와 개념은 인간이 실세계를 바라보는 인식의 형태를 빚는다
    - 세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다
        - 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다
        - 어떤 객체를 자동차라는 개념으로 분류하는 것은 자동차라는 개념을 적용할 수 있는 집합의 일원으로 해당 객체를 포함시키는 것을 의미한다
    - 하나하나를 객체라고 하고 하나의 개념을 타입이라고 한다
- 타입
    - 객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다
    - 어떤 객체의 타입이 자동차라고 말할 수 있으려면 자동차가 무엇인지에 대한 명확한 정의가 필요하다
        - 심볼, 내연, 외연 (이전 내용에 있음)
    - 어떤 컴퓨터는 데스크톱 이기도 하면서 노트북 컴퓨터일 수도 있다. 즉 한 객체가 한시점에 복수의 타입에 속할 수 있다
        - 한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류라고 하고 여러 타입에 속할 경우 다중 분류라고 한다
        - `하지만 대부분의 객체지향 언어는 단일 분류만을 지원한다`
            - 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다
            - 다중상속과는 다르다. 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다. 반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가
              서로 다른 타입의 인스턴스가 되도록 허용한다
            - 만약 객체가 타입을 변경 할 수 있다면 이를 동적 분류라고 하고 변경 할 수 없다면 정적 분류 라고 한다
            - 하지만 대부분의 언어는 일단 클래스로 부터 인스턴스를 생성한 후 클래스를 변경할 수 있는 방법을 제공하지 않는다. 즉 객체의 타입을 변경할 수 없다 &rarr; 정적 분류만 허용한다

### 일반화와 특수화

- 범주의 계층
    - 린네의 분류체계 (린네가 만듬) &rarr; 계, 문, 강, 목, 과, 속, 종 으로 점점 특수화됨
    - 즉, 계층 구조로써 좀 더 세부적인 범주가 하위에 위치한다
    - 하위에 위치한 범주는 상위에 위한 범주의 특수화라고 한다
- 서브타입
    - 객체지향에서 범주는 개념을 의미하고 개념은 타입을 의미하므로 일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다
        - 따라서 일반적인 타입을 이용해 좀 더 세부적인 타입을 정의함으로써 타입 간의 게층 구조를 구축할 수 있다
        - 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입(supertype)이라고 한다
        - 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype)이라고 한다
        - 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다
    - 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'is-a'규칙을 준수해야 한다
        - 100% 규칙 : 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다
        - is-a규칙 : 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 보통 영어로 subtype is a supertpye 구문으로 확인 가능하다
- 상속
    - 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스간 상속을 사용하는 것이다. 하지만 모든 상속 관계가 일반화 관계는 아니다
    - 일반화의 원칙은 슈퍼타입에 순응해야 한다는 것이면 순응에는 구조적인 순응과 행위적인 순응이 있으며 모두 대체 가능성을 의미한다
        - 구조적인 순응(structural conformance)
            - 100%규칙을 의미한다
            - 즉, 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다
            - 따라서 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다
            - Person이 name이라는 속성을 가진다면 Person의 서브타입은 Employee역시 name이라는 속성을 가질 것이라고 기대할 수 있다. 따라서 Employee는 Person에 대해
              구조적으로 순응하며 따라서 Person을 대체할 수 있다
        - 행위적 순응(behavioral conformance)
            - 타입의 행위에 관한 것이며 행위적으로 대체 가능해야 한다. 흔히 리스코프 치환 원칙이라고 한다
            - Person이 getAge()라는 메시지에 대한 응답으로 나이를 반환한다면 서브타입인 Employee역시 getAge()라는 메시지에 대한 응답으로 나이를 반환해야 한다
            - 클라이언트 입장에서 Employee는 Person에 대해 행위적으로 순응하기 때문에 대체 가능하다
    - 상속은 서브타이핑과 서브클래싱의 두가지 용도로 사용될 수 있다
        - 서브 타이핑(subtyping)
            - 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다
            - 설계의 유연성이 목표이다
            - 인터페이스 상속(interface inheritance)
            - 일반화를 위함, 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 행위적 순응 관계를 의미하며 대체 가능성을 내포한다
            - 가능한 서브클래싱 보다는 서브 타이핑을 추구하는 쪽이 코드를 유연하게 만들기때문에 더 좋다
        - 서브 클래싱(subclassing)
            - 서브클래스가 슈퍼클래스를 대체할 수 없는 경우에는 이를 서브클래싱이라고 한다
            - 코드의 중복 제거와 재사용성이 목적이다
            - 구현 상속(implementation inheritance)
        - 클래스가 다른 클래스를 상속받았다는 사실만으로 두 클래스 간의 관계가 서브타이핑인지, 서브클래싱인지 여부를 결정할 수는 없다
            - 서브타이핑의 전제 조건은 대체 가능성이기 떄문에 서브타이핑인지 여부를 확인하려면 클라이언트 관점에서 실제로 어떻게 사용되고 있는지를 확인해야한다

### 집합과 분해

- 계층적인 복잡성
    - 복잡성은 '계층'의 형태를 띤다
    - 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다
        - 자동차 부붐은 1000개다 보다 자동차는 안정적인 형태(엔진, 프레임 바퀴 트렁크 후드) 가 다섯개 이다 더 단순하다
    - 안정적인 형태의 부분으로 부터 전체를 구축하는 행위를 '집합'이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 '분해'라고 한다
    - `집합의 가치는 많은 수의 사물들을 형상을 하나의 단위로 다룸으로써 복잡성을 줄일 수 있다는 데 있다. 즉 불필요한 세부 사항을 추상화한다`
    - `집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다`
- 합성 관계
    - 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 '합성 관계'를 사용한다
    - 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부를 방지한다
        - 주문 항목은 주문의 일부이므로 이 모델을 다루는 사람은 주문 항목과 관련된 세부 사항은 무시하고 주문과 상품만이 존재하는 것처럼 모델을 다룰 수 있다
- 패키지
    - 합성 관게를 이용해 커다란 객체 그룹을 단순화하더라도 클래스의 수가 많아지면 많아질수록 클래스 간 의존성을 관리하는 일은 어려워 진다
    - 즉 전체적은 구조를 쉽게 이해할 수 있도록 적절한 높이와 적절한 축척으로 소프트웨어를 표현할 수 있어야 한다
    - `이처럼 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지(package)또는 모듈(module)이라고 한다`
    - 패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다
        - 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적은 복잡도를 낮출 수 있다
        - 함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경게를 넘나들 필요가 적어진다
        - 합성 관계가 내부에 포함된 객체드르이 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 `패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다`