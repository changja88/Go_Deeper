## 클래스

- 정의 : '이 데이터들은 함께 사용되는데, 그에 과련된 로직이 이것이다'라는 이야기를 하고 싶을 때 클래스를 사용한다
- 로직을 클래스 단위로 어떻게 구성해야 하는지, 로직 사이의 차이점을 어떻게 효과적으로 표현해야 하는지를 알아야 한다
- 클래스 계층을 구성하는 것은 일종의 압축 기법을 사용하는 것이다
    - 클래스 계층의 사용은 상위클래스의 코드를 모두 하위클래스에 붙여 넣는 것과 같은 효과를 가져온다
    - 다른 압축기법과 마찬가지로, 클래스 계층을 사용하면 코드를 읽기 어려워진다 (하위 클래스를 이해하려면 상위클래스를 이해해야 함으로)
    - 때문에 선별적으로 상속을 사용해야 한다
    - 하위 클래스를 생성하는 것은 "이 클래스는 상위 클래스와 비슷하지만, 약간 다르다"라고 이야기 하는 것이다 (객체지향의 사실과 오해에서 일반화/특수화 관계)
- `다른 클래스의 크기를 너무 비대하게 하지 않으면서 클래스의 수를 줄이는 것은 프로그램을 개선한 것이라 할 수 있다`

### 단순한 상위 클래스 이름

- 이름 중에서도 가장 중요한 것이 클래스 이름이다. 클래스는 프로그램 설계의 핵심이기 때문
- 클래스 이름을 지을 때는 간결성과 표현성 사이에서 고민하게 된다
    - 클래스 이름은 가급적 짧으면서 핵심을 찔러야 하지만, 좀 더 정확한 의미를 전달하기 위해 몇 개의 단어를 사용해야 하는 경우도 있따
    - 이런 딜레마에서 벗어나느 방법은 메타포(은유)를 사용하는 거싱다
    - 메타포를 사용하면 단어 하나만으로 연상작용을 통해 여러 관련 정보와 내포된 의미를 전달 할 수 있다
    - 클래스 이름을 찾는데는 시간이 걸리는 것이 당연한다
        - 구연을 끝내고 나서 찾기도 하고 몇일, 몇년이 걸리기도 하다
        - 다른 사람과 대화중에 적절한 이름ㅇ르 찾을 수도 있다
        - `하지만 중요한 클래스에 대해서는 보통 한 단어로 된 이름을 사용하는 것이 좋다`

### 한정적 하위 클래스 이름

- 하위클래스 이름은 상위클래스와의 유사점과 차이점을 나타내야 한다
- 이 경우에도 간결성과 풍부한 표현성 사이의 고민이다11
    - `하위 클래스의 경우 최상위 클래스와 달리 대화 중에 사용되는 경우가 드물기 때문에 간결성을 포기하더라도 표현성을 택하는 편이 좋다`
    - 보통은 상위클래스 이름에 한두 개의 수식어를 붙여서 정하는 경우가 많다
    - 하지만 하위 클래스 자체로 프로그램의 중요한 개념을 의미하는 경우라면 최상위 클래스와 같이 단순한 이름을 사용해야 한다
- 다단계 클래스 계층(multi-level hierachy)을 사용한 경위 위임을 사용한 경우 위임을 통해 다단계 클래스 계층을 제거 하는 편이 좋다
    - 기계적으로 바로 위의 상위클래스 이름에 수식어를 붙이기 보다는, 코드를 읽는 사람의 입장에서 생각하라
    - 이 클래스는 어떤 클래스와 가장 유사한가?
    - 하위 클래스 이름은 가장 유사한 상위 클래스의 이름을 바탕으로 짓는 것이 좋다

### 추상 인터페이스

- `개발에 관한 오랜 격언 중 하나로, 구현이 아니라 인터페이스에 맞춰 코딩하라는 말이 있다`
    - 이는 설계상의 결정을 필요 이상으로 노출하지 말라는 뜻이다
- `인터페이스란 구현이 빠진 여러 연산의 집합을 의미한다`
- 인터페이스 추가에는 비용이 발생한다
    - 인터페이스를 수를 최대한 늘린다고 해서 소프트웨어 비용이 최소화되는 것은 아니다
    - 따라서 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야 한다
- `자바가 제공하는 추상 인터페이스에 대한 두 가지 메커니즘인 상위클래스와 인터페이스는 수정 시 서로 다른 형태로 비용이 발생한다`

### 인터페이스

- `인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이도, 이외의 내용은 상관하지 않는다"라고 이야기 하는 것과 같다`
- 인터페이스는 다중 상속의 유연성을 제공하면서도 복잡성과 모호성을 갖고 있지 않은 적절하게 균형이 잡힌 메커니즘이다
    - 하나의 클래스는 여러 인터페이스를 구현한다고 선언할 수 있다
    - 인터페이스는 필드를 배제하고 연산만을 나타내므로 사용자는 구현이 변경되더라도 신경 쓸 필요가 없다
- `인터페이스를 사용하면 구현을 바꾸는 것은 쉽지만, 인터페이스 자체를 바꾸기는 쉽지 않다`
    - 인터페이스를 조금이라도 바꾸거나 추가하면, 그 인터페이스를 구현하는 모든 클래스를 수정해야 하기 떄문이다
- 인터페이스를 사용해서 커뮤니케이션에 방해가 되는 한 가지 요인이 있다
    - 모든 연산이 공용(public)이어야 한다는 점이다
- 인터페이스에 이름을 짓는 방법에는 크게 두 가지가 있다
    - 인터페이스를 구현이 빠져있는 클래스로 간주하는 경우, 클래스와 같은 방법을 사용한다
        - 하지만 좋은 이름을 모두 인터페이스에 사용해버려서 막상 클래스에서 사용할 수 있는 이름의 수가 적어지는 단점이 생길 수 있다
        - 이런 방식으로 이름을 지으면, 자바 인터페이스와 상위 클래스 상속 사이에서 어떤 것을 사용할지 나중에 결정할 수 있는 장점이 있다
    - 구상 클래스의 이름을 간결하게 짓는 것이 인터페이스 사용을 숨기는 것보다 코드 커뮤니케이션에 있어 중요한 경우가 있다
        - 이런 경우 인터페이스 이름에는 "I"를 붙이면 된다

### 추상 클래스

- 자바에서 추상 인터페이스와 실제 구현의 차이를 나타내는 다른 방법은 상위클래스를 사용하는 것이다
- `상위클래스는 런타임에 어떤 하위클래스로 교체될지도 모른다는 의미에서 추상적이다`
- 결국 추상 클래스와 자바 인터페이스 장단점은 인터페이스 수정의 용이성과 단일 클래스가 여러 인터페이스를 지원할 수 있는지 여부로 귀결된다
    - 추상 인터페이스를 수정하려면 구현과 인터페이스를 수정해야 하며, 수정시 기존 구현이 마비된다 &rarr; 버전 인터페이스를 사용해야 한다
    - 추상 클래스에는 이런 문제가 없다. 기본 구현을 사용할 수 있는 길이 열려있는 한, 기존 설계를 망가뜨리지 않고 새로운 연산을 얼마든지 추가할 수 있다
- 추상 클래스의 단점은 각 클래스가 단 1개의 상위 클래스만을 지정할 있다는 것이다
    - 다양한 인터페이스의 지원이 필요하다면 인터페이스를 사용해야 한다
- `최사위 클래스를 인스턴스화해서 사용할 가능성이 조금이라도 있다면 인터페이스보다는 추상 클래스를 사용하는 것이 좋다`
    - 쓸데 없이 추상 클래스를 너무 많이 만들게 되는 경우를 필할 수 있다

### 버전 인터페이스

- 인터페이스에 연산을 추가하면 기존 인터페이스가 동작하지 않게 된기 때문에 함부로 추가하기가 어렵다
    - `이런 경우 새로운 인터페이스를 선언해서 기존 인터페이스를 확장(상속)한 후 새로운 연산을 추가할 수 있다`
    - 새로운 기능을 사용하기를 원하는 사용자는 확장된 인터페이스를 사용할 수 있지만, 기존 사용자는 새로운 인터페이스에 대해 알 필요가 없다

```java
interface Command {
    void run();
}
```

- 위 인터페이스가 공개되고 이미 사용된 상황에서 인터페이스를 바꿀 경우 수정 비용이 엄청 나다. 이런 경우 아래 처럼. 버전 인터페이스를 사용해서 해결 할 수 있다

```java

interface ReversibleCommand extends Comand {
    vodi undo();
}
```

### 값 객체

- `객체에는 값 스타일 객체가 있고, 상태 스타일 객체가 있다 또는 복합 스타일`
- 아래 코드는 변치 않는 수학적 값들로 구성된 회계 시스템이다

```java
class Transaction {
    int value;

    Transaction(int value, Account credit, Account debit) {
        this.value = value;
        credit.addCredit(this);
        debit.addDebit(this);
    }

    int getValue() {
        return value;
    }
}
```

- 위의 Transaction 객체의 경우, 일단 생성된 후에 값을 변경하는 것이 불가능 하다. 더구나 객체 생성자는 2개의 Account 객체를 모두 업데이트 해준다
- 따라서 이 코드를 보면 거래가 중간에 중단되는 경우나 거래 금액이 나중에 바뀌는 경우를 미리 걱정할 필요가 없다는 을 알 수 있다
- `값 스타일의 객체에서는 생성자에서만 모든 상태를 설정할 뿐, 다른 경로를 통해서는 필드 값을 변경하면 안된다`
    - 값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다
    - 이러한 객체는 연산을 요청한 쪽에서 저장한다
    - bounds.translateBy(10,20) &rarr; 상태 스타일의 Rectangle 객체
    - bounds = bounds.translateBy(10,20) &rarr; 값 스타일의 Rectangle 객체
- 단점
    - 값 스타일 객체를 사용할 때의 문제점은 성능이다. 모든 객체를 매번 새로 생성하면 메모리 관리에 부담을 줄 수 있다 &raar; 요즘은 무시해라
    - 익숙하지 않은 형태이고, 상태로 된 부분과 값으로 된 부분을 구별하기 쉽지 않다
- 어잿든 중요한 것은 적절한 형태의 객체를 사용 해야 한다

### 특화

- 연산 간의 유사점과 차이점을 부각시키는 방향으로 코드를 작성하면, 프로그램을 읽고 사용하고 수정하기 쉬워진다
- 코드에서 유사점과 차이점을 부각시키면 코드 독자가 명확히 코드를 이해하고 기존 코드가 새로운 요구사항을 처리할 수 있을지 판단할 수 있다
- 또 수정이 필요한 경우 기존 코드를 변형해서 특화하는 것이 좋을지 완전히 새로운 코드를 짜는 것이 좋을지 판단할 수 있다

### 하위클래스

- `하위클래스를 선언하는 것은 "이 객체는 상위클래스와 같다" 이 부부만 제외하면 이라고 말하는 것과 같다`
- `초기에는 분류를 나태내는데 사용하였지만, 상속이 구현을 공휴가 위한 기법이므로 공통된 구현을 갖는 경웨 더 효과적으로 사용될 수 있다는 것을 알게 되었다`
- 상속의 단점
    - 하위클래스를 사용하면 되돌리기가 쉽지 않다. 하위 클래스를 사용한 후 하위클래스가 표현하고자 하는 변형을 효과적으로 나태나지 못한다고 생각되면 하위클래스를 통해 얽혀 있는 코드를 모두 정리해줘야 한다
    - 하위 클래스를 이해하기 위해서는 먼저 상위클래스를 이해해야 하며 상위클래스가 복잡해지면 더욱이 문제가 된다
    - 하위클래스는 상위클래스의 의존을 의미함으로 상위클래스의 수정이 어려워진다
    - 클래스의 상속 계층이 복잡해지면서 위 문제들이 심화될 수 있다
    - 특히 병렬 클래스 계층에서 문제가 심화되는 경우가 많다

<img src = "./img/IMG_5702.jpg" width = "700" height = "250">
<img src = "./img/IMG_5703.jpg" width = "700" height = "250">

- 오른쪽 이미지는 병렬 클래스 계층이다 (대칭 구조)
    - 병렬 클래스 계층을 이용하는 경우, 하나의 클래스 계층에 있는 각 하위 클래스에 대해 다른 클래스 계층에 대응되는 하위 클래스가 필요하다. 이는 일종의 중복으로서 클래스 계층간 암묵적 의존 관계를 형성한다
    - 이런 경우 새로운 기능을 추가하려면 양쪽 클래스 계층을 모두 수정해야 한다
    - 병렬 클래스의 경우 개선이 어려울 수도 있지만 개선 방법을 찾는 것이 현명하다. 왼쪽 이미지의 경우 오른쪽처럼 개선이 가능하다

<img src = "./img/IMG_5704.jpg" width = "500" height = "250">

- `하위클래스를 올바르게 사용하기 위한 키 포인트는 상위클래스의 로직을 여러 개의 메소드로 잘게 쪼개는 것이다`
    - 이는 하위 클래스를 작성 할 때, 각 메소드를 따로 오바라이드할 수 있게 하기 위해서이다
    - 상위 클래스 메소드가 너무 크다면, 위 이미지 처럼 상위 클래스의 메소드를 복사해서 일부를 수정 해야한다
    - 코드를 복사하면 2개 클래스 사이에 암묵적 의존 관계가 생긴다. 이 경우 상위 클래스 코드를 고치려면 복사된 모든 코드를 살펴보고 수정해야 한다
- 하위클래스 사용을 제한하는 마지막 요소는 동적으로 변화하는 로직을 나타낼 수 없다는 것이다
    - 하위클래스를 사용하는 경우, 객체를 생성할 때 그 객체의 목적을 알아야 하며 이후에 바뀔 수 없다
    - 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용하자

### 구현자

- `implements(구현)를 사용하건 extedns(상속)을 사용하건, 같은 프로토콜을 여러 번 구현하는 것은 "코드의 목적에 부합하게 구현된 경우, 이 연산의 내부 구현에 대해서는 신경지 않아도 괜찮다"를 의미한다`
- 결국, 객체와 메시지를 사용하는 방식은 프로그래머의 `의도와 구현을 분리`해서 좀더 명확히 프로그래머의 의도를 나타낸다
- 이러한 표현의 명확성과 유연성을 통해 객체 지향 언어는 프로그래밍 언어의 패러다임을 교체했다

### 내부 클래스

- 어떤 연산을 표현하기 위한 클래스가 필요하지만, 새로운 파일에 완전히 새로운 클래스를 만들고 싶지 않은 경우가 있다
    - 작은 전용 클래스(내부클래스)를 사용하면 클래스 사용에 따른 비용을 지불하지 않으면서도 클래스의 장점을 대부분 취할 수 있다
    - 내부 클래스는 Object 객체만을 상속하는 경우도 있지만 상위클래스를 상속하기도 하는데, 이는 클래스 내부의 사용을 위해 기존 클래스를 약간 수정하는 경우 유용하다
    - 내부 클래스는 감싼 클래스(enclosing class)에 대한 정보를 암묵적으로 전달 받는다. 이는 클래스 간의 관계를 명시적으로 정하지 않으면서도 감싼 클래스의 데이터를 접근할 수 있는 유용한 기법이다

```java

public class InnerClassExample {
    private String field;

    public class Inner {
        public String example() {
            return field; // enclosing class data에 접근이 가능 하다 
        }

        @Test
        public void passes() {
            field = "abc";
            Inner bar = new Inner();
            assertEquals("abc", bar.example());
        }
    }
}
```

### 인스턴스별 행위

- 이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다
- 하지만 이런 제약 사항을 완화하면 새로운 스타일의 표현이 가능하다. 물론 새로운 스타일을 사용하려면 비용이 든다
    - 인스턴스별로 다른 행동을 보이는 경우, 특정 인스턴스의 행동을 이해하기 위해서는 실례를 보거나 데이터의 흐름을 분석해야만 한다
- `코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 편이 좋다`

### 조건문

- `인스턴스별 다른 로직을 수행하게 하는 방법이며, 모든 로직이 한곳에 있게 하는 장점이 있지만, 행동 변경을 위해선느 코드 수정이 불가피한 단점이 있다`

```
public void display(){
    switch(getType()){
      case RECTANGEL:
        //
        break;
      case OVAL:
        //
        break;
      case TEXT:
        //
        break;
    }
}
```

- 위 함수가 Figure클래스의 함수라고 할 경우, Figure 클래스에서 새로운 도형을 지원해야 해야 할 경우 모든 switch 문에 새로운 절을 삽입 해야 한다
    - 또한 기존 코드에 문제가 발생하는 위험을 감수하고, Figure 클래스를 직접 수정 해야한다

<img src = "./img/IMG_5705.jpg" width = "800" height = "250">

- 이 문제는 위이미지 처럼 하위클래스나 위임 중 더 적합한 방법을 사용해서 조건문을 메시지로 바꾸면 해결 할 수 있다
    - `중복되는 조건부 로직이나 분기문의 결과에 따라 로직이 달라지는 경우, 보통 명시적인 로직 대신 메시지를 사용하는 것이 더 좋다`
    - 또한 자주 변하는 조건부 로직의 경우 메시지를 사용하면 다른 분기문에 대한 영향을 최소화하면서 분기문을 단순화할 수 있다
    - `즉, 조건문은 단순성과 지역성(하나의 클래스만 수정)에 장점이 있지만, 광범위하게 사용되는 경우라면 이러한 장점이 문제가 될 수 있다`

### 위임

- `몇 가지 객체 중 하나를 선택해서 작업을 미루는 것`
- 위임은 각 인스턴스에서 다른 로직을 수행하도록 하는 몇 가지 방법중 하나이다
    - 공통으로 사용되는 로직은 위임 클래스를 참조하는 클래스에 들어 있지만, 변형은 여러 객체에 각각 구현된다

```
public void mouseDown(){
    switch(getTool()){
      case SELECTING:
        //
        break;
      case CREATING_RECTANGLE:
        //
      break;
      case EDITING_TEXT:
        //
        break;
    }
}
```

- 이 코드는 앞에서 다른 조건문의 모든 문제를 그대로 지나고 있다
    - 새로운 도구(tool)을 추가하려면 코드를 수정해야 하고, 조건문의 중복(mouseUp(), mouseMove() 등)으로 인해 도구를 새로 추가하기 어렵다
    - 이 경우 하위 클래스도 적당한 해결책이 아니다. 프로그램 수행 도중에 편집기가 도구를 바꿔야 하기 때문이다
    - 하지만 아래와 같이 위임을 통해 코드에 유연성을 부여할 수 있다

```java
public void mouseDown(){
        getTool().mouseDown();
        }
```

- 위임은 인스턴스별 행동을 지원할 뿐 아니라 코드 공유에도 사용할 수 있다
    - Stream 객체에 위임하는 객체는 Stream 객체의 타입이 런타임에 바뀔 수 있다면, 인스턴스별 행동을 사용할 수 있다
    - 또는 다른 사용자와 함께 Stream 구현을 공유하는 것도 가능하다
- 아래처럼 위임을 좀더 응용해서 위임자 클래스(delegator)를 위임 메소드(delegated method)에 인자로 넘겨주는 방식으로 사용하기도 한다

```
// GraphicEditor
public void mouseDown(){
    tool.mouseDown(this);
}
// RectangleTool
public void mouseDown(GraphicEditor editor){
    editor.add(new RectangleFigure());
}
```

- 위임을 사용해서 자기 자신에게 메시지를 보낸다면, 자기 자신이 무엇인지 분명치 않다
    - 아래 코드에서는 RectangleTool은 도형 RactangleFigure를 하나 추가하지만, 자기 자신이 아닌 위임자 클래스인 GraphicsEditor에 추가한다
    - GraphicsEditor는 위임 메소드인 mouseDown()을 통해 전달될 수도 있지만, 아래 코드에서는 단순하게 생성자를 통해 필드에 저장하는 방법을 사용했다
    - GraphicsEditor를 mouseDown의 인자로 전달하면 여러 종류의 Editor클래스에서 이 메소드를 사용할 수 있게 되지만, 이러한 유연성이 중요치 않은 경우라면 그냥 필드를 통해 참조하는 편이
      간단하다

```
// GraphicEditor
public void mouseDown(){
    tool.mouseDown(this);
}
// RectangleTool
private GraphicEditor editor;
public RectangleTool(GraphicEditor editor){
    this.editor=editor;
}
public void mouseDown(GraphicEditor editor){
    editor.add(new RectangleFigure());
}
```

### 플러그인 선택자

- 한 두개의 메소드에만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스 안에 들어가도 좋은 경우
    - 이런 경우 메소드 이름을 필드에 저장해 두고 리플렉션을 통해 메소드를 호출하는 것도 좋다

<img src = "./img/IMG_5706.jpg" width = "800" height = "250">
<img src = "./img/IMG_5707.jpg" width = "400" height = "250">

- 공통 메소드인 runTest()를 구현하는 방식으로 서로 다른 이름을 가진 ListTest 인스턴스는 각각 다른 테스트 메소드를 수행할 수 있었다
- 하지만 테스트 이름을 테스트가 수행될 때 사용할 메소드 이름으로 사용하면 아래와 같이 플로그인 선택자를 구현할 수 있다

```
String name;
public void runTest()throws Exception{
    class[] noArguments=new Class[0];
    Method moethod = getClass().getMehtod(name,noArguments);
    method.invoke(this,new Object[0]);
}
```

- 이 기법을 사용하면 오른쪽 그림처럼 단일 클래스만으로 여러 개의 테스트 구현이 가능하다
    - 하지만 코드 양을 줄이는 기법이 보통 그렇듯, 이러한 코드는 이 기법을 이미 알고 있는 사람만이 이해할 수 있다
- 플로그인 선택자 사용에 따른 비용은 상당하므로, 그비용을 정당화할 수 있는 일부 어려운 문제에만 제한적으로 사용해야 한다

### 익명 내부 클래스

- 인스턴스별 행동을 위해 자바가 지원하는 가른 기법중 하나
- `익명 내부 클래스의 기본 아이디어는 한 곳에서만 사용되는 클래스를 생성해서 일부 메소드를 오버라이드한 후, 지역적으로만 사용하는 것이다`
    - 특정 지역에서만 사용되므로 이러한 클래스에는 이름이 필요 없다
- `익명 내부 클래스를 효율적으로 사용하려면 API가 매우 간단하거나 상위 클래스가 대부분의 구현을 담당하고 있어서 내부 클래스를 쉽개 구현할 수 있어야 한다`
- 익명 내부 클래스는 별도로 테스트 하기 어려워서 복잡한 로직에 적합하지 않다

```
buttonGreen.setOnClickListener(new Button.OnClickListener() {
    @Override
    public void onClick(View view) {
    }
});
```

### 라이브러리 클래스

- 어떤 객체에도 적합하지 않은 기능의 경우 한가지 방법은 빈 클래스를 하나 만들어거 정적 메소드로 구현하는 것이다
- `라이브러리 클래스는 인스턴스화가 불가능한, 라이브러리 메소드만을 갖고 있는 클래스다`
- 라이브러리 클래스는 널리 사용되고 있지만, 메소드 수가 많아질 경우 문제가 발생한다
    - 모든 로직을 정적 메소드로 구현하면, 객체 지향 프로그래밍의 가장 큰 장점인 공유 데이터를 전용 네임 스페이스를 사용하여 표현해서 단순화하는 강점을 잃게 된다
        - 전용 네임 스페이스 &rarr; 클래스의 데이터 (alice.height)
    - 그러므로 가능한 경우 라이브러리 클래스는 객체로 변환하는 것이 좋다
- 라이브러리 클래스를 점진적으로 객체로 바꾸기 위해서는 정적 메소드를 인스턴스 메소드로 바꾸면 된다
    - 물론 정적 메소드가 들어갈 적합한 다른 클래스가 있으면 옮기면 좋다
    - 처음에는 정적 메소드가 인스턴스 메소드에 위임하는 방식을 사용해서 같은 인터페이스를 유지 하는 것이 좋다 