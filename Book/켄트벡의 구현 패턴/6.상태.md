## 상태

- 객체는 외부에 드러나는 행위(behavior)와 행위를 지원하기 위한 상태(state)를 묶어주는 편리한 단위
- 여러개의 상태를 마구잡이로 뒤섞어서 사용한 프로그램은 수정하기 어렵다. 상태를 변경하는 코드의 효과를 예측하기 어렵다.
    - 하지만 객체를 사용하면 참조할 수 있는 상태의 네임스페이스 훨씬 작아지므로, 특정 변화에 의해 상태가 어떤 영향을 받을지 분석하기 훨씬 수월해진다
- 다음 패턴들을 알아본다
    - 상태 : 시간에 따라 변화하는 값을 사용하여 연산하다
    - 접근 : 상태에 대한 접근을 제한해서 유연성을 조절한다
    - 직접 접근 : 객체 내의 상태를 직접 접근한다
    - 간접 접근 : 좀더 나은 유연성을 위해 메소드를 통해 상태에 접근한다
    - 고용 상태 : 클래스의 모든 인스턴스에 적용되는 상태는 필드에 저장한다
    - 가변 상태 : 같은 클래스의 인스턴스마다 다른 상태를 유지해야 할 겨우 상태 맵에 저장한다
    - 외재 상태(Extrinsic State) : 객체와 연동된 특수 상태는 상태의 사용자가 소유하는 맵에 저장한다
    - 변수 : 변수는 상태 접근에 필요한 네임스페이스를 제공한다
    - 지역 변수 : 지역 변수는 단일 범위 내에서만 유효한 상태를 저장한다
    - 필드 : 필드는 객체가 생성될 때부터 소멸될 때까지 상태를 저장한다
    - 파라미터 : 파라미터는 메소드가 활성화된 동안 상태를 전달한다
    - 수집 파라미터(collecting parameter): 여러 개의 메소드를 통해 복잡한 결과를 얻기 위해 파라미터를 전달한다
    - 파라미터 객체 : 자주 사용하는 긴 파라미터 목록은 객체로 만들어서 통합한다
    - 상수 : 변하지 않는 상태는 상수로 저장한다
    - 역할 제시형 작명 : 변수 이름은 연산에서의 역할을 반영하여 짓는다
    - 선언형 타입 : 변수에 대한 일반적 타입을 선언한다
    - 초기화 : 변수 초기화 가급적 선언적으로 한다
    - 열성적 초기화 : 인스턴스가 생성될 떄 필드를 초기화 한다
    - 게으른 초기화 : 초기화 비용이 높은 객체의 경우, 객체가 실제 사용되기 직전에 초기화한다

### 상태

- 상태를 사용하면 코드에 위험 요소가 유입되는 것을 감수해야 한다
    - 상태와 병령 프로그래밍은 잘 맞지 않는다
    - 함수형 프로그래밍 언어에는 변화하는 상태의 개념이 없다 &rarr; 대중적 인기가 없다. 인간의 두뇌는 상태에 적응해 있기 때문
- 객체지향 언어는 상태를 다루는데 적합한 전략이다
    - 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대해 매우 엄격한 접근 권한을 적용해서 "알지 못하는 사이에"상태가 변해버리는 문제를 막아준다
    - 객체를 사용하면 빠르고 정확하게 변수에 대한 모든 접근을 확인할 수 있따
- 효과적으로 상태를 관리하기 위한 키포인트는 유사한 상태를 묶어서 관리하고 각 상태를 별도록 관리하는 걳이다
    - 두 가지 상태가 유사한지 단서
        - 1> 두개의 상태가 동일한 연산 안에서 사용되고
        - 2> 동일한 시점에 생성되고 소멸 되는지

### 접근

- 하나의 프로그래밍 언어는 저장된 값에 대한 접근(accessing stored value)와 계산(invoking computation)으로 나눌 수 있다
- 객체의 목표 중 하나는 저장소를 관리하는 것이다
    - 각 객체는 조그만한 메모리를 갖고 있는 별도의 작은 컴퓨터라고 볼 수 있다
    - 때문에 객체 간의 접근의 용이성을 위해 객체 간의 독립성을 포기하는 것은 바람직하지 않다 &rarr; 전부다 public은 위험하다

### 직접 접근
- 