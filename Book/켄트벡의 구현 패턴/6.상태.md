## 상태

- 객체는 외부에 드러나는 행위(behavior)와 행위를 지원하기 위한 상태(state)를 묶어주는 편리한 단위
- 여러개의 상태를 마구잡이로 뒤섞어서 사용한 프로그램은 수정하기 어렵다. 상태를 변경하는 코드의 효과를 예측하기 어렵다.
    - 하지만 객체를 사용하면 참조할 수 있는 상태의 네임스페이스 훨씬 작아지므로, 특정 변화에 의해 상태가 어떤 영향을 받을지 분석하기 훨씬 수월해진다
- 다음 패턴들을 알아본다
    - 상태 : 시간에 따라 변화하는 값을 사용하여 연산하다
    - 접근 : 상태에 대한 접근을 제한해서 유연성을 조절한다
    - 직접 접근 : 객체 내의 상태를 직접 접근한다
    - 간접 접근 : 좀더 나은 유연성을 위해 메소드를 통해 상태에 접근한다
    - 고용 상태 : 클래스의 모든 인스턴스에 적용되는 상태는 필드에 저장한다
    - 가변 상태 : 같은 클래스의 인스턴스마다 다른 상태를 유지해야 할 겨우 상태 맵에 저장한다
    - 외재 상태(Extrinsic State) : 객체와 연동된 특수 상태는 상태의 사용자가 소유하는 맵에 저장한다
    - 변수 : 변수는 상태 접근에 필요한 네임스페이스를 제공한다
    - 지역 변수 : 지역 변수는 단일 범위 내에서만 유효한 상태를 저장한다
    - 필드 : 필드는 객체가 생성될 때부터 소멸될 때까지 상태를 저장한다
    - 파라미터 : 파라미터는 메소드가 활성화된 동안 상태를 전달한다
    - 수집 파라미터(collecting parameter): 여러 개의 메소드를 통해 복잡한 결과를 얻기 위해 파라미터를 전달한다
    - 파라미터 객체 : 자주 사용하는 긴 파라미터 목록은 객체로 만들어서 통합한다
    - 상수 : 변하지 않는 상태는 상수로 저장한다
    - 역할 제시형 작명 : 변수 이름은 연산에서의 역할을 반영하여 짓는다
    - 선언형 타입 : 변수에 대한 일반적 타입을 선언한다
    - 초기화 : 변수 초기화 가급적 선언적으로 한다
    - 열성적 초기화 : 인스턴스가 생성될 떄 필드를 초기화 한다
    - 게으른 초기화 : 초기화 비용이 높은 객체의 경우, 객체가 실제 사용되기 직전에 초기화한다

### 상태

- 상태를 사용하면 코드에 위험 요소가 유입되는 것을 감수해야 한다
    - 상태와 병령 프로그래밍은 잘 맞지 않는다
    - 함수형 프로그래밍 언어에는 변화하는 상태의 개념이 없다 &rarr; 대중적 인기가 없다. 인간의 두뇌는 상태에 적응해 있기 때문
- 객체지향 언어는 상태를 다루는데 적합한 전략이다
    - 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대해 매우 엄격한 접근 권한을 적용해서 "알지 못하는 사이에"상태가 변해버리는 문제를 막아준다
    - 객체를 사용하면 빠르고 정확하게 변수에 대한 모든 접근을 확인할 수 있따
- 효과적으로 상태를 관리하기 위한 키포인트는 유사한 상태를 묶어서 관리하고 각 상태를 별도록 관리하는 걳이다
    - 두 가지 상태가 유사한지 단서
        - 1> 두개의 상태가 동일한 연산 안에서 사용되고
        - 2> 동일한 시점에 생성되고 소멸 되는지

### 접근

- 하나의 프로그래밍 언어는 저장된 값에 대한 접근(accessing stored value)와 계산(invoking computation)으로 나눌 수 있다
- 객체의 목표 중 하나는 저장소를 관리하는 것이다
    - 각 객체는 조그만한 메모리를 갖고 있는 별도의 작은 컴퓨터라고 볼 수 있다
    - 때문에 객체 간의 접근의 용이성을 위해 객체 간의 독립성을 포기하는 것은 바람직하지 않다 &rarr; 전부다 public은 위험하다

### 직접 접근

- `x = 10 처럼 변수에 직접 접근을 한다는 것의 장점은 '명확성'이지만, 명확성이라는 것은 유연성을 희생하다는 말이다`
- 직접 접근의 단점은 사람의 사고 수준보다 낮은 수준의 세부 구현을 사용한다는 점이다
    - doorRegister = 1; 1을 저장하는 것이 창고 문을 여는 것을 뜻하더라도, 코드를 통해 이런 내용을 전달하는 것은 어렵다
    - 위 코드는 openDoor(); 처럼 표현 할 수 있으며, 객체를 사용하면 door.open(); 으로 표현 할 수 있따
- 직접 접근이 많은 코드는 원활한 커뮤니케이션을 방해하는 요소이다
    - 모든 경우에 적용할 수 있는 직접 접근 사용법을 만들려는 시도가 있었지만, 존재 하지 않는다
    - 필요한 경우에는 생성자 내부에서도 직접접근을 허용하지 않을 수도 있다
    - 결국 의도를 가지고 작성을 해야 한다

### 간접 접근

- 메소드 호출을 통해 상태 변화를 숨길 수도 있다
    - `접근자 메소드를 사용하면 명확성과 직접성을 희생해서 유연성을 얻을 수 있다`
    - 메소드를 사용하는 입장에서는 저장되는 값을 직접 알 필요가 없다. 따라서 기존 코드를 바꾸지 않고도 저장소 결정과 같은 문제를 나중에 변경할 수 있다 &rarr; 유연성
- 추천 정책
    - 내부에서는 직접 접근을 허락하지만, 외부에서는 간접 접근을 사용한다 &rarr; 대부분의 접근에 외부에서 발생하면 설계상 문제가 발생할 수 있다
    - 간접 접근만 사용 &rarr; 명확성이 떨어진다. setter/getter 구현은 간단하지만 간접 접근이 많아지면 코드를 읽기가 어려워 질 수 있다
    - 아래 코드 처럼 2개 이상의 데이터가 의존 관계가 있는 경우에는 간접 접근이 매우 유리 하다
  ```
  Rectangle void setWidth(int width){
    this.width = width;
    area = widht * height;
  }
  ```

### 공용 상태

- `여러 연산에서 같은 데이터를 사용하는 경우에는 클래스에 필드를 선언해서 사용하는 것이 좋다`
    - 예를 들어 좌표를 나타내려면 x,y가 항상 같이 필요하다 이런경우 아래 처럼 필드를 사용해 표현하는 것이 좋다
    - 공통 상태를 사용하면 코드만 봐도 제대로 된 객체를 만들기 위해 필드나 생성자에서 어떤 요소가 필요한지 쉽게 알 수 있다
    - 공용 상태는 범위와 생명기간이 같아야 한다
  ```java
  class Point{
    int x;
    int y;
  }
  ```

### 가변 상태

- 같은 객체에서도 인스턴스에 따라 각각 다른 데이터 요소를 필요로 할 때가 있다. 단순히 값만 다른 것이 아니라, 전혀 새로운 데이터 요소를 필요로 하는 경우이다
    - 값만 다른게 아니라 타입도 다르게 하고 싶은 경우이다
- 가변 상태는 데이터 요소의 이름을 키로하고 값을 데이터로 하는 맵으로 표현 된다

```java

class FlexibleObject {
    Map<String, Object> properties = new HashMap<String, Object>();

    Object getProperty(String key) {
        return properties.get(key);
    }

    void setProperties(String key, Object value) {
        properties.set(key, value);
    }
}
```

- 가변 상태는 공용상태에 비해 훨씬 유연하지만, 코드 커뮤니케이션이 쉽지 않다
- `각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에는 가변 상태의 사용을 정당화할 수있다`
    - 예를 들어 bordered라는 플래그가 참인 경우에만 borderedWidth와 borderColor가 필요한 Widget 클래스의 경우 아래처럼 구성이 가능하다
    - class Widget의 속성으로 해쉬맵 properties가 있고 key, value로 bordered/값, bordered/값, borderColor/값
    - `즉, 플래그 필드에 의해서 사용하지 않을지도 모르는 필드의 경우에는 타입을 몰라도 되는게 정당화 될 수 있다`
- `가능하다면 공용상태를 사용하는 것이 좋다. 경우에 따라 어떤 필드가 필요할지 확실치 않은 경우에만 가변 상태를 사용하는 것이 좋다`

### 외재 상태

- 프로그램의 일부에서만 객체의 특정 상태를 필요로 하는 경우이다
    - 예를 들어 객체가 디스크의 어느 부분에 저장되어 있느야 하는 정보는 데이터 입출력을 담당하는 부분을 제외한 프로그램의 다른 부분에는 의미가 없다
    - 필드를 통해 이러한 데이터를 저장하면 대칭성의 원리를 위배하게 된다
    - 다른 필드는 시스템 전체에 모두 유용하게 사용되기 때문이다
- `어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하는 편이 낫다`
    - 위 예의 경우, 데이터 입출력을 담당하는 부분에서 IndentityMap이라는 맵을 만들고, 객체를 키로 디스크상에 저장된 위치를 데이터로 사용하면 된다
- 단점
    - 외재 상태를 사용하면 객체의 복사가 어려워진다
        - 모든 외재 상태를 올바르게 복사하려면 상태를 어떻게 사용하는지 알아야 히기 때문
    - 외재 상태를 사용하면 디버깅이 어려워 진다
        - 일반적인 디버거는 객체의 외재 상태를 보여주지 않기 때문

### 변수

- `대부분의 경우에는 지역변수, 정적변수(static), 전용변수(private)만 사용해서 객체 간의 의존성을 줄이는 것이 좋다`
    - 사용하는 변수의 종류를 줄이면, 문맥만으로도 현재 사용하는 변수가 지역 변수인지 필드인지 쉽게 구분이 가능하다
- `여러 데이터를 저장하는 변수(컬렉션)의 이름은 복수가 되어야 한다. 읽는 사람 입장에서 값을 하나만 갖고 있는 것과 여럿 갖고 있는 것을 구별하는 것은 중요하다`
- 변수의 생명기간과 범위
    - 생명기간 : 예를 들어 특정 함수가 호출된 이후에 값을 같게 되는 변수가 있을 수 있다. 이런 경우 변수의 생명기간은 범위보다 작으며 좋지 않다
    - 범위 : 변수가 사용될 수 있는 범위
    - `가급적이면 변수의 범위와 생명주기는 가까운것이 좋다 + 같은 범위에서 정의된 변수들은 같은 생명기간을 갖는것이 좋다`
        - (내생각) 클래스의 모든 변수가 초기화 블럭으로 다 할돵되면 좋다 &rarr; 범위 = 생명주기

### 지역변수

- 지역 변수는 변수가 선언된 지점이 속한 범위에서만 접근할 수 있다
- `가급적 정보를 널리 퍼뜨리지 않는 것이 좋다는 원칙에 따라, 지역 변수는 사용되기 직전에 가급적 최소 범위 내에서 선언해야 한다`
- 지역 변수의 역할
    - 컬렉터 : 이후 사용을 위한 정보를 모은다. 때로 컴렉터의 값은 함수를 통해 반환되기도 한다. 이런 경우 이름을 result,results로 짓는 것이 좋다
    - 카운터 : 특정 객체의 수를 정장하는 특수 컬렉터
    - 설명
        - 복잡한 표현을 해야하는 경우, 표현 내용을 지역 변수에 하여 독자의 이해를 돕기 위해 사용
        - 설명을 목적으로 하는 지역 변수는 도우미 메소드로 바꿀수도 있다
    - 재사용
        - 값이 바뀌지만 기존 값을 다시 사용해야 하는 경우, 그 값을 지역 변수에 저장할 수 있다
        - 예를 들어 타임스탬프를 여러 객체에 사용해야 하는 경우, 매번 새로운 타임스탬프를 새로 받아와서 사용하면 시간이 매번 달라지기 때문에 안된다
    - 원소
        - 현재 사용하는 컬렉션의 원소를 저장하기 위해 사용되는 경우
        - 반복문에서 한개의 원소

### 필드

- 필드의 범위와 생명기간은 필드를 갖고 있는 객체와 같다
- 필드의 선언의 클래스의 가장 앞이나 가장 뒤에 한꺼번에 선언하는 것이 좋다
    - 가장 앞 : 코드에서 어떤 필드들이 사용될지 문맥을 제공 &rarr; 일반적이다
    - 가장 뒤 : 행위가 중요하고 데이터는 구현 세부 사항이니 신경 쓸 필요 없음
- 필드 변수는 지역 변수에 비해 용도가 많지 않고 역할은 아래와 같다
    - 도우미
        - 객체의 여러 메소드에서 사용하는 객체를 저장한다
        - 여러 메소드에서 객체를 파라미터로 전달받는다면, 파라미터를 도우미 필드로 바꾸고 생성자에서 필드를 설정하는 방법을 고려할 만하다
    - 플래그
        - 블린 플래그는 "객체가 두 가지 다른 방식으로 동작함"을 의미한다
        - 몇 가지 조건문에서 플래그를 사용하는 것은 괜찮지만 플래그에 따라 결정을 내리는 코드가 중복되어 있따면 전략 필드를 고려해보는 것이 좋다
    - 전략
        - 객체의 연산을 하는 다른 방법이 있음을 나타내는 경우, 그 부분을 수행하는 객체를 필드에 저장하라
        - 객체의 생명기간 동안 연산 방법이 바뀌지 않는 경우라면, 생성자에서 전략 필드를 설정하라
        - 그렇지 않다면 전략 필드를 수정하는 메소드를 제공하라
    - 상태
        - 객체의 행위 양식을 결정한다는 점에서 상태 필드는 전략 필드와 비슷하다. 하지만 상태 필드는 스스로 다음 상태를 설정한다
        - 반면 전략 필드는 다른 객체에 의해 설정한다
        - 상태와 상태 전이가 한 곳에서 표현되지 않으므로, 이런 방식으로 구현한 상태 기계(state machine)코드는 읽기 어렵다.
        - 그러나 상태 사용이 그리 복잡하지 않은 경우라면 괜찮다
    - 부속(component)
        - 부속 필드는 해당 객체가 소유하는 객체나 데이터를 저장한다

### 파라미터

- 비전용 변수(필드 혹은 정적 필드)를 사용하지 않고 상태를 다른 객체에 전달하려면 파라미터를 사용해야 한다
    - `비전용 변수를 사용하면 클래스 간에 강한 의존성이 생겨난다 &rarr; A클래스의 함수가 B클래스의 비전용 변수에 의존`
    - 이런 의존성은 시간이 지나면 강화되는 것이 일반적이므로, 정적 변수와 파라미터를 모두 사용할 수 있는 경우라면 언제나 파라미터를 사용하는 것이 좋다
- `하나의 객체에서 다른 객체에 대한 여러 메시지가 같은 파라미터를 필요로 한다면, 그 파라미터를 호출되는 개체에 포함시키는 것이 나을 수도 있다`
    - 파라미터는 객체를 연결하는 얇은 실과 같지만, 너무 많아지면 나중에는 문제가 될 수 있다
    - 아래 코드 참조

```java
Server s=new Server();
        s.a(this);
        s.b(this);
        s.c(this);
        s.d(this);
        s.e(this);
```

- 위 코드처럼 Server에서 계속 this가 필요한 경우 아에 Server를 만들데 this를 줘버리는 편이 좋다(아래 코드 참조)

```java
  Server s=new Server(this);
        s.a();
        s.b();
        s.c();
        s.d();
        s.e();
```

### 수집 파라미터

- 여러 메소드 호출을 통한 결과를 모으려면 결과를 통합하는 과정이 필요하다
    - 한 가지 방법은 메소드의 결과값을 반환하는 것이다. 이 방법은 값이 정수처럼 단순한 경우 적합하다 (아래 코드)

```
int size(){
    int result = 1;
    for (Node each: getChildren() )
        result+= each.size();
    return result;
}
```

- 하지만 단순한 덧셈이 아니라 좀더 복잡한 방식을 통해 결과를 통합해야 하는 경우라면 파라미터를 전달해서 결과를 수집하는 편이 더 직관적이다(아래 코드)

```
asList(){
    List result = new ArrayList();
    addTo(results); // result를 전달해서 수집하고 있다
    return resuilts;
}
addTo(List elements){
    elements.add(getValue());
    for (Node each: getChildren())
        each.addTo(elements);
}
```

### 옵션 파라미터

- 메소드는 파라미터가 전달되지 않은 경우 기본 파라미터를 사용한다. 이런 경우 반드시 필요한 파라미터를 앞에서 전달하고, 옵션 파라미터는 뒤에 전달한다
    - 이렇게 하면 파라미터를 가급적 바꾸지 않고 옵션 파라미터를 선택적으로 사용할 수 있다

```
public ServerSocket()
public ServerSocker(int port)
public ServerSocker(int port, int backlog)
```

- 위 코드를 보면 생성자에서 옵션 파라미터를 사용했다. 기본 생성자에는 없지만 보조 생성자에서는 backlog를 지정할 수 있다
- 파라미터에 키워드를 사용하는 언어의 경우 옵션 파라미터를 좀더 직접적으로 표현할 수 있다

### 가변인자

- 어떤 메소드는 특정 타입의 파라미터를 여러 개 취할 수 있다
    - 간단한 해결책은 컬렉션을 파라미터로 사용하는 것이다
    - 하지만 이 경우 메소드를 호출하는 쪽이 지저분 해진다 (아래코드)

```
Collection<String> keys = new ArrayList<String>():
keys.add(key1);
keys.add(key2);
object.index(keys);
```

- 위와 같은 문제가 자주 발생함에 따라, 자바에서는 다양한 개수의 인자를 취할 수 있는 메커니즘을 제공한다
    - 가변인자는 항상 마지막 파라미터야 한다

### 파라미터 객체

- 여러 개의 파라미터가 함께 여러 메소드로 전달된다면 이들을 묶어서 하나의 객체로 만드는 것을 고려할 수 있다
    - 파라미터 리스트를 하나의 객체로 바꾼 후, 일부 코드에서 파리미터 객체의 일부 필드만 사용한다면 그에 해당하는 메소드를 파라미터 객체에 만들면 된다

```
setOuterBOunds(x,y,width,height);
setInnerBounds(x+2,y+2,width-4,height-4
```

- 위 코드는 아래처럼 객체를 사용해서 바꿀 수 있다

```
setOuterBounds(bounds);
setInnerBounds(bounds.expand(-2));
```

- 파라미터 객체를 사용하면 코드가 짧아지고, 의도를 좀더 명확히 전달할 수 있다
- 파라미터 객체의 사용을 반대하는 쪽의 주된 논거는 성능이다
    - 파리미터 객체를 생성할 때 시간이 걸리기 때문이다
    - 하지만 실제 현실에서 객체 생성시간이 문제가 되는 경우는 별로 없다

### 상수

- 변화하지 않는 데이터를 프로그램의 여러 부분에서 사용해야 하는 경우가 있다
    - 컴파일할 때 그 값을 알고 있다면 변수를 static final로 선언하고 프로그램에서 그 변수를 참조하게 하는 것이 좋다
    - 보통 상수 변수는 다른 변수들과 구별하기 위해 변수 이름에 대분자만 사용하는 경우가 많다
    - 상수를 사용하는 것이 중요한 이유는 실수를 줄일 수 있고, 그 값의 뜻을 전달 하수 있기 때무니다
    - `또한 흔히 상수는 인터페이스에서 메시지의 종류를 나타내기 위해 사용된다`

### 역할 제시형 작명

- 변수 이름을 어떻게 짓는 것이 좋을까?
- 하나의 변수를 이해하기 위해서는 몇가지 정보가 필요하다
    - 연산에 있어서 변수의 역할은 무엇인가
    - 그 변수에 사용되는 객체는 어떤 것인가
    - 변수의 범위와 생명 기간은?
    - 얼마나 다양한 곳에서 변수가 참조되는가?
- `위의 고려사항을 생각해 볼수 있지만 보통 변수의 역할을 충분히 드러내는 쪽이 좋다`
    - 생명기간, 범위, 타입은 일반적으로 문맥을 통해 전달이 되기 때문

### 선언 타입

- 자바와 같이 타입을 강제하는 언어에서는 변수의 타입을 선언해야 하며, 타입선언을 피할 수 없다면 커뮤니케이션에 활용하는 것이 좋다
- members는 ArrayList이다 라고 말하는 것보다 members는 Collection이다 라고 말하는 것보다 많은 정보를 함축하고 있다
    - 하지만 타입을 일반적인 타입으로 하는 것에 대한 효과가 그리 크지 않기 때문에 가급적 일반적으로 사용하는 정도가 적당하다

### 초기화

- 변수의 상태는 프로그램 작성 이전에 가정을 할 때 도움이 되는 정보를 준다
- `초기화는 변수가 사용되기 전에 알고 있는 상태로 만드는 작업이다`
- 초기화는 가급적 선언과 함께하는 것이 좋다
    - 초기화와 선언을 함께 하면, 한 곳에서 변수에 대한 여러 정보를 얻을 수 있다
    - 하지만 성능(초기화 비용이 큰 경우)이 문제가 되는 경우, 생성과 초기화를 분리 할 수 있다

### 열성적 초기화

- 열성적 초기화는 변수가 선언되거나 생성되자마자 초기화한다 (생성자블럭에서 바로 치과)
    - 열성적 초기화를 사용하면 모든 변수가 초기화 이후에 사용될 수 있음을 보장 한다
    - 가능하다면 변수는 선언문에서 초기화 하는 것이 좋다 &rarr; 독자가 선언 타입과 실제 타입을 쉽게 확인 할수 있다'
    - 모든 필드를 선언문에서 초기화하거나 생성자에서 초기화하면 일종의 대칭성을 얻을 수 있다

```java
class Library {
    List<Person> members = new ArrayList<Person>(); // 선언문에서 초기화 한 경우
}

class Point {
    int x, y;

    Point(int x, int y) { // 생성자에서 초가화 한 경우 
        this.x = x;
        this.y = y;
    }
}
```

### 게으른 초기화

- 초기화 비용이 크다면 가급적 늦추고(사용이 되지 않을 수도 있으므로), 취득 메소드를 만들고 처음으로 해당 메소드가 호출될 때 객체를 최기화 하면 된다 (아래 코드)

```
Library.Collection<Person> getMembers(){
  if(members == null)
    members = new ArrayList<Person>();
  return members;    
}
```
- 게으른 초기화를 사용하면 열성정 초기활르 사용할 때보다 코드를 읽기 어려워 진다