## 메소드

- 개념적으로 임의의 프로그램은 복잡한 제어 흐름이 들어 있는 커다란 루틴이라 볼 수 있다
    - 거대한 루틴에서는 중요한 부분과 덜 중요한 부분을 구별하기 어렵기 때문에 코드를 읽기 어렵다
    - 어떤 기능을 호출하는 쪽과 실제 기능을 구현하는 쪽을 분리하는 것도 어렵다
- 프로그램 로직을 여러 개의 메소드로 나누면 로직 간의 연관성을 나타낼 수 있다
    - 메소드를 클래스로 나누고, 클래스를 다시 패키지 단위로 나누면 더 많은 정보를 전달하게 된다
    - 방대한 연산을 여러 개의 메소드로 나누는 작업은 어렵게 보이지 않지만 현실은 다르다
    - 아래 패턴들을 고려해서 메소드를 나눠야 한다
- 메소드 분할시 고려해야 하는 패턴
    - 조합 메소드 : 다른 메소드에 대한 호출로 메소드를 작성한다
    - 의도 제시형 이름 : 메소드가 의도하는 바를 나타내는 이름을 사용한다
    - 메소드 가시성 : 메소드는 가급적 전용으로 한다
    - 메소드 객체 : 복잡한 메소드는 새로운 객체로 바꾼다
    - 오버라이드 메소드 : 특화를 나타내기 위해 오버라이드를 사용한다
    - 오버로드 메소드 : 같은 연산에 대해 다른 인터페이스를 제공한다
    - 메소드 반환 타입 : 반환 타입에는 가급적 가장 일반적인 타입을 사용한다
    - 메소드 주석 : 코드 자체에서 쉽게 얻을 수 없는 정보는 주석을 통해 나타낸다
    - 도우미 메소드 : 주요 연산을 좀더 명확하게 표현하기 위해 작은 전용 메소드를 사용한다
    - 디버그 출력 메소드 : toString() 을 사용해서 유용한 디버그 관련 정보를 출력한다
    - 변환 : 객체 형변환은 명확하게 표현한다
    - 변환 메소드 : 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공한다
    - 변환 생성자 : 대부분의 변환에 대해서는 원본 객체를 인자로 취하는 변환될 객체의 생성자를 제공한다
    - 생성 : 객체 생성을 명확히 표현한다
    - 완결 생성자 : 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다
    - 공장 메소드 : 좀더 복잡한 객체를 생성할 때, 생성자 대신 정적 메소드를 사용한다
    - 내부 공장 : 좀더 많은 설명이 필요하거나 이후 개선이 필요한 객체 생성의 경우 도우미 메소드로 캡슐화한다
    - 컬렉션 접근자 메소드 : 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공한다
    - 불린 설정 메소드 : 케뮤니세이션 도움이 된다면, 불린 값을 성정하는 두개의 메소드(상태별로 하나씩)을 제공한다
    - 쿼리 메소드: isXXX라는 이름으로 된 메소드를 사용해서 불린 값을 반환한다
    - 동등성 메소드 : equels()와 hashCode()를 함께 정의한다
    - 취득 메소드 : 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공한다
    - 설정 메소드 : 드물게, 메소드를 사용해서 필드 값을 설정한다
    - 안전한 복사 : 접근자 메소드를 통해 전달하거나 전달되는 인스턴스를 복사해서 앨리어스 문제를 회피한다

### 조합 메소드

- 추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성해야 한다 (아래 잘못된 코드 참조)

```
void compute(){
    input();
    flags |= 0x0080;
    output();
}
```

- 위 코드처럼 작성하면 갑자기 추상화 수준이 바뀌면서 흐름이 깨진다
- 상대적으로 짧은 메소드 단위로 코드를 구성할 때 코드 전체의 조망이 쉬우면서도 세부 이해가 쉬운 로직을 작성할 수 있다
- 메소드의 크기를 결정하는 다른 요소는 특화다
    - 적당한 크기로 메소드를 작성하는 경우, 코드를 하위클래스로 복사하거나 여러 개의 메소드를 오버라이드하거나 하지 않고 손쉽게 오바링드가 가능핟
- 메소드를 구성할 때는 추측이 아닌 사실에 근거하라
    - 일단 동작하는 코드를 만들고 구성 방식을 결정하라
    - 코드 구성에 미리 시간을 들이게 되면, 구현 도중 새로 알게 되는 사실 때문에 했던 일들을 반복하는 경우가 많다

### 의도 제시형 이름

- 메소드 이름을 통해서는 메소드의 의도만 전달하고, 그 외 정보는 다른 방식으로 전달하는 것이 좋다
    - 구현 전략등 다양한 정보를 전달하고 싶겠지만 하지 말라(아래 코드 참고)

```
Customer.linearCustomerSearch(String id)
Customer.find(String id) // 이게 더 좋다
```

- 즉, 구현 전략이 사용자게 중요한 문제가 아니라면 이름에서는 빼라
- 기존 인터페이스에 대한 유사점을 사용해서 메소드를 구현한다면 인터페이스에 사용된 것과 같은 이름을 사용해라
    - 실제 Iterator 인터페이스를 구현하는 것이 아니라 할지라도 Iterator인터페이스를 본따서 hasNext()나 next()와 같은 메소드 이름을 사용해라
    - 즉 역사와 전통적인 네이밍을 해라

### 메소드 가시성

- 가시성을 선택할 때는 두 가지 비용을 고려해야 한다
    - 하나는 미래의 유연성이다
        - 외부에 드러나는 인터페이스가 많지 않은 경우 미래에 인터페이스를 수정하는 것은 어렵지 않다
    - 다른 고려할 사항은 객체를 사용하는데 들어가는 비용이다
        - 노출된 인터페이스가 많지 않은 객체를 사용할 경우, 사용하는 측에서는 필요 이상으로 많은 작업을 해야한다
- 일반적으로는 가급적 가시성을 낮추는 것이 좋지만, 문제는 작성자가 관리하지 않는 코드에서 내가 작성한 코드를 호출하기 시작하면서 발생한다
    - 이런 경우 심사숙고해서 가시성을 공용으로 할지 보호로 할지 결정 해야한다

- 공용(public)
    - 공용으로 선언하면 패키지 외부에서도 이 메소드가 유용한 것이라고 이야기하는 것이다
    - 또한 공용 메소드 가시성을 사용하는 것은 프로그래머가 코드 관리를 책임지겠다는 뜻이다
    - 메소드를 수정할 경우 모든 수정을 본인이 담당하거나, 최소한 사용자들에게 수정 사항을 알려줄 책임이 있다
- 패키지(pakage)
    - 패키지 가시성은 해당 메소드가 같은 패키지의 다른 객체에게는 유용하지만 패키지 외부의 객체에게는 공개하지 않겠음을 의미한다
    - 패키지로 선언하는 경우 공용이나 보호가 더 좋지 않은지 고려해봐야 한다
- 보호(protected)
    - 하위 클래스를 사용해서 코드를 재사용하려 할 때 유용하다
    - 패키지 가시성보다 제한적인 것 같지만 사술 둘의 관계는 독립적이다
- 전용(private)
    - 외부 객체와 상관없이 모든 메소드 호출을 제어할 수 있다는 점에서, 전용 메소드는 최고의 유연성을 확보해준다
- `가장 제한적인 가시성을 선택한 후, 필요에 따라 점점 가시성을 높여가는 것이 좋다`
- 메소드를 final로 선언하는 것은 그 메소드를 사용하는 것은 자유이지만, 메소드를 더 이상 바꿀 수 없음을 의미한다. 메소드를 변경하는 것이 복잡하고 미묘한 결과를 유발하는 경우, 이러한 자기 보호 장치는
  정당화 될 수 있다. 하지만 대가로 다른 객체에서는 해당 메소드를 오버라이드하면 쉽게 해결할 수 있는 일을 더 복잡하게 처리해야 한다
- 메소드를 static으로 선언하면 다른 객체에서 해당 클래스의 인스턴스에 접근할 수 없는 경우에도 메소드에 접근할 수 있다
    - 정적 메소드는 어떤 인스턴스의 상태에 의존할 수 없으므로 복잡한 로직을 구현하기에 적합하지 않다
    - 정적 메소드를 상속하는 것은 가능하지만 정적 메소드가 오버라이드된 경우에는 상위클래스의 메소드를 호출하는 것이 불가능 하다
    - 경우에 따라 정적 메소드를 생성자 대신 유용하게 사용할 수도 있다

### 메소드 객체

- 메소드 객체는 복잡하게 꼬여 있는 메소드를 읽기 쉽고 명확하면서도 세부 구현 전달이 쉽도록 바꿔준다
    - 이 패턴은 일단 동작하는 코드가 나온 후에 사용하는 것이 보통이며, 코드가 복잡할수록 효과가 크다
- 먼저 많은 수의 파라미터와 임시 변수를 사용하는 긴 메소드를 찾아라
    - 찾았다면 해당 메소드의 일부를 많은 파라미터를 사용하는 서브 메소드로 변환다(이때 메소드 이름을 짓기 어려운 경우가 많다)
    - 메소드 객체 생성 순서는 아래와 같다
- 1> 메소드 이름을 따서 클래스 이름을 정한다. ex) complexCalculation() 은 ComplexCalculator가 된다
- 2> 메소드에서 사용하는 각 파라미터, 지역 변수, 필드에 대해 새로운 객체상의 필드를 생성한다. 일단 기존에 사용한 이름과 같은 이름ㅇ르 사용한다(이름은 나중에 변경 간으)
- 3> 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다
- 4> 본래 메소드를 새로운 클래스의 caculate()라는 메소드로 복사한다. 기존 메도으세ㅓ 파라미터, 지역 변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 된다
- 5> 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다(아래 코드)

```
complexCalculation(){
    new ComplexCalculator().calculate();
}
```

- 6> 본래 메소드에서 필드를 설정하는 부분이 있었다면, 다음과 같이 calcualte()가 반환된 후에 설정한다 (아래 코드)

```
complexCalculation(){
    ComplexCalculator calculator = new ComplexCalculator();
    calculator.calculate();
    mean = calculator.mean;
    variance = calculator.variance;
}
```

- 새로 만들어진 클래스의 코드는 리팩토링하기 쉽다
    - 메소드의 일부를 새로운 메소드로 분리하더라도 이제 모든 데이터가 필드에 저장되어 있으므로, 파라미터를 사용할 필요가 없기 때문이다
    - 때로는 메소드를 분화해 나가다 보면, 일부 데이터는 필드가 아닌 지역 변수로 바꾸거나 필드를 파라미터로 바꿔도 괜찮은 경우를 찾을 수 있다
- 이미 기존 객체에서 메소드 분화를 상당히 진행해 놓은 경우가 있을 수 있다
    - 이런 경우에는 필요한 메소드를 인라인해서 모든 연산을 한 메소드 안에 물아 넣은 다음 메소드 객체를 만들어 리펙토링 해야 한다

### 오버라이드

- 객체지향에서는 유사한 연산 사이의 차이점을 오버라이드를 통해서 여러 방식으로 표현할 수 있다
- 상위 클래스 메소드를 잘 구성한 경우, 새로운 코드를 추가할 연결고리를 쉽게 찾을 수 있다
    - 상위클래스 코드가 작고 밀접한 코드로 나뉘어 있다면, 오버라이드를 사용하기 쉽다
- 오바라이드를 사용한다고 상위클래스와 하위클래스의 메소드 중 하나를 선택해야만 하는 것은 아니다
    - super.method()를 호출해서 상위 클래스의 메소드를 사용할 수 있다
    - 하지만 하위클래스와 상위클래스의 여러 메소드를 자유롭게 혼합해서 사용하는 것은 좋지 않다
- 상위클래스의 메소드가 너무 방대한 경우 문제가 발생할 수 있다
    - 하위클래스에 상위클래스 코드를 복사해서 필요한 부분만 수정할 것인가? 다른 방법을 사용할 것인가?

### 오버로드

- 서로 다른 파라미터를 사용해서 같은 메소드를 선언하는 경우이다
- 오버로드는
- 1> 파라미터의 타입만 다른 경우
    - `메소드 오버로드를 사용하면 호출자가 특정 파라미터 형태로 객체를 변형해야 하는 부담을 덜어준다`
- 2> 파라미터의 갯수가 다른 경우
    - 이 스타일에는 문제가 있을 수 있다
    - 이 메소드를 사용하면 어떻게 되나 라는 질문에 답하기 위해, 메소드 이름뿐 아니라 파라미터도 유심히 살펴봐야 하기 때문이다
- `기본적으로 오보로드의 반환타입은 똑같아야 쓰는 사람이 코드를 읽기가 편하다`

### 메소드 반환 타입

- 함수를 작성할 때는 의도를 나타내는 반환 타입을 사용해야한다
    - 구상 클래스나 기본 타입을 반환 타입으로 사용할 수 있지만, 가급적 메소드의 적용 범위를 넓히기 위해서 의도를 드럴낼 수 있는 가장 추상적인 타입을 사용해야한다
    - 이렇게 하면 이후 구체적인 반환 클래스의 타입을 유연하게 변경할 수 있다
- 반환 타입을 일반화하면 세부 구현을 숨길 수도 있다
    - List대신 Collection을 반환하면 사용자는 원소의 순서가 정해져 있는지 여부를 알수 없다

### 메소드 주석

- 코드만으로 분명하지 않은 정보는 주석을 사용해서 전달해야 한다
    - 하지만 많은 경우 주석은 이미 알 수 있는 벙보를 중복해서 나타낼 뿐, 실제 커뮤니케이션에 도움을 주지 못한다
    - 주석을 작성하고 코드와 주석 간 일관석을 유지하기 위해서는 비용이 발생하기 때문에 이를 정당화할 수 있는 경우에만 사용해야 한다
- 주석은 두 메소드의 사이의 제약이 있는 경우를 표현하기 어렵다. 하지만 테스틑 코드는 이를 쉽게 반영할 수 있다
    - 결국 주석이 커뮤니케이션 방법중 최상의 선택이라면 좋은 주석을 작성해야 한다

### 도우미 메소드

- 도우미 메소드의 목적은 당장 관련도가 떨어지는 세부 구현을 숨기고 메소드 이름을 통해 프로그래머의 의도를 나나탬으로써, 복잡하고 거대한 연산 코드를 좀더 읽기 좋게 하기 위함이다
    - 일반적으로 전용으로 선언되며, 하위클래스 사용이 필요한 경우 보호형으로 선언되기도 한다
- 도우미 메소드는 케뮤니케이션 관점에서 중요한 경우가 많이 때문에 보통 짧거나, 어떤 경우에는 아주 짧을 수도 있다
- 메소드의 로직이 불명확해지는 경우에는 도우미 메소드를 제거하고 모든 도우미 메소드를 인라인으로 만드로 새로운 시각에서 로직을 나눠보는것이 좋다

### 디버그 출력 메소드

- 객체를 문자열로 나태나면 여러가지 좋은 점이 있다
    - 어떤 객체의 내용을 사용자에게 표현할 때 편리하고, 저장 후 다시 읽어와서 사용하기에도 좋으며 프로그래머에게 객체 내부 구현을 표현할 수도 있다
    - 고품질의 디버그 메시지를 출력하면 또한 얻을 수 있는 장점이 많다
    - 따라서 toString()은 프로그래머에게 유용한 객체의 정보를 알려주기 위해 사용하는 것이 좋다

### 변환

- 객체 A를 가진 상태에서 이후 연산을 위해 객체 B가 필요한 경우가 있다
- 다른 패턴들과 마찬가지로 변환 패턴의 목표는 프로그래머의 의도를 명확히 전달하는 것이다
- `변환을 편리하게 표현하기 위해서 새로운 의존성을 만드는 것은 좋지 않다`

### 변환 생성자

- 변환 생성자는 원본 객체를 파라미터로 취해서 대상 객체를 반환한다
- 변환 생성자는 하나의 원본 객체를 여러 다른 대상 객체로 변환할 때 유용하다 (아래 코드 참조)
    - 변환을 사용하더라도 원본 객체의 코드가 지저분해지지 않기 때문이다

```
String.asFile() // 이와 메소드를 만들면 편리하겠지만, String객체를 사용하는 잠재적 변화의 종류가 너무 많다(String 클래스는 변환 메소드로 넘칠것이다)

File(String name), URL(String spce), StringReadStream(String contents)와 같이 변환 생성자를 이용하는 편이 좋다 
```

### 생성

- 과거의 프로그램은 코드와 데이터가 섞여있는 커다란 덩어리였다. 이걸 해결하기 위해서 프로그램을 작은 덩어리로 나누기 시작했고 이때 도입된 것이 객체이다
- 따라서 의미 있는 객체 생성을 위해서는 명확하고 직접적인 표현과 유연선 사이에서 균현을 잡아야 한다
    - 생서오가 관련되 구현 패턴을 이용하면 "객체 만들기를 잘 표현 할수 있다(아래 패턴들을 봐보자)"

### 완결 생성자

- 객체는 연산을 하기 위해 정보가 필요하다. 생성자에서 연산을 할 수 있는 제대로 된 객체를 반환하는 생성자를 제공한다 (아래코드)

```
new Rectangle(0,0,50,200);
```

- 하지만 인자를 사용하지 않는 생성자와 여러 개의 설정 메소드를 사용해서 객체를 생성하는 것이 좀더 유연성을 높이는 경우가 있다
    - 하지만 이런 경우 독자 입장에서 올바로 동작하는 객체를 생성하기 위해 어떤 파라미터들일 필요하지 알기 어렵다 (아래코드)

```
Rectangle box = new Rectangle()
box.setLeft(0);
box.setWidth(50);
box.setHeight(200);
box.setTop(0);
```

- 생성자는 사용자를 구상 클래스로 안내한다. 좀더 추상적으로 가져가고 싶은 경우 공장 메소드를 사용해야 한다
    - 하지만 공장 메소드의 경우에도 인터페이스만 보고 객체 생성을 위해 어떤 정보가 필요한지 쉽게 이해할 수 있도록 완결된 형태의 생성자를 제공해야한다
- `완결 생성자를 구현할 떄는 모든 생성자가 동일한 하나의 생성자를 사용해서 모든 초기화를 하도록 해야한다`
    - 이렇게 하면 어떤 생성자를 사용하더라도 클래스의 올바른 동작을 위해 필요한 변치 않는 부분을 적절히 설정하는 것을 보장 할 수 있다

### 공장 메소드

- 정적(static)메소드를 사용해서 객체를 생성하는 방법이다
- 장점 (아래 코드 )
    - 의도가 담긴 별도의 이름을 가질 수 있다
    - 추상 타입 반환이 가능하다
        - 런타임에 타입이 결정되는 하위 클래스를 반환할 경우에 유용

```
Rectangle.create(0, 0, 50, 200;
```

- 단점
    - 복잡성이 증가한다
    - 이득이 있을 경우에만 사용해야 한다. 즉, 객체 생성 이외의 다른 의도가 있을 경우에만 사용해야 한다
- 공장 메소드의 변형으로는 관련 공장 메소드를 모아서 특수 공장 객체의 메소드로 사용하는 방법이 있다
    - 이 방법은 동시에 여러 구상 클래스 중에서 하나를 선택해야 하는 경우 유용하다

### 내부 공장

- 도우미 객체를 생성을 전용으로 하고 싶지만, 객체 생성 과정이 복잡하거나 하위클래스에 따라 달라질 경우, 새로운 객체를 생성하고 반환하는 메소드를 만드는 것이 좋다
- 내부 공장은 게으른 초기화를 사용하는 경우에도 흔히 사용된다 (아래코드)

```
getX(){
  if(x == null)
    x= ....; // 복잡한 코드 
   return x; 
}
getX(){
  if(x == null)
    x = computeX(); // 내부 공장
    returnx
}
```

- `내부 공장은 하위클래스에서 변형을 초청하는 의미를 갖는다`

### 컬렉션 접근자 메소드

- 컬렉션을 갖고 있는 객체에 컬렉션에 대한 접근을 어떻게 제공할 것인가
    - 그냥 컬렉션을 반환하는 메소드를 제공하면 문제가 발생한다
    - 사용하는 쪽에서는 가장 유연하게 사용할 수 있지만, 주는 쪽에서는 콜렉션의 상태가 변경 될 수 있기 때문에 객체의 상태가 더이상 유효하지 않게 될 수 있다
- 수정할 수 없는 형태로 제공
    - 컬렉션을 수정하려고 하면 예외가 발생하기 때문에 문제가 발생한다
- 제한적이지만 의미가 있는 접근을 제공해야 한다(아래 코드)

```
void addBook(Book arrival){
    books.add(arrival)
}
int bookdCount(){
    return books.size();
}
```

- 사용자가 원소를 하나씩 접근해야 한다면, 다음과 같이 순차열람자를 반환하는 메소드를 제공할 수 있다(아래 코드)

```
Iterator<Book> getBooks(){
    final Iterator<Book> reader = books.iterator();
    return new Iterator<Book>(){
        public booleand hasNext() return reader.hasNext();
        public Book next() return reader.next();
        public remove() throw new UnsupportedOperationException();
    }
}
```

- 대부분의 컬렉션 프로토콜을 중복해서 구현하고 있다면, 설계상에 문제가 있을 확률이 높다
    - 객체에서 클라이언트가 필요하는 작업을 제공한다면, 애초에 내부 데이터에 접근할 필요가 없기 때문

### 불린 설정 메소드

- 불린 상태를 설정하는 가장 좋은 방법은 설정 메소드를 제공하는 것이다(아래 코드)

```
void setValid(boolean newState){}
```

- 클라이언트가 인자를 동적으로 바꾸는 유연성을 필요로 하는 경우라면 아래 기법도 좋다(아래 코드)
- 또한 설정 메소드의 인자가 언제나 상수값 혹은 불린인 경우에도 아래 코드처럼 명확하게 인터페이스를 제공하는 것도 좋다

```
void valid(){}
void invalid(){}
```

### 질의 메소드

- 객체가 프로토콜을 통해 다른 객체의 결정을 도와야 할 경우에는 "be동사(is,was)"나 "have"동사를 사용하는 것이 좋다
- 하지만 어떤 객체가 다른 객체의 상태에 의존적인 로직을 많이 가지고 있다면, 이는 로직의 위치에 문제가 있다는 신호이다 (아래코드)

```
if(widget.isVisible()) widget.doSomething();
else widget.doSomethingElse()
```

- 위 경우에는 widget객체에 적당한 메소드를 넣어주는 편이 낫다

### 동등성 메소드

- 객체의 동일성이 아닌 동등성(equality)를 비교해야하는 경우, equals()와, hashCode()를 구현해야한다
    - 동등한 객체는 같은 해쉬 값을 가져야 하므로 hashCode()의 구현에는 equals() 구현에 쓰인 데이터만 사용해야 한다

### 취득 메소드

- 객체 상태에 대한 접근을 허용하기 위한 한 가지 방법은 상태를 반환하는 메소드를 제공하는 것이며 자바에서는 보통 이런 메소드에 접두어 "get"을 붙인다
    - 관행은 따르는 것이 좋다
- 취득 메소드 구현은 너무 간다하므로, 구현 보다는 메소드 가시성을 어떻게 할 것이냐 문제를 고민하는 것이 좋다
    - `무작정 취득 메소드를 제공하는 것보다 가급적 필요한 로직을 데이터가 있는 쪽으로 옮기는 것을 고려할 필요가 있다`

### 설정 메소드

- 필드 값을 설정하는 메소드가 필요하다면 "set"이라는 접두어를 사용한다
- 설정 메소드의 가시성을 높이는 문제는 더욱 주의 해야한다
    - 설정 메소드의 이름은 의도가 아닌 구현에 의해 정해진다
    - 설정 인터페이스를 통해 유용한 인터페이스를 구현할 수 있다면 설정 메소드를 사용하는 것도 괜찮다
    - `하지만 그런 경우라도 메소드 이름은 클라이언트 입장에서 지어야 한다`
    - 값을 설정해서 클라이언트가 어떤 문제를 해결할 수있는지 이해하고, 그 문제를 직접 해결할 수있는 메소드를 제공해야 한다
- 인터페이스에 설정 메소드를 포함시키면, 내부 구현을 노출시키게 된다(아래 코드)

```
paragraph.setJustification(Paragraph.CENTERED);
```

- 하지만 아래 코드 처럼 메소드의 목적에 따라 인터페이스 이름을 정하면 코드가 읽기가 쉬워진다 (아래 코드)
    - 설사 centered()의 구현이 설정 메소드인 경우에도 그렇다

```
paragraph.centered();

Paragraph:centered(){
    setJustification(CENTERED);
}
```

- 내부적으로(전용 혹은 보호)설정 메소드를 사용하는 것은 의존적인 정보를 업데이트하는 경우 등에 유용하다 (아래코드)
    - 정렬이 바뀐경우 문단을 새로 고침해야 하는 경우
    - 설정 메소드를 사용하면 어떤 데이터가 변경될 경우, 어떤 의존적인 데이터가 변경되어야 하는지 명확하게 보여줄수 있다

```
private void setJustification(...){
    ...
    rerdisplay();
}
```

- 설정 메소드를 사용하면 코드에 문제가 발생하기 쉽기 때문에, 가급적 외부에서 설정 메소드 사용을 피하느 ㄴ것이 좋다 

