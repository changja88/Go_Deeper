## 행위

- 이번 장에서는 프로그램의 행위를 표현하는 방법, 아래 패턴들에 대해서 알아 본다
    - 제어 흐름 : 연산을 여러 단계로 나타낸다
    - 주요 흐름 : 주요 제어 흐름을 명확하게 표현한다
    - 메시지 : 메시지를 보내서 제어 흐름을 표현한다
    - 선택 메시지 : 여러 선택 사항을 나타내기 위해 메시지 구현자를 다양화 한다
    - 더블 디스패치 : 두 가지 축으로 메시지 구현자를 다양화 해서 중첩된 선택을 표현한다
    - 분리 메시지 : 복잡한 연산은 밀접한 단위의 연산으로 나눈다
    - 되돌림 메시지 : 메시지를 같은 수신자에게 보내서 제어 흐름에 대칭성을 부여한다
    - 초청 메시지 : 다른 방식으로 구현될 수 있는 메시지를 보내서 미래에 일어날 변형을 대비한다
    - 설명 메시지 : 로직을 설명하기 위해서 메시지를 보낸다
    - 예외 흐름 : 주요 흐름에 대한 표현을 방해하지 않으면서, 가급적 명확하게 예외적 제어 흐름을 표현한다
    - 보호 구문: 지역적 예외 흐름은 이른 반환을 통해 표현한다
    - 예외 : 비지역적 예외 흐름은 예외로 표현한다
    - 체크 예외 : 명시적 선언으로 예외를 처리한다
    - 예외 전달 : 예외를 전달할 때에는 예외 처리자에게 적합한 정보를 전달 할 수 있도록 필요에 따라 예외의 형태를 변화한다

### 제어 흐름

- 제어 흐름이 있는 이유는 뭘까?
    - 제어 흐름은 모두 연산 표현을 풍부하게 해주는 매개체가 되어준다
    - `제어 흐름은 관련된 것들끼리 모아서 처음 보는 독자도 손쉽게 이해할 수 있게 하기 위해 존재한다`

### 주요 흐름

- 프로그램에는 주요 흐름이 있고, 연산에도 주요 흐름이 있다
    - 언어를 통해서 주요 흐름일 명확하게 표현해야 한다
    - 예외처럼 가끔 수행되고 가끔 변하는 부분을 명확하게 나타내면 오히려 자주 읽고 이해하고 수정해야 하는 부분이 오히려 불명확해 진다
    - 예외 조건이 중요하지 않으게 아니라 연산의 주요 흐름을 명확하게 표현하는 것이 더 중요하다
    - 예러 상황은 예외와 조건절을 사용해서 표현하면 된다

### 메시지

- 메시지를 사용하면 메시지를 수신하는 수신자의 상태가 변할 수 있다는 것을 주의 해야 한다
- 메시지를 프로시저로 사용한다면
    - 세부 구현은 바뀔 수도 있다는 의미를 내포하고 있을 수도 있다
    - 또는 세부 구현에 대한 설명을 적당히 미루는 커뮤니케이션 의도를 내포하고 있을 수도 있다
- 프로시저 &rarr; 어떤 절차를 표현 하기 위한 것

### 선택 메시지

- case문과 같은 목적으로 구현 선택을 위해 메시지를 보낼 수 있따

```
public void displayShape(Shape subject, Brush brush){
    brush.display(subject);
}
```

- 위 코드는 display()메시지가 런타임에 브러시의 타입에 따라 구현을 선택한다
- 이렇게 작성을 하면 명시적으로 사용해야 하는 조건문의 사용을 크게 줄일 수 있으며 추후 확장이 쉽다
- 하지만 단점도 있다
    - 코드 독자가 연산의 세부 구현을 이해하기 위해 여러 개의 클래스를 살펴봐야 한다 (아래 코드 참조)
    - 따라서 당장 연산의 변형이 필요하지 않은 경우라면 미래 확장을 위해 굳이 선택 메시지를 사용할 필요는 없다

```
class ScreenBrush(){
    display()
}
class BigBrush(){
    display()
}
```

### 더블 디스패치

- 선택 메시지를 사용하면 일차원적인 변형을 잘 표현할수 있다. 하지만 두 가지의 독립적인 차원에서의 변형을 표현하기 위해서는 2개의 선택 메시지를 직렬(cascade)로 연결해야 한다
- 예시
    - 스크린에 출력할 타원과 직사각형의 연산 과정의 차이점을 표현하고 싶은 경우
    - 우선 어느 곳에서 연산을 해야하는 결정해야 한다
    - 1> 기본 연산은 Brush에서 하는 것이 더 적당해 보이므로, 선택 메시지를 먼저 Shape에 보낸 후 Brush로 보낸다
    - 2> 이제 각 Shape는 다른 방식으로 displayWith()를 구현할 수 있다. 하지만 세부 구현을 하는 `대신 자신의 타입을 Brush에 넘겨주자`. 이제 각 Brush는 경우에 따라 어떤일을 해야
      할
      지 알 수 있다

```
displayShape(Shape subject, Brush brush){
    subject.displayWith(brush);
}
Oval.displayWith(Brush brush){
    brush.displayOval(this);
}
Rectangle.displayWith(Brush brush){
  brush.displayRectangle(this);
}
PostscriptBrush.displayRectangle(Rectangle subject){
    writer print(subject.left() + " " + ... + " rect);
}
```

- 단점으로 유연성이 떨어진다
    - 새로운 Shape를 추가하면 모든 종류의 Brush의 메소드를 수정 해야한다
    - 따라서 두 가지 요소 중 변경될 가능성이 높은 요소를 둘째 선택 메시지의 수신자로 선택해야 한다

### 분리(순차) 메시지

- 여러 단계로 구성된 알고리즘이 있다면, 관련된 단계들을 모으고 이를 수행하기 위해 메시지를 보낼 수 있다
- 분리 메시지는 이름을 잘 지어야 한다
    - 메시지 이름만 보고 이후에 어떤 일이 일어날지 짐작할 수 있어야 한다
    - 세부 구현에 관심이 있는 사람만 분리 메시지로 인해 호출되는 부분을 읽게 해야 한다
    - 만약 분리 메시지의 이름을 짓기 어렵다면 분리메시지 패턴을 사용하는 것이 적합하지 않다는 신호이다

### 되돌림 메시지

- `대칭성을 이용하면 코드의 가독성을 높일 수 있다`

```
void compute(){
    input();
    helper.precoess(this);
    output();
}
```

- 위 코드는 대칭성이 떨어 진다. 잠재적인 대칭성을 드러내는 도우미 메소드를 사용하면 메소드의 가독성을 높일 수 있다
    - 이렇게 하면 compute() 메소드를 보면서 누가 메시지를 받는지(언제나 this에게 전달되지만)고민할 피필요가 없다

```
void process(Helper helper){
    helper.process(this);
}
void compute(){
    input();
    process(helper);
    output();
}
```

- 이제 독자는 쉽게 compute()메소드의 구조를 이해할 수 있다
- `하지만 되돌림 메시지를 과도하게 사용하면 구현을 다른 곳으로 옮겨야 할 필요성이 희석되어 버린다`(아래 코드)

```
void input(Helper helper){
    helper.input(this);
}
void output(Helper helper){
    helper.output(this);
}    
```

- 위와 같은 경우 아래처럼 compute()메소드 전체를 Helper클래스로 옮기는 것이 나을 수도 있다 (아래 코드)

```
coupute(){
    new Helper(this).compute();
}
Helper.compute(){
    input();
    process();
    output();
}
```

- 대칭성과 같은 "미학적"만족을 위해 사로운 메소드를 만드는 것이 의미기 없게 느껴질 떄도 있다
    - 하지만 미학은 생각보다 중요한다
    - 미학에 대한 자신의 식격을 높이게 되면, 자신의 코드에서 받는 미학적 느낌을 통해 코드의 품질을 평가할 수 있게 된다
    - `코드에서 받는 느낌은 이미 유용성이 알려져 있는 다른 패턴만큼이나 중요하다`

### 초청 메시지

- 코드를 작성 하면서 사람들이 하위클래스의 어떤 연산을 변형시킬 것이라 예상할 수 있다
    - 이런 경우에 적당한 이름의 메시지를 통해 변형의 여지를 마련했음을 알려주는 것이 좋다
    - 이러한 메시지는 프로그래머로 하여금 이후 목적에 맞게 연산을 구현하도록 초청하는 의미를 갖는다
- `로직에 대한 기본(default)구현이 있다면 그 구현을 메시지의 구현으로 삼고, 그렇지 않다면 추상 메소드로 선언해서 초청메시지임을 분명히 해야한다`

### 설명 메시지

- `개발에서 개발자의 의도와 구현을 구분하는 것은 언제나 중요하다`
    - 독자는 이를 통해 먼저 연산의 핵심을 파악할 수 있고, 필요한 경우에만 세부 구현에 관심을 기울이면 된다
    - 메시지를 사용하면 먼저 풀려는 문제의 이름을 반영하는 메시지를 보낸 후, 문제 푸는 방식을 반영하는 메시지를 보내서 이 구분을 명시할 수 있다 (아래 코드)

```
hightlight(Rectangle area){ // 문제의 이름을 반영하는 메시지를 보내고
    reverse(area); // 문제 푸는 방식을 반영하는 메시지를 보낸다
}
```

- 한 줄로 된 코드에 주석을 붙이고 싶은 경우라면 설명 메시지 사용을 고려해야 한다 (아래 코드)

```
flags|= LOADED_BIT; // 로드 비트를 설정

```

- 위 코드를 아래 코드 처럼 설명 메시지로 바꿀 수 있다

```
void setLoadedFlage(){
    flags|= LOADED_BIT;
}

```

- 한 줄 짜리 메소드는 커뮤니케이션을 돕고, 주석보다 좋으며, 떄로는 추가 확장을 위해 유용할 떄도 있다
- `하지만 가장 중요한 이유는 코드를 작성하는 사람의 의도를 좀더 명확하게 전달하기 위함이다`

### 예외 흐름

- 독자는 프로그램의 각 문장이 순서대로 하나씩 수행될 때 가장 이해하기 쉽다
    - 따라서 주요흐름은 명료하게 유지해야 한다
    - 같은 맥락으로 예외 흐름은 수행빈도가 낮고, 개념적으로 덜 주용하기 때문에 주요흐름을 훼손 하지 않는 범위에서 명료하게 나타내야 한다
    - 예외 흐름은 조건절이나 예외절로 표현 해야한다
- 만약 예외 흐름도 주요 흐름과 동등하게 표현 하려면 프로그램에 플래그가 난무하고 특별한 의미를 가진 다양한 값을 반환해야한다

### 보호절

- 코드를 작성하다보면 주요 르름이 있지만 주요 흐름에서 벗어나야 할 때가 있다
    - 보호절을 사용하면 간단한 지역적 예외 상황을 지역적 예외 상황을 지역적인 변화만을 수반하며 표현할 수 있다 (아래 코드)

```
void initialize(){
    if(!isInitialized()){
    }
}
void initialize(){
    if(isInitialized()){
        return;
        ...
}
```

- 위 코드에서 첫째 코드의 경우 독자는 then에 해당하는 코드를 찾아야 한다. 하지만 두번째 코드에서는 then을 찾을 필요가 없다
- if-then-else는 동등한 중요성을 갖고 있는 제어 흐름을 표현한다. 반면에 보호절은 한 쪽의 제어 흐름이 다른 쪽보다 중요한 경우 유용하다
- 보호절은 여러 개의 조건이 있을 경우 특히 유용하다 (아래코드)

```
void compute(){
    Server server = getServer();
    if (server == null) return;
    Client clent = server.getClient();
    if (client == null) return;
    Request cureent = client.getRequest();
    if (current == null) return;
    processRequest(current);
}
```

- 보호절의 다른 형태는 루프 내의 continue를 사용하는 것이다. 이 때는 "이 경우는 신경 쓰지 말고 다른 경우르 보세요"라는 의미이다 (아래코드)

```
while(line = reader.readline()){
    if(line.startWith("#') || line.isEmpty())
      continue
    // 보통 경우 처리
}
```

- `중요한 점은 보호절의 포인트는 보통 경우와 예외 경우 처리의 차이점을 부각시키는 것이다`

### 예외

- 예외는 여러 함수 호출을 걸쳐서 제어 흐름을 바꾸는 경우를 표현할 떄 유용하게 사용된다
    - 스택 상에서 한참 위쪽에 문제가 발생했다면 스택의 한참 아래쪽에서 해결하는 것이 합리적이다
    - A() -> B() -> C() -> D() 순으로 함수 호출이 발생했고 예외가 D에서 발했다면 A에서 처리하는게 합리적이다
    - 예외를 발견한 쪽에서는 예외를 던지고, 예외를 처리하는 쪽에서 예외를 받는 편이 그 사이의 모든 코드에서 예외를 처리하지도 못하면서 예외를 체크하고 전달하며 코드를 지저분하게 하는것보다 좋기 떄문
- 예외에는 비용이 들어간다
    - 예외는 일종의 설계상 누수이다
    - 호출된 메소드가 예외를 던지면 예외는 예외를 던진 메소드부터 예외를 처리할 메소드까지 거치게 되는 모든 메소드의 설계와 구현에 영향을 미친다
    - 예외가 발생할 경우 다음에 수행되는 문장이 다른 메소드나 다른 객체, 다른 패키지에 있을 수도 있으므로 제어 흐름을 따라가기가 어려워진다
    - 가능하면 순차적 구문, 메시지, 루프, 제어문을 사용해서 제어흐름을 표현하는 것이 좋다

### 체크 예외

- 예외의 위험성 중 하나는 예외를 던졌을 때 아무도 그 예외를 받지 않을 수 있다는 것이다. 이 경우 프로그램 수행은 종료 된다
    - 이런 상황을 피하기 위해 자바에는 체크 예외가 있다
    - 이러한 예외는 프로그래머가 선언하며, 컴파일러에 의해 체크된다
    - 체크 에외를 넘겨받을 수 있는 클래스는 모두 그 예외를 받거나 다른 클래스로 넘겨줘야 한다

### 예외 전달

- 예외는 다양한 추상화 수준에서 발생할 수 있따. 예상치 않은 시점에 하위 수준의 예외를 받아서 보여주는 것은 혼란을 일으킨다
- 하위 수준의 예외는 문제를 진단하는 데 유용한 정보를 제공해주는 경우가 많다
    - 하위 수준의 예외를 상위 수준 예외로 포장하라.
    - 예를 들어 로그를 통해 문제 해결을 돕는 메시지를 출력할 수 있다 