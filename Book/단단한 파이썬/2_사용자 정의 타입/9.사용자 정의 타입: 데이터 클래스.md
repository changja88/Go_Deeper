## 사용자 정의 타입: 데이터 클래스

- 데이터 클래스는 연관 데이터의 그룹화를 지원하는 사용자 정의 타입이다
    - 정수형이나 문자열, 열거형은 같은 타입들은 스칼라며 이들은 하나의 값만을 표현한다
    - 리스트나 세트, 딕셔너리는 유형이 같은 컬렉션이다
- 여러 데이터 필드를 단일 데이터 타입으로 변형할 필요가 있다
    - 이때 딕셔너리와 튜플이 좋기는 하지만 몇가지 문제가 있다
        - 가독성이 좋지 않고, 런타임 시 딕셔너리나 튜플에 무엇이 들어있는지 알기가 어렵기 때문

### 데이터 클래스의 동작

- 데이터 클래스는 변수들의 동종 컬렉션을 표현하며 모두 복합 타입으로 만들어 진다
    - 복합 타입은 여러 값으로 구성돼 있으며 논리적 그룹화 또는 연관관게의 종류를 나타내야 한다
- 데이터 클래스를 만든다는 것은 코드베이스에 공유 자료 집합을 추가하는 것이다
    - 개발자가 각 필도를 개별적으로 수행해야 할 필요 없이 재사용할 수 있는 그룹화를 제공
- 데이터 클래스는 필드뿐만 아니라 메서드의 형태로 동작을 추가할 수 있다
  ```python
  @dataclass
  class Recipe:
  some_fileds: int
  
      def make_vegitarian(self):
          ...
  
      def get_ingredient_names(self):
          ...
  ```
    - 딕셔너리나 튜플보다 재사용성이 좋다 -> dataclass에 바로 함수형을 추가

### 사용법

- 데이터 클래스는 작업의 편의를 위해 몇 가지 내장 함수를 갖고 있다

#### 문자열 변환

- 데이터 클래스는 디폴트로 __str__, __repr__을 제공한다

#### 등가 비교

```python
@dataclass(eq=True)
class Recipe:
    ...
```

- 두 데이터 ㅋ늘래스 간 등가 비교를 하기 원한다면 dataclass 에서 eq=True 설정을 할 수 있다
    - 파이썬은 비교를 할 때 __eq__함수를 수행한다
    - 다른 디폴트를 원한다면 __eq__를 오버라이드 할 수 있다

#### 관계 비교

- 디폴트로 데이터 클래스는 관계 비교 연산을 지원하지 않는다 -> 정렬이 불가능하다
- 디폴트로 관계 비교 연산 및 정렬을 가능하게 하려면 eq=True, order=True로 설정해야 한다
    - 생성된 비교 함수는 각 필드를 통해 필드가 정의된 순서로 비교한다
    - 커스텀을 하고 싶다면 __le__, __lt__,__gt__,__ge__를 작성 하면 된다

#### 불변성

- dataclass를 frozen으로 설정면 불변으로 만들 수 있다
    - frozeon = True
- dataclass를 세트 내에서 또는 딕셔너리의 키로 사용하기를 원한다면 해시가 가능 해야한다
    - dataclass를 frozen으로 만들면 명시적으로 동일성 검사를 불가능하게 하지 않는 한 자동으로 해시 가능 상태가 된다
- frozen을 시키는데는 주의 사항이 있다
    - 1> 불변이라고 해서 dataclass 내 필드의 불변성을 의미하는 것이지 dataclass 자체가 갖고 있는 값의 불변성을 의미하는 것은 아니다. 타입 체커에서 값의 변경도 오류 로 처리하기를 원한다면
      변수들을 Final로 어노테이팅을 하면 된다
    - 2> frozen은 멤버들의 설정을 막을 뿐이다. 멤버들이 변경 가능하다면 이 멤버들에 대해 메서드를 호출해 이들의 값을 변경할 수 있다. frozen은 이들의 속성에까지 불변성을 확장 시키지 않는다
        - soup.aromatics.addd(ingredient("Garlic)) -> 가능하다

### 다른 타입과의 비교

- 데이터 클래스는 상대적으로 최신(3.7)에 나온 개념이며, 데이터 클래스의 도입을 판단하려면 데이트 클래스가 다른 구조에 관련해서 어디에서 좋은지 알아야 한다

#### 데이터 클래스와 딕셔너리

- 딕셔너리는 키와 값을 매핑하는 데 최적은 선택이지만, 유형이 동일해야 한다는 조건이 있다 (키의 타입이 같아야 하고, 모든 값의 타입도 같아야 한다)
    - 유형이 동일한 데이터를 사용할 떄 딕셔너리는 사람이 추론하기에는 어렵다
    - 또한 타입 체커도 딕셔너리의 오류에 대한 체크를 잘 모른다
- 반면 데이터 클래스는 태생부터 유형이 다른 데이터를 위한 것이다
    - 코드를 읽는 사람들이 타입에 존재하는 정확한 필드를 알 수 있고 타입 체커는 정확한 사용을 체크 할 수 있따
    - 유형이 다른 데이터를 갖고 있다면 딕셔너리 대신 데이터 클래스를 사용하는 것이 좋다

#### 데이터 클래스와 TypedDict

- TypedDict는 유형이 다른 데이터를 저장하는 또 다른 방법이며 코드를 읽는 사람이나 타입 체커나 모두 이해할 수 있따
- TypedDict와 데이터 클래스는 상당히 유사한 문제를 해결하며 어느 것이 더 낫다는 결정을 하기 어렵다
    - 일단 기본은 dataclass를 사용하는 것이다
    - 함수를 내부에서 사용할 수 있고, 불변셩, 호환성, 등가 비교 등 다른 제어 기능이 많이 때문이다
    - 하지만 이미 딕셔너리로 작업을 하고 있는 경우 또는 dataclass의 장점이 필요하지 않은 경우에는 TypeDict로 가는 것이 좋다

#### 데이터 클래스와 namedtuple

- namedtuple은 컬렉션 모듈에서 튜플 비슷한 역할을 한는 컬렉션 타입이다.
- nametuple은 튜플을 더 읽기 쉽게 만든느 데 도움이 되며 dataclass를 사용해도 같은 장점을 얻는다
    - 필자는 아래의 장점 때문에 dataclass를 namedtuple대신 사용한다
    - 1> 파라미터의 명시적 타입 어노테이팅
    - 2> 불변성, 호환성, 동일성 검사 제어
    - 3> 타입에서 함수 정의 가능 