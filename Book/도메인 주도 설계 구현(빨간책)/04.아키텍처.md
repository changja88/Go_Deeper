## 아키텍처

- DDD의 가장 큰 장점 중 하나는 특정 아키텍처의 사용을요구하지 않는다는 점이다
    - 핵심 도메인이 바운디드 컨텍스트의 중심에 머무르기 때문에 하나 이상의 아키텍처적 영향력이 전체 애플리케이션이나 전체 시스템에 영향을 미칠 수 있도록 해준다

- 로드맵
    - DIP와 핵사고날을 통해 신뢰할 수 있는 계층 아키텍처를 개선하는 방법을 배우자
    - 핵사고날 서비스 지향과 REST를 지원하는 방법을 살펴보자
    - 개인 데이터 패브릭이나 그리드 기반 분산 캐시의 관점과 이벤트 주도 스타일의 관점을 배우자
    - CQRS라는 새로운 아키텍처 패턴이 어떻게 DDD에 도움이 될지 생각해보자

## 계층

<img src = "./img/IMG_6210.jpg" width = "500" height = "500">

- 위 그림은 전통적인 계층 아키텍처를 사용한 일반적 DDD 애플리케이션 게층을 나타낸다
- 이 아키텍처의 중요한 계층은 자신의 층과 바로 아래층에만 연결될 수 있다는 점이다
    - 스타일마다 약간의 차이가 있다
    - 엄격한 계층 아키텍처는 바로 아래층과만 연결되도록 하는 구조다
    - 느슨한 계층 구조는 상위 계층이 그 아래의 모든 계층과 연결되도록 한다
    - 하위 계층은 사실상 상위 계층과 느슨하게 연결되지만, 이는 관찰자(observer)나 중재자(mediator)와 같은 메커니즘을 사용해야만 가능하다
    - 사용자 인터페이스와 애플리케이션 서비스는 대부분 인프라를 이용하기 때문에 대부분의 시스템이 느슨한 계층을 기반으로 한다
    - `아래에서 위쪽으론 절대로 직접 참조할 수 없다`

#### 사용자 인터페이스 계층

- 사용자의 뷰와 요구사항 문제를 다루는 코드만 포함한다
- `도메인/비즈니스 로직을 담아서는 안된다`
- 여기에서 찾을 수 있는 유효성 검사의 유형은 도메인 모델에 속해 있는 유형과는 다른다
- 사람과 다른 시스템 모두가 사용자가 될 수 있으므로 이 계층은 때론 오픈 호스트 서비스의 형태로 API서비스를 원격 호출하는 수단을 제공한다

#### 애플리케이션 계층

```
@Transactional
public void commitBacklogItemToSprint(String aTenantId,String aBacklogItemId,String aSprintId){
        String aTenantId=new TenantId(aTenantId);

        BacklogItem backlogItem=backlogItemRepository.backlogItemOfId(tenantId,new BacklogId(aBacklogItemId));

        Sprint sprint=sprintRepository.sprintOfId(tenantId,new SprintId(aSprintId));

        backlogItem.commitTo(Sprint);
}
```

- `도메인 로직이 전혀 없다`
- 영속성 트랜잭션과 보안을 제어할 수 있다
- 이벤트 기반의 알림을 다른 시스템으로 보내거나, 사용자에게 보낼 이메일 메시지의 작성을 담당할 수도 있다
- 이 계층에 위치한 애플리케이션 서비스는 비즈니스 로직을 갖고 있지 않지만, 도메인 모델의 직접적인 클라이너트가 된다
- 매우 경량으로 유지되고, 애그리게잇과 같은 도메인 객체에게 오퍼레이션의 수행을 지시한다
- 유스케이스나 사용자 스토리를 모델상 표현하는 주요 방법이기도 하다
- 따라서 사용자 인터페이스로부터 매개변수를 받아 리퍼지토리를 사용해 애그리게잇 인스턴스를 획득하고, 몇 가지 커맨드 오퍼레이션을 수행하는 일을 애플리케이션 서비스의 공통 기능으로 포함한다
- 위 코드는 애플리케이션 샘플코드이다
- 애플리케이션 코드가 이보다 더 복잡 해진단다면 도메인 로직이 애플리케이션 서비스로 새어나가고 있음을 나타내는 신호 일 수 있다
- 애플리케이션 서비스는 새로운 애그리게잇을 생성하기 위해 팩토리를 사용하거나, 애그리게잇의 생성자가 새로운 인스턴스를 생성하도록 해서 그에 맞는 리라지토리를 통해 저장시킨다
- 애플리케이션 서비스는 무상태 오페레이션으로 설계된 일부 도메인별 테스크를 완성하기 위해 도메인 서비스를 사용할 수도 있다
- 도메인 모델이 도메인 이벤트를 게시하도록 설계됐다면, 애플리케이션 계층은 이벤트에 구독자를 얼마든지 등록할 수 있다. 이렇게 함으로써 이벤트를 저장하거나 전달하거나 애플리케이션이 책임지고 처리토록 할 수 있다.
  이를 통해 도메인 모델이 고유한 핵심 문제만 알면 되는 자유로움을 자고, 도메인 이벤트 게시자를 경량으로 유지할 수 있도록 해주며, 메시징 인프라스트럭처의 의존성으로부터 해방된다

#### 전통적인 게층과 도메인과의 문제

- 도메인 계층에서 인프라 계층을 사용할 때 제약을 둬야 할 수 있다.
    - 그렇다고 핵심 도메인 객체가 이를 사용할 수 있다는 의미는 아니며, 이런 상황은 무조건 피하도록 해야한다
    - 하지만 계층의 정의를 따르기 위해선 인프라가 제공하는 기술에 의존적인 도메인 계층 안에서 일부 인터페이스를 구현해야 할 수도 있다
    - 1)9장에 나오는 모듈을 구현해 기술적 클래스를 숨길수 있다
    - 2)인터페이슬르 애플리케이션 게층안에 구현에서 계층 구조 규칙을 지킬 수도 있다
    - 3)DIP를 이용할 수도 있다

#### 인프라 계층

- 가장 아래 계층이다
- 영속성이나 메시징 메커니즘과 같은 요소가 이 계층에 있다
- 메시지는 엔터프라이즈 메시징 미들웨어 시스템이 발송하거나, 이메일(SMTP), 문자 메시지처럼 더 기초적인 요소를 포함 할 수도 있다
- 애플리케이션에 낮은 수준의 서비스를 제공하는 모든 기술적인 컴포넌트와 프레임워크들은 주로 인프라의 일부로 간주된다
- 인프라 계층을 가장 아래에 두면 불이익이 일부 발생할 수 있다
    - 도메인 계층에서 필요한 기술적 측면을 구현하려면 계층의 규칙을 어겨야 하며, 테스트도 오렵다
    - 이를 해결 하기 위해서는 DIP를 적용해야 한다

### 의존성 역행원리(DIP)

<img src = "./img/IMG_6212.jpg" width = "500" height = "500">

- 의존성이 영향을 주는 방식을 조정함으로써 전통적인 계층 아키텍처를 개선하는 방법
- 정의 : 상위 수준의 모듈은 하위 수준의 모듈에 의존해선 안된다. 둘 모두는 반드시 추상화에 의존해야 한다

```java
import java.util.Collection;

public class HibernateBacklogItemRepositry implements BacklogItemRepository {
    @Override
    @SuppressWarnings("unchecked")
    public Collection<BacklogItem> allBacklogItemsCommitedTo(Tenat aTennat, SprintId aSprintId) {
        Query query = this.session().createQuery(
                "from -BacklogItem as _obj_ + where _obj_.tenant = ? and _obj_.sprintId = ?"
        );
        query.setParameter(0, aTennat);
        query.setParameter(1, aSprintId);
        return (Collection<BacklogItem>) query.list();
    }
}
```

- 도메인 계층에 초점을 맞춰보면, DIP를 사용함으로써 도메인과 인프라 모두가 도메인 모델에서 정의한 추상화(인터페이스)에 의존하게 된다
    - 애플리케이션 계층은 도메인을 직접 사용하는 클라이언트이므로 도메인 인터페이스에 의존적이며,
    - 리파지토리나 인프라에서 제공하는 기술적 도메인 서비스 구현 클래스를 간접적으로 액세스 한다
- 구현을 위해선 의존성 주입이나 서비스 팩토리나 플러그인을 비롯한 여러 방법중 하나를 선택 할 수 있다

## 핵사고날 또는 포트와 어댑터

<img src = "./img/IMG_6214.jpg" width = "600" height = "600">

- 위 이미지는 핵사고날 아키텍처 이미지이다
    - 핵사고날 아키텍처는 포트와 어답터로 알려져 있다
    - 외부 타입마다 어답터가 존재하고, 외부 영역은 애플리케이션의 API를 통해 내부 영역과 이어진다
- 핵사고날 아키텍처에서 대칭성을 만들어주는 스타일을 규정했다
    - 이 아키텍처는 다양한 이질적 클라이언트가 동등한 지위에서 시스템과 상호작용하도록 함으로써 그 목표를 달성한다
    - 새로운 클라이언트가 필요하다면, 단순히 내부 애플리케이션의 API가 클라이언트의 입력을 이해하도록 변환해주는 어댑터만 추가해주면 된다
    - 이를 바탕으로 시스템이 사용하는 그래픽, 영속성, 메시징과 같은 출력 메커니즘이 다양해지고 쉽개 대체할 수 있게 된다
- 계층 아키텍처를 사용하고 있다고 말하는 팀은 실제론 핵사고날을 사용하고 있다
    - 실제로는 의존성 주입을 사용하고 있기 때문
    - 의존 주입이 무조건 핵사고날을 의미하진 않으며, 아키텍처를 만드는 과정에서 자연스럽게 포트와 어댑터 스타일의 방향으로 흘러가게 해줄 뿐이다
- 핵사고날의 시각
    - 일반적으로 클라리언트가 시스템과 상호작용하는 곳을 프론트 엔드로 여긴다. 마찬가지로 애플리케이션이 저장된 영속성 데이터와 상호작용 하는 곳을 백엔드라고 여긴다
        - 그러나 핵사고날은 시스템의 영역을 다른 방식으로 바라본다
    - 핵사고날에는 외부와 내부 두 주요 영역이 있다
        - 외부 영역은 이질적인 클라이언트가 입력을 보낼 수 있도록 해주며, 영속 데이터를 가져오거나 애플리케이션의 출력을 저장하거나 다른 위치로 전송하는 메커니즘을 제공한다
    - 위 이미지에서 각 클라이언트 타입은 자신만의 고유한 어댑터를 갖는데 이는 입력 프로토콜을 애플리케이션의 API와 호환되는 '내부' 입력으로 변환한다
    - 각 해사고날의 면은 입력이든 출력이든 각기 다른 종류의 포트를 표현한다
        - 클라이언트의 세 가지 요청이 같은 종류의 입력 포트(어댑터 A,B,C)로 들어오고, 다른 하나는 다른 종류의 포트(어댑터 D)를 사용한
        - 포트를 정의하는 엄격한 틀이 있는 것은 아니며, 따라서 포트라는 개념은 유연하게 해석된다
        - 포트를 어떤 위치로 나눴든, 클라이언트의 요청이 도착하면 그에 해당하는 각각의 어댑터가 이 입력을 변환해준다. 그런 후에 애플리케이션에서의 오퍼레이션을 호출하거나 애플리케이션으로 이벤트를 보낸다.
          이를 통해 제어권이 내부로 전달된다
        - 애플리케이션은 퍼블릭 API를 통해 요청을 받는다. 애플리케이션 경계(또는 내부 핵사고날)는 유스케이스의 경계이기도 하다.
        - `즉 애플리케이션의 기능적 요구사항에 기반해 유스케이스를 생성해야지, 다양한 클라이언트가 얼마나 연결될지나 출력 메커니즘에 기반해서는 안 된다`
        - 레이어드 아키텍처와 마찬가지로 여기에서도 애플리케이션 서비스는 도메인 모델과 직접 연결되는 클라이언트다

```java
import java.lang.annotation.Target;

@Path("/tenants/{temantsId}/products")
public class ProductResource extends Resource {
    private ProductService productService;

    @GET
    @Patch("{productId}")
    @Produces({"application/vnd.saasovation.projectovation_xml"})
    public Product getProduct(
            @PathParam("tenantId") String aTenantId,
            @PathParam("productId") String aProductId,
            @Context Request aRequest
    ) {
        Product product = productService.product(aTenantId, aProductId);
        if (product == null) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return product;
    }
}
```

- 위 코드는 게시된 레스트풀 리소를 보여준다
    - HTTP 입력 포트를 통해 요청이 도착했고, 핸들러는 어댑터로서 동장해 요청을 애플리케이션 서비스로 할당한다
    - 다양한 JAX-RX어노테이션은 어댑터의 중요한 구성 요소이며, 리소스 경로를 파시하고 매개변수를 String 인스턴스로 변환해준다
    - 주압된 ProductService인스턴스를 사용해 해당 요청을 애플리케이션 내부로 할당한다
    - Product는 XML로 직렬화돼 Response로 들어가며, 이는 HTTP 출력 포트로 보내진다
- 애플리케이션 측면(핵사고날 안쪽에서 밖깥쪽으로)
    - 마찬가지로 위 이미지에서 표현된 것처럼 리포지토리 패턴을 사용하여 DB에 접근 하는 E,F,G와 메시징을 위한 H는 어댑터는 다를 것이다
- 핵사고날의 큰 장점은 테스트를 위해 어댑터를 쉽개 개발할 수 있다는 점이다
    - 클라이언트와 저장소 메커니즘이 없더라도, 전체 애플리케이션과 도메인 모델을 설계해서 테스트 할수 있다(ProductService를 구동할 수 있다)

- 핵사고날 아키텍처는 다양한 측면에서 활용되므로, 시스템에 필요한 다른 여러 아키텍처를 지원할 떄 든든한 기반이 된다
    - 예를 들어 서비스 지향이나 REST또는 이벤트 주도 이키텍처를 파헤치거나, CQRS를 사용하거나, 데이터 패브릭, 그리드 기반 분산 캐시를 사용하거나, 맵 리듀스 분산 병렬 처리르 사용할 수 있다 