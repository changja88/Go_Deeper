## 아키텍처

- DDD의 가장 큰 장점 중 하나는 특정 아키텍처의 사용을요구하지 않는다는 점이다
    - 핵심 도메인이 바운디드 컨텍스트의 중심에 머무르기 때문에 하나 이상의 아키텍처적 영향력이 전체 애플리케이션이나 전체 시스템에 영향을 미칠 수 있도록 해준다

- 로드맵
    - DIP와 핵사고날을 통해 신뢰할 수 있는 계층 아키텍처를 개선하는 방법을 배우자
    - 핵사고날 서비스 지향과 REST를 지원하는 방법을 살펴보자
    - 개인 데이터 패브릭이나 그리드 기반 분산 캐시의 관점과 이벤트 주도 스타일의 관점을 배우자
    - CQRS라는 새로운 아키텍처 패턴이 어떻게 DDD에 도움이 될지 생각해보자

## 계층

<img src = "./img/IMG_6210.jpg" width = "500" height = "500">

- 위 그림은 전통적인 계층 아키텍처를 사용한 일반적 DDD 애플리케이션 게층을 나타낸다
- 이 아키텍처의 중요한 계층은 자신의 층과 바로 아래층에만 연결될 수 있다는 점이다
    - 스타일마다 약간의 차이가 있다
    - 엄격한 계층 아키텍처는 바로 아래층과만 연결되도록 하는 구조다
    - 느슨한 계층 구조는 상위 계층이 그 아래의 모든 계층과 연결되도록 한다
    - 하위 계층은 사실상 상위 계층과 느슨하게 연결되지만, 이는 관찰자(observer)나 중재자(mediator)와 같은 메커니즘을 사용해야만 가능하다
    - 사용자 인터페이스와 애플리케이션 서비스는 대부분 인프라를 이용하기 때문에 대부분의 시스템이 느슨한 계층을 기반으로 한다
    - `아래에서 위쪽으론 절대로 직접 참조할 수 없다`

#### 사용자 인터페이스 계층

- 사용자의 뷰와 요구사항 문제를 다루는 코드만 포함한다
- `도메인/비즈니스 로직을 담아서는 안된다`
- 여기에서 찾을 수 있는 유효성 검사의 유형은 도메인 모델에 속해 있는 유형과는 다른다
- 사람과 다른 시스템 모두가 사용자가 될 수 있으므로 이 계층은 때론 오픈 호스트 서비스의 형태로 API서비스를 원격 호출하는 수단을 제공한다

#### 애플리케이션 계층

```
@Transactional
public void commitBacklogItemToSprint(String aTenantId,String aBacklogItemId,String aSprintId){
        String aTenantId=new TenantId(aTenantId);

        BacklogItem backlogItem=backlogItemRepository.backlogItemOfId(tenantId,new BacklogId(aBacklogItemId));

        Sprint sprint=sprintRepository.sprintOfId(tenantId,new SprintId(aSprintId));

        backlogItem.commitTo(Sprint);
}
```

- `도메인 로직이 전혀 없다`
- 영속성 트랜잭션과 보안을 제어할 수 있다
- 이벤트 기반의 알림을 다른 시스템으로 보내거나, 사용자에게 보낼 이메일 메시지의 작성을 담당할 수도 있다
- 이 계층에 위치한 애플리케이션 서비스는 비즈니스 로직을 갖고 있지 않지만, 도메인 모델의 직접적인 클라이너트가 된다
- 매우 경량으로 유지되고, 애그리게잇과 같은 도메인 객체에게 오퍼레이션의 수행을 지시한다
- 유스케이스나 사용자 스토리를 모델상 표현하는 주요 방법이기도 하다
- 따라서 사용자 인터페이스로부터 매개변수를 받아 리퍼지토리를 사용해 애그리게잇 인스턴스를 획득하고, 몇 가지 커맨드 오퍼레이션을 수행하는 일을 애플리케이션 서비스의 공통 기능으로 포함한다
- 위 코드는 애플리케이션 샘플코드이다
- 애플리케이션 코드가 이보다 더 복잡 해진단다면 도메인 로직이 애플리케이션 서비스로 새어나가고 있음을 나타내는 신호 일 수 있다
- 애플리케이션 서비스는 새로운 애그리게잇을 생성하기 위해 팩토리를 사용하거나, 애그리게잇의 생성자가 새로운 인스턴스를 생성하도록 해서 그에 맞는 리라지토리를 통해 저장시킨다
- 애플리케이션 서비스는 무상태 오페레이션으로 설계된 일부 도메인별 테스크를 완성하기 위해 도메인 서비스를 사용할 수도 있다
- 도메인 모델이 도메인 이벤트를 게시하도록 설계됐다면, 애플리케이션 계층은 이벤트에 구독자를 얼마든지 등록할 수 있다. 이렇게 함으로써 이벤트를 저장하거나 전달하거나 애플리케이션이 책임지고 처리토록 할 수 있다.
  이를 통해 도메인 모델이 고유한 핵심 문제만 알면 되는 자유로움을 자고, 도메인 이벤트 게시자를 경량으로 유지할 수 있도록 해주며, 메시징 인프라스트럭처의 의존성으로부터 해방된다

#### 전통적인 게층과 도메인과의 문제

- 도메인 계층에서 인프라 계층을 사용할 때 제약을 둬야 할 수 있다.
    - 그렇다고 핵심 도메인 객체가 이를 사용할 수 있다는 의미는 아니며, 이런 상황은 무조건 피하도록 해야한다
    - 하지만 계층의 정의를 따르기 위해선 인프라가 제공하는 기술에 의존적인 도메인 계층 안에서 일부 인터페이스를 구현해야 할 수도 있다
    - 1)9장에 나오는 모듈을 구현해 기술적 클래스를 숨길수 있다
    - 2)인터페이슬르 애플리케이션 게층안에 구현에서 계층 구조 규칙을 지킬 수도 있다
    - 3)DIP를 이용할 수도 있다

#### 인프라 계층

- 가장 아래 계층이다
- 영속성이나 메시징 메커니즘과 같은 요소가 이 계층에 있다
- 메시지는 엔터프라이즈 메시징 미들웨어 시스템이 발송하거나, 이메일(SMTP), 문자 메시지처럼 더 기초적인 요소를 포함 할 수도 있다
- 애플리케이션에 낮은 수준의 서비스를 제공하는 모든 기술적인 컴포넌트와 프레임워크들은 주로 인프라의 일부로 간주된다
- 인프라 계층을 가장 아래에 두면 불이익이 일부 발생할 수 있다
    - 도메인 계층에서 필요한 기술적 측면을 구현하려면 계층의 규칙을 어겨야 하며, 테스트도 오렵다
    - 이를 해결 하기 위해서는 DIP를 적용해야 한다

### 의존성 역행원리(DIP)

<img src = "./img/IMG_6212.jpg" width = "500" height = "500">

- 의존성이 영향을 주는 방식을 조정함으로써 전통적인 계층 아키텍처를 개선하는 방법
- 정의 : 상위 수준의 모듈은 하위 수준의 모듈에 의존해선 안된다. 둘 모두는 반드시 추상화에 의존해야 한다

```java
import java.util.Collection;

public class HibernateBacklogItemRepositry implements BacklogItemRepository {
    @Override
    @SuppressWarnings("unchecked")
    public Collection<BacklogItem> allBacklogItemsCommitedTo(Tenat aTennat, SprintId aSprintId) {
        Query query = this.session().createQuery(
                "from -BacklogItem as _obj_ + where _obj_.tenant = ? and _obj_.sprintId = ?"
        );
        query.setParameter(0, aTennat);
        query.setParameter(1, aSprintId);
        return (Collection<BacklogItem>) query.list();
    }
}
```

- 도메인 계층에 초점을 맞춰보면, DIP를 사용함으로써 도메인과 인프라 모두가 도메인 모델에서 정의한 추상화(인터페이스)에 의존하게 된다
    - 애플리케이션 계층은 도메인을 직접 사용하는 클라이언트이므로 도메인 인터페이스에 의존적이며,
    - 리파지토리나 인프라에서 제공하는 기술적 도메인 서비스 구현 클래스를 간접적으로 액세스 한다
- 구현을 위해선 의존성 주입이나 서비스 팩토리나 플러그인을 비롯한 여러 방법중 하나를 선택 할 수 있다 