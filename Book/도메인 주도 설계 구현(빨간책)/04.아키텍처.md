## 아키텍처

- DDD의 가장 큰 장점 중 하나는 특정 아키텍처의 사용을요구하지 않는다는 점이다
    - 핵심 도메인이 바운디드 컨텍스트의 중심에 머무르기 때문에 하나 이상의 아키텍처적 영향력이 전체 애플리케이션이나 전체 시스템에 영향을 미칠 수 있도록 해준다

- 로드맵
    - DIP와 핵사고날을 통해 신뢰할 수 있는 계층 아키텍처를 개선하는 방법을 배우자
    - 핵사고날 서비스 지향과 REST를 지원하는 방법을 살펴보자
    - 개인 데이터 패브릭이나 그리드 기반 분산 캐시의 관점과 이벤트 주도 스타일의 관점을 배우자
    - CQRS라는 새로운 아키텍처 패턴이 어떻게 DDD에 도움이 될지 생각해보자

## 계층

<img src = "./img/IMG_6210.jpg" width = "500" height = "500">

- 위 그림은 전통적인 계층 아키텍처를 사용한 일반적 DDD 애플리케이션 게층을 나타낸다
- 이 아키텍처의 중요한 계층은 자신의 층과 바로 아래층에만 연결될 수 있다는 점이다
    - 스타일마다 약간의 차이가 있다
    - 엄격한 계층 아키텍처는 바로 아래층과만 연결되도록 하는 구조다
    - 느슨한 계층 구조는 상위 계층이 그 아래의 모든 계층과 연결되도록 한다
    - 하위 계층은 사실상 상위 계층과 느슨하게 연결되지만, 이는 관찰자(observer)나 중재자(mediator)와 같은 메커니즘을 사용해야만 가능하다
    - 사용자 인터페이스와 애플리케이션 서비스는 대부분 인프라를 이용하기 때문에 대부분의 시스템이 느슨한 계층을 기반으로 한다
    - `아래에서 위쪽으론 절대로 직접 참조할 수 없다`

#### 사용자 인터페이스 계층

- 사용자의 뷰와 요구사항 문제를 다루는 코드만 포함한다
- `도메인/비즈니스 로직을 담아서는 안된다`
- 여기에서 찾을 수 있는 유효성 검사의 유형은 도메인 모델에 속해 있는 유형과는 다른다
- 사람과 다른 시스템 모두가 사용자가 될 수 있으므로 이 계층은 때론 오픈 호스트 서비스의 형태로 API서비스를 원격 호출하는 수단을 제공한다

#### 애플리케이션 계층

```
@Transactional
public void commitBacklogItemToSprint(String aTenantId,String aBacklogItemId,String aSprintId){
        String aTenantId=new TenantId(aTenantId);

        BacklogItem backlogItem=backlogItemRepository.backlogItemOfId(tenantId,new BacklogId(aBacklogItemId));

        Sprint sprint=sprintRepository.sprintOfId(tenantId,new SprintId(aSprintId));

        backlogItem.commitTo(Sprint);
}
```

- `도메인 로직이 전혀 없다`
- 영속성 트랜잭션과 보안을 제어할 수 있다
- 이벤트 기반의 알림을 다른 시스템으로 보내거나, 사용자에게 보낼 이메일 메시지의 작성을 담당할 수도 있다
- 이 계층에 위치한 애플리케이션 서비스는 비즈니스 로직을 갖고 있지 않지만, 도메인 모델의 직접적인 클라이언트가 된다
- 매우 경량으로 유지되고, 애그리게잇과 같은 도메인 객체에게 오퍼레이션의 수행을 지시한다
- 유스케이스나 사용자 스토리를 모델상 표현하는 주요 방법이기도 하다
- 따라서 사용자 인터페이스로부터 매개변수를 받아 리퍼지토리를 사용해 애그리게잇 인스턴스를 획득하고, 몇 가지 커맨드 오퍼레이션을 수행하는 일을 애플리케이션 서비스의 공통 기능으로 포함한다
- 위 코드는 애플리케이션 샘플코드이다
- 애플리케이션 코드가 이보다 더 복잡 해진단다면 도메인 로직이 애플리케이션 서비스로 새어나가고 있음을 나타내는 신호 일 수 있다
- 애플리케이션 서비스는 새로운 애그리게잇을 생성하기 위해 팩토리를 사용하거나, 애그리게잇의 생성자가 새로운 인스턴스를 생성하도록 해서 그에 맞는 리라지토리를 통해 저장시킨다
- 애플리케이션 서비스는 무상태 오페레이션으로 설계된 일부 도메인별 테스크를 완성하기 위해 도메인 서비스를 사용할 수도 있다
- 도메인 모델이 도메인 이벤트를 게시하도록 설계됐다면, 애플리케이션 계층은 이벤트에 구독자를 얼마든지 등록할 수 있다. 이렇게 함으로써 이벤트를 저장하거나 전달하거나 애플리케이션이 책임지고 처리토록 할 수 있다.
  이를 통해 도메인 모델이 고유한 핵심 문제만 알면 되는 자유로움을 갖고, 도메인 이벤트 게시자를 경량으로 유지할 수 있도록 해주며, 메시징 인프라스트럭처의 의존성으로부터 해방된다

#### 전통적인 게층과 도메인과의 문제

- 도메인 계층에서 인프라 계층을 사용할 때 제약을 둬야 할 수 있다.
    - 그렇다고 핵심 도메인 객체가 이를 사용할 수 있다는 의미는 아니며, 이런 상황은 무조건 피하도록 해야한다
    - 하지만 계층의 정의를 따르기 위해선 인프라가 제공하는 기술에 의존적인 도메인 계층 안에서 일부 인터페이스를 구현해야 할 수도 있다
    - 1)9장에 나오는 모듈을 구현해 기술적 클래스를 숨길수 있다
    - 2)인터페이슬르 애플리케이션 게층안에 구현에서 계층 구조 규칙을 지킬 수도 있다
    - 3)DIP를 이용할 수도 있다

#### 인프라 계층

- 가장 아래 계층이다
- 영속성이나 메시징 메커니즘과 같은 요소가 이 계층에 있다
- 메시지는 엔터프라이즈 메시징 미들웨어 시스템이 발송하거나, 이메일(SMTP), 문자 메시지처럼 더 기초적인 요소를 포함 할 수도 있다
- 애플리케이션에 낮은 수준의 서비스를 제공하는 모든 기술적인 컴포넌트와 프레임워크들은 주로 인프라의 일부로 간주된다
- 인프라 계층을 가장 아래에 두면 불이익이 일부 발생할 수 있다
    - 도메인 계층에서 필요한 기술적 측면을 구현하려면 계층의 규칙을 어겨야 하며, 테스트도 오렵다
    - 이를 해결 하기 위해서는 DIP를 적용해야 한다

### 의존성 역행원리(DIP)

<img src = "./img/IMG_6212.jpg" width = "500" height = "500">

- 의존성이 영향을 주는 방식을 조정함으로써 전통적인 계층 아키텍처를 개선하는 방법
- 정의 : 상위 수준의 모듈은 하위 수준의 모듈에 의존해선 안된다. 둘 모두는 반드시 추상화에 의존해야 한다

```java
import java.util.Collection;

public class HibernateBacklogItemRepositry implements BacklogItemRepository {
    @Override
    @SuppressWarnings("unchecked")
    public Collection<BacklogItem> allBacklogItemsCommitedTo(Tenat aTennat, SprintId aSprintId) {
        Query query = this.session().createQuery(
                "from -BacklogItem as _obj_ + where _obj_.tenant = ? and _obj_.sprintId = ?"
        );
        query.setParameter(0, aTennat);
        query.setParameter(1, aSprintId);
        return (Collection<BacklogItem>) query.list();
    }
}
```

- 도메인 계층에 초점을 맞춰보면, DIP를 사용함으로써 도메인과 인프라 모두가 도메인 모델에서 정의한 추상화(인터페이스)에 의존하게 된다
    - 애플리케이션 계층은 도메인을 직접 사용하는 클라이언트이므로 도메인 인터페이스에 의존적이며,
    - 리파지토리나 인프라에서 제공하는 기술적 도메인 서비스 구현 클래스를 간접적으로 액세스 한다
- 구현을 위해선 의존성 주입이나 서비스 팩토리나 플러그인을 비롯한 여러 방법중 하나를 선택 할 수 있다

## 핵사고날 또는 포트와 어댑터

<img src = "./img/IMG_6213.jpg" width = "600" height = "600">

- 위 이미지는 핵사고날 아키텍처 이미지이다
    - 핵사고날 아키텍처는 포트와 어답터로 알려져 있다
    - 외부 타입마다 어답터가 존재하고, 외부 영역은 애플리케이션의 API를 통해 내부 영역과 이어진다
- 핵사고날 아키텍처에서 대칭성을 만들어주는 스타일을 규정했다
    - 이 아키텍처는 다양한 이질적 클라이언트가 동등한 지위에서 시스템과 상호작용하도록 함으로써 그 목표를 달성한다
    - 새로운 클라이언트가 필요하다면, 단순히 내부 애플리케이션의 API가 클라이언트의 입력을 이해하도록 변환해주는 어댑터만 추가해주면 된다
    - 이를 바탕으로 시스템이 사용하는 그래픽, 영속성, 메시징과 같은 출력 메커니즘이 다양해지고 쉽개 대체할 수 있게 된다
- 계층 아키텍처를 사용하고 있다고 말하는 팀은 실제론 핵사고날을 사용하고 있다
    - 실제로는 의존성 주입을 사용하고 있기 때문
    - 의존 주입이 무조건 핵사고날을 의미하진 않으며, 아키텍처를 만드는 과정에서 자연스럽게 포트와 어댑터 스타일의 방향으로 흘러가게 해줄 뿐이다
- 핵사고날의 시각
    - 일반적으로 클라리언트가 시스템과 상호작용하는 곳을 프론트 엔드로 여긴다. 마찬가지로 애플리케이션이 저장된 영속성 데이터와 상호작용 하는 곳을 백엔드라고 여긴다
        - 그러나 핵사고날은 시스템의 영역을 다른 방식으로 바라본다
    - 핵사고날에는 외부와 내부 두 주요 영역이 있다
        - 외부 영역은 이질적인 클라이언트가 입력을 보낼 수 있도록 해주며, 영속 데이터를 가져오거나 애플리케이션의 출력을 저장하거나 다른 위치로 전송하는 메커니즘을 제공한다
    - 위 이미지에서 각 클라이언트 타입은 자신만의 고유한 어댑터를 갖는데 이는 입력 프로토콜을 애플리케이션의 API와 호환되는 '내부' 입력으로 변환한다
    - 각 해사고날의 면은 입력이든 출력이든 각기 다른 종류의 포트를 표현한다
        - 클라이언트의 세 가지 요청이 같은 종류의 입력 포트(어댑터 A,B,C)로 들어오고, 다른 하나는 다른 종류의 포트(어댑터 D)를 사용한
        - 포트를 정의하는 엄격한 틀이 있는 것은 아니며, 따라서 포트라는 개념은 유연하게 해석된다
        - 포트를 어떤 위치로 나눴든, 클라이언트의 요청이 도착하면 그에 해당하는 각각의 어댑터가 이 입력을 변환해준다. 그런 후에 애플리케이션에서의 오퍼레이션을 호출하거나 애플리케이션으로 이벤트를 보낸다.
          이를 통해 제어권이 내부로 전달된다
        - 애플리케이션은 퍼블릭 API를 통해 요청을 받는다. 애플리케이션 경계(또는 내부 핵사고날)는 유스케이스의 경계이기도 하다.
        - `즉 애플리케이션의 기능적 요구사항에 기반해 유스케이스를 생성해야지, 다양한 클라이언트가 얼마나 연결될지나 출력 메커니즘에 기반해서는 안 된다`
        - 레이어드 아키텍처와 마찬가지로 여기에서도 애플리케이션 서비스는 도메인 모델과 직접 연결되는 클라이언트다

```java
import java.lang.annotation.Target;

@Path("/tenants/{temantsId}/products")
public class ProductResource extends Resource {
    private ProductService productService;

    @GET
    @Patch("{productId}")
    @Produces({"application/vnd.saasovation.projectovation_xml"})
    public Product getProduct(
            @PathParam("tenantId") String aTenantId,
            @PathParam("productId") String aProductId,
            @Context Request aRequest
    ) {
        Product product = productService.product(aTenantId, aProductId);
        if (product == null) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return product;
    }
}
```

- 위 코드는 게시된 레스트풀 리소를 보여준다
    - HTTP 입력 포트를 통해 요청이 도착했고, 핸들러는 어댑터로서 동장해 요청을 애플리케이션 서비스로 할당한다
    - 다양한 JAX-RX어노테이션은 어댑터의 중요한 구성 요소이며, 리소스 경로를 파시하고 매개변수를 String 인스턴스로 변환해준다
    - 주압된 ProductService인스턴스를 사용해 해당 요청을 애플리케이션 내부로 할당한다
    - Product는 XML로 직렬화돼 Response로 들어가며, 이는 HTTP 출력 포트로 보내진다
- 애플리케이션 측면(핵사고날 안쪽에서 밖깥쪽으로)
    - 마찬가지로 위 이미지에서 표현된 것처럼 리포지토리 패턴을 사용하여 DB에 접근 하는 E,F,G와 메시징을 위한 H는 어댑터는 다를 것이다
- 핵사고날의 큰 장점은 테스트를 위해 어댑터를 쉽개 개발할 수 있다는 점이다
    - 클라이언트와 저장소 메커니즘이 없더라도, 전체 애플리케이션과 도메인 모델을 설계해서 테스트 할수 있다(ProductService를 구동할 수 있다)

- 핵사고날 아키텍처는 다양한 측면에서 활용되므로, 시스템에 필요한 다른 여러 아키텍처를 지원할 떄 든든한 기반이 된다
    - 예를 들어 서비스 지향이나 REST또는 이벤트 주도 이키텍처를 파헤치거나, CQRS를 사용하거나, 데이터 패브릭, 그리드 기반 분산 캐시를 사용하거나, 맵 리듀스 분산 병렬 처리르 사용할 수 있다

## 서비스 지향(SOA)

- 서비스는 언제나 상호 운용성(interoperable)이 있다는 사실 이외에도 아래 표와 같이 8개의 설계 원리가 있다

| 서비스 설계 원리                             | 내용                                                                          |
|---------------------------------------|-----------------------------------------------------------------------------|
| 1.서비스 계약(Service Contract)            | 서비스는 그 목적과 기능을 하나 이상의 설명 문서에 계약으로써 표현한다                                     |
| 2.서비스의 느슨한 결합(Service Loose Coupling) | 서비스는 의존성을 최소화하고 오직 서로에 대해서만 알고 있다                                           |
| 3.서비스 추상화(Service Abstraction)        | 서비스는 그들의 계약만을 게시하고, 클라이언트로부터 내부 로직을 숨긴다                                     |
| 4.서비스 재사용성(Service Reusability)       | 서비스는 좀 더 대단위(coarse-grained)의 큰 서비스를 만들기 위해 다른 상대에게 재사용될 수 있다               |
| 5.서비스 자율성(Service Autonomy)           | 서비스는 하위 환경과 자원을 제어하며 독립적으로 유지되고, 이로부터 서비스는 일관성과 신뢰성을 유지한다                   |
| 6.서비스 무상태(Service Satelessness)       | 서비스는 상태 관리의 책임을 소비자(consumer)에게 두며, 이는 서비스 자율성을 위한 제어 과정과 충돌하지 않도록 하기 위해서다  |
| 7.서비스 발견성(Service Discoverability)    | 메타데이터로 서비스를 기술함으로써 검색이 가능해지고 서비스 계약을 이해할 수 있는데, 이를 통해 서비스는 (재)사용 가능한 자산이 된다 |
| 8.서비스 구성성(Service Composability)      | 서비스는 크기나 컴포지션의 복잡성과는 무관하게, 더 대단위의 서비스를 구성하는 일부가 될 수 있다                      |

<img src = "./img/IMG_6214.jpg" width = "600" height = "600">

- 위이미지에서 가장 왼편의 서비스 경계와 도메인 모델을 핵심에 두고, 설계 원리를 핵사고날 아키텍처와 결합할 수 있다
    - 위 이미지에서 소비자는 REST, SOAP, 메시징을 이용해 서비스에 접근한다.
    - `하나의 헥사고날 기반 시스템이 다수의 기술적 서비스 엔드포인트를 지원한다는 점이 중요하다`
- 서비스는 비즈니스와 기술을 하나로 만들어주는 방법으로서 비즈니스 전략을 강조한다
    - 그러나 하나의 비즈니스 서비스를 정의하는 것이 하나의 서브도메인이나 바운디드 컨텍스트를 정의하는 것과 같은 의미는 아니다
    - 문제점점 공간과 해결책 공간 평가를 수행하면 각각 많은 수로 구성된 비즈니스 서비스를 발견하게 될 것이 분명하다
    - 따라서 위 이미지는 단 하나의 바운디드 컨텍스트에 해당하는 아키텍처를 보여줬을 뿐이지만, 이는 많은 레스트풀 리소스, SOAP 인터페이스, 메시징 타입 등을 통해 구체화된 기술적 서비스의 집합을 제공할 수
      있으며, 이 집합은 전체 비즈니스 서비스의 일부일 뿐이다
- 즉, T-서비스(기술적 서비스)로 + 핵사고날의 형태이다
    - 기술적 서비스는 REST, SOAP, 메시징을 받아준다

## REST: 표현 상태 전송

- REST는 지난 수년 동안 가장 많이 사용된 동시에 남용되기도 한, 아키텍처의 화제어 중 하나이다
    - 일부에선 REST가 SOAP를 사용하지 않고 HTTP연결상에서 XML을 전송한다고 생가하며
    - 다른 일부는 HTTP와 JSON의 사용과 같은 의미로 생각하기도 한다
    - 또다른 사람들은 REST를 수행하기 위해선 메소드 인수를 URI쿼리 매개변수로 보내야 한다고 생각한다
    - 전부 틀렸다
    - 그나마 권위 있는 로이 T.필딩의 논문을 살펴보자

### 아키텍처 스타일로서의 REST

- 왜 REST를 시스템을 만드는 방법이나 웹 서비스르 만드는 방법으로 생각하게 됐을까?
    - 다른 모든 기술처럼 웹 프로토콜을 여러 가지 방법으로 활용할 수 있다는 점을 발견했기 때문

### 레스트풀 HTTP 서버의 주요 특징

- '레스트풀 HTTP'를 사용한 분산 아키텍처의 주요 특징은 무엇일까?
    - [서버 측면]
    - 사람이 웹 브라이저를 통해 사용하는 서버인지, 프로그래밍 언어로 작성된 클라이언트 같은 다른 에이전트인지와 전혀 무관하다
    - 1.이름 자체에서 알 수 있듯이 리소스가 핵심 개념이다
        - 외부에서 접근 가능하도록 노출하고 싶다는 의미는 '대상'이 무엇인지 결정하고 각각에서 구분된 식별자를 부여한다
        - 일반적으로 각 리소스는 하나의 URI를 가지며, URI는 반드시 하나의 리소를 가리켜야 한다
        - URI를 통해 외부로 노출할 '대상'을 각각 불러낼 수 있어야 한다
        - 리소스는 하나 이상의 포맷에 따라 상태를 판단할 수 있는 표현을 갖게 된다. XML이나 JSON 문서, HTML폼의 포스트 데이터나 일부 이진 포맷 등과 같은 표현을 통해 클라이언트가 리소스와
          상호작용한다
    - 2.무상태로 의사소통한다
        - 클라이언트와 서버가 암시적 컨텍스트(세션)을 설정하기 위해 개별 요청에 의존하지 않는다는 점이 중요하다
        - 이는 다른 요청과는 독립적으로 각각의 리소스를 엑세스할 수 있도록 해주며, 이런 측면을 바탕으로 대규모 확장성을 달성할 수 있다
    - [리소스 측면]
    - 맞춰야 할 인터페이스 종류가 무엇인지 묻는 질문은 매우 합리적인 결과다
    - 질문에 관한 답도 만찬가지로, 분산 시스템의 다른 아키텍처적 스타일과 REST를 차별화하는 매우 중요한 특징이다
    - 호출을 위해 사용하는 메소드의 집합은 미리 정해져 있다
        - 모든 객체가 같은 인터페이스를 지원한다
        - 레스트풀 HTTP에서의 메소드는 리소스에 적용할 수 있는 HTTP동사(GET, POST, PUT, DELETE등이 가장 중요하다)다
        - 이런 메소드는 CRUD 오퍼레이션으로의 변환 작업을 해주지 않는다. 영속성 엔티티를 나타내지 않고, 그 대신 올바른 동사가 사용됐을 때 호출될 행동을 캡슐화한 리소스를 생성하는 일은 매우 일반적이다
        - 각 HTTP메소드는 HTTP명세에 아주 명확하게 정의돼 있다
            - 예를 들어 GET 메소드는 '안전한' 오퍼레이션에만 사용돼야한다
    - [하이퍼미디어]
    - 레스트풀 서버는 하이퍼미디어라는 방법을 통해 클라이언트가 애플리케이션에서 일어날 수 있는 상태 변경에 맞는 경로를 찾을 수 있도록 해준다
    - 즉, 개별 리소스는 스스로 자립할 수 없으며, 리소스는 서로 연결돼 동작한다. 웹이라는 이름은 이런 특징 때문에 지어졌다
    - 서버의 입장에선 답을 줄 때 연결 정보를 포함시켜야 함을 의미하며, 이는 클라이언트가 연결된 리소스와 상호작용할 수 있도록 해준다

### 레스트풀 HTTP클라이언트의 주요 특징

- 레스트풀 HTTP 클라이언트는 리소스 표현 내에 포함된 링크를 따라가거나 서버로 처리할 데이터를 보낸 후 결과로 돌아온 리소스로 리다이렉션함으로써, 한 리소스에서 다른 리소스로 이동한다
- 이상적인 REST 설정에선 클라이언트가 단 하나의 잘 알려진 URI에서 시작해, 그 다음부터 하이퍼미디어 제어를 계속 따라가게 된다

### REST와 DDD

- 도메인 모델을 레스트풀 HTTP로 바로 노출하는 것은 좋지 않다
    - 이는 도메인 모델 내의 변경 하나하나가 시스템 인터페이스로 바로 반영되기 때문이다
    - DDD와 레스트풀 HTTP를 합치는 방법에는 두 가지 접근법이 있다
    - 1> 시스템의 인터페이스에 별도의 바운디드 컨텍스트를 생성하고, 시스템의 인터페이스 모델에서 실제 핵심 도메인으로 액세스하기 위해 적절한 전략을 사용한다
        - 고전적인 방법
        - 시스템의 인터페이스를 서비스나 원격 인터페이스가 아닌 단순한 리소스 추상화로 노출된 하나의 응집된 묶음으로 바라 본다
    - 2> 크로스커팅(crosscutting) 접근법
        - 내부와 외부 모두를 좀더 반영할 수 있는 방법
        - 미디어 타입을 선택하고, 이어서 이 포맷에 맞는 도메인 모델을 생성한다
        - 이 포맷을 알아야 하는 모든 시스템은 이 모델을 사용할 수 있다
        - 당연하게도 이 접근법에선 서버가 여러 종류의 미디어 타입을 다뤄야 할 필요성이 발생하며, 여러 서버에서 같은 미디어 타입을 사용할 수도 있다

### 왜 REST인가

- REST 원리에 맞게 설계된 시스템은 느슨한 결합의 조건을 충족한다
    - 일반적으로 새로운 리소스를 추가해서 기존의 리소스 표현으로 연결하는 일은 매우 쉽다
    - 새로운 포맷의 지원이 필요한 시점에도 추가가 쉬우며, 훨씬 덜 취약한 시스템 연결 집합을 이끌어낸다
    - 보다 작은 단위(리소르)로 나눠지며, 각 단위가 개별적으로 테스트 및 디버깅할 수 있고, 가용 가능한 진입 지점을 노출하기 때문에 REST기반 시스템은 이해하기가 훨씬 쉽다

## 커맨드-쿼리 책임 분리(CQRS, Command-Query Responsibility Segregation)

- 사용자가 필요로 하는 데이터 뷰를 리파지토리로 쿼리하기란 어려울 수 있다
    - 특히 사용자 경험 설계가 여러 에그리게잇 타입과 인스턴스로부터 데이터 뷰를 생성해야 할 때가 어렵다
    - 도메인이 정교할수록 이런 상황이 발생할 가능성이 높아 진다
- 리파지토리만을 사용하는 것은 바람직한 해결책이 아니다
    - 클라이언트가 여러 리파지토리를 통해 필요한 모든 애그리게잇 인스턴스를 취득한 후에 필요한 데이터만 데이터 전속 객체(DTO)로 모아서 사용하도록 요구할 수 있다
    - 아니면 하나의 쿼리로 다양한 리파지토리에 흩어져 있는 데이터를 모아주는 특화된 파인더를 설계할 수도 있다
- 도메인 데이터를 뷰에 매핑하는 완전히 다른 방법이 없을까?
    - 이 질문에 대한 대답으로, 이상한 이름을 가진 아키텍처 패턴인 커맨드-쿼리 책임 분리(CQRS, Command-Query Responsibility Segregation)이 있다
    - `이 아키텍처는 엄격한 객체(또는 컴포넌트)의 설계 원칙과 커맨드-쿼리 분리(CQS)를 아키텍처 패턴으로 녹여내기 위해 노력한 결과다`
- CQRS는 다음 내용을 따른다
    - 모든 메소드는 작업을 수행하는 커맨드이거나 데이터를 호출자에게 반환하는 쿼리 중하나여야 하며, 하나의 메소드가 두 역할을 모두 할 수는 없다
    - `즉 질문하는 행동이 대답을 바꿔선 안된다`
    - 좀 더 형식적으로 말하자면, 메소드는 오직 참조적으로 투명해서(referentially transparent)다른 부작용을 일으키지 않을 때만 값을 반환해야 한다
    - 객체 수준에서 이는 다음을 의미한다
        - 1> 메소드가 객체의 상태를 수정한다면, 이 메소드는 커맨드이며 값을 반환하면 안된다
        - 2> 메소드가 값을 반환한다면, 이 메소드는 쿼리이며 직접적이든 간접적이든 객체 상태의 수정이 야기해선 안된다
- DDD를 사용할 때 아키텍처 패턴으로 적용해야 하는 이유는 무엇일까?
    - 바운디드 컨텍스트에서 논의한 바와 같이 도메인 모델을 시각화하자. 일반적으로 커맨드 메소드와 쿼리 메소드 모두 갖고 있는 애그리게잇을 확인하게 된다. 또한 특정 속성을 필터링하는 여러 파인더 메소드를 갖고
      있는 리파지토리를 만난다
    - 하지만 CQRS와 함께라면 이런 '일반성'을 무시하고 보여줄 데이터를 쿼리하는 방법을 다르게 설계할 것이다
- 다시 말해서 전통적으로 모델에서 찾게 되는 모둔 순수 쿼리 책임을, 같은 모델의 순수 커맨드를 실행하는 책음으로부터 분리한다
    - 애그리게잇은 쿼리 메소드(게터) 없이 오직 커맨드 메소드만을 포함하게 된다
    - 리파지토리는 add()나 save()메소드와, fromID()와 같은 단 하나의 쿼리 메소드로 분해된다. 이 하나의 쿼리 메소드는 고유한 애그리게잇 식별자를 포함해 반환한다
    - 리파지토리에선 애그리게잇을 찾을 때 부가 속성의 필터링과 같은 기타 방법을 사용할 수 없다. 이런 모든 부분을 전통적인 모델로부터 제거한 후, 그 결과를 커맨드 모델로 지정한다
    - 여전히 사용자에게 데이터를 보여줄 방법이 필요하며, 이를 위해선 최적화된 쿼리에 맞춰 두 번째 모델을 생성하며 이를 쿼리 모델이라 한다

### CQRS의 영역 살펴보기

<img src = "./img/IMG_6215.jpg" width = "600" height = "400">

- 이 패턴의 주요 영역을 각 단계별로 살펴보자

#### 클라이언트와 쿼리 처리기

- 클라이언트는 웹 브라우저나 사용자 지정 데스크톱 사용자 인터페이스일 수 있다
- 여기엔 복잡한 계층이 없다
- 이 컴포넌트는 쿼리 저장소 데이터베이스로 쿼리를 실행시키며, 쿼리 결과의 전송에 필요하다면 일부 포맷으로 직렬화도 수행한다

#### 쿼리 모델(읽기 모델)

- 쿼리 모델은 정규화되지 않은 데이터 모델이다
- 이는 도메인 행동을 전달하기 위한 목적이 아니며, 오직 표시(보고)할 데이터만을 전달한다
- 만약 이 데이터 모델이 SQL데이터베이스라면, 각 테이블에는 한 가지 종류의 클라이언트 뷰(실제로 보여준다는 의미의 뷰)만을 위한 데이터가 저장된다
- 이 테이블은 열이 많아질 수 있으며, 주어진 모든 사용자 인터페이스 뷰에서 필요한 정보를 모두 합친 확대 집합을 담아야 할 수도 있다
- 테이블 뷰는 테이블로부터 생성되고, 각각의 테이블 뷰는 전체 정보의 논리적 하위집합으로 사용된다
    - 예를 들어, 테이블은 일반적인 사용자와 매니저와 관리자에게 사용자 인터페이스를 보여주기에 충분한 데이터를 갖도록 설계할 수 있다
- 필요한 수만큼의 뷰를 지원하기
    - CQRS 기반의 뷰는 (개발과 유지에 있어서)싸고 일회용일 수 있다는 점을 알아둬야 한다
    - 새로운 영속성 뷰 데이터를 생성하기 위해 언제든 다시 게시할 수 있는 경우 특히 그렇다
    - 모든 단일 뷰는 독립적으로 청므부터 재작성될 수 있고, 전체 쿼리 모델을 완전히 다른 영속성 기술로 바꿀 수도 이싸
    - 이는 나타는 UI 요구사항을 지속적으로 해결해줄 뷰를 생성하고 유지하는 일을 쉽게 해준다
    - 그 결과, 테이블 패러다임의 사용은 지양하는 대신에 더 풍부하고 더 직감적인 사용자 경험으로 이끌어 준다
- 오베헤드 문제
    - 뷰는 단순히 쿼리에 응답할 뿐이며, 이 때에도 조인을 요구하지 않는다
    - 쿼리 모델 업데이트 만이 오버헤드를 발생시킨다. 쿼리 모델 업데이트가 최적화되어 수행될 수 있도록 테이블과 뷰의 설계에 주의해야 한다

#### 클라이언트가 커맨드 처리를 주도한다

- 사용자 인터페이스 클라이언트는 커맨드 모델 내에 있는 애그리게잇의 행동을 실행 시키기 위한 방법으로 서버로 커맨드를 보낸다(또는 간접적으로)

#### 커맨드 처리기

- 보내진 커맨드는 커맨드 핸들러/처리기가 수신하는데, 이들이 몇 가지 스타일 중 하나를 따를 수 있다.
- 1> 카테고리 스타일
    - 커맨드의 카테고리에 맞춰 애플리케이션 서비스 인터페이스와 구현을 생성한다
    - 각 애플리케이션 서비스는 다수의 메소드를 가질 수 있고, 커맨드의 각 타입마다 카테고리에 맞는 매개변수로 하나의 메소드를 선언한다
    - 이 스타일의 주요 이점은 단순성이다. 이해와 생성 유지 관리가 쉽다
- 2> 전용 스타일
    - 각 핸들러는 하나의 메소드를 갖고 있는 하나의 클래스다
    - 메소드 계약은 매개변수를 포함하고 있는 특정 커맨드의 사용을 용이하게 한다
    - 이 스타일에는 분명한 이점이 있다. 하나의 핸들러/처리기당 하나의 책임만 있고, 각 핸들러는 독립적으로 재사용될 수 있고, 핸들러 타입은 특정 종류의 커맨드의 양이 많을 떄 이를 관리하기 위해 확장될 수
      있다
- 3> 메시지 스타일
    - 커맨드를 비동기식 메시지로 보내며, 전용 스타일로 설게된 핸들러로 전달 된다
    - 이는 각 커맨드 처리기 컴포넌트가 특정 타입의 메시지를 받도록 할 뿐만 아니라, 커맨드 프로세싱 부하를 처리할 수 있도록 주어진 타입의 처리기를 추가할 수 있다
    - 복잡한 설계가 필요하기 때문에 기본으로 사용하면 안 된다. 확장성의 요구가 있을 경우에만 비동기식으로 변경해야한다
- 대부분의 커맨드 핸들러는 리파지토리로부터 애그리게잇 인스턴스를 받아와 그와 관한 커맨드 메소드 행동을 실행한다 (아래코드 )

```
@Transactional
public void commitBacklogItemToSprint(String aTenantId, String aBacklogItemId, String aSprintId){
    TenantId tenantId = new TenantId(aTenantId);
    BacklogItem backlogItem = backlogItemRepository.backlogItemOfId(tenantId, new BacklogItemId(aBacklogItemid));
    Sprint sprint = sprintRepository.sprintOfId(tenantId, new SprintId(aSprintId));
    backlogItem.commitTo(sprint);
}

```

- 커맨드 핸드러가 완성되면 단일 애그리게잇 인스턴스가 업데이트되고, 커맨드 모델에 의해 도메인 이벤트가 게시된다

#### 커맨드 모델(쓰기 모델)은 해동을 수행한다

- 커맨드 모델상의 각 커맨드 메소드가 수행되면, 도메인 이벤트에서 설명하는 바와 같이 이벤트를 게시하며 수행이 완료된다
- 아래 코드처럼 BacklogItem은 해당 커맨드 메소드가 완료되도록 해준다

```java
public class BacklogItem extends ConcurrencySafeEntity {
    public void commitTo(Sprint aSprint) {
        DomainEventPublisher.instance().publish(new BacklogItemCommitted(
                this.tenant(),
                this.backlogItemId(),
                this.sprintId()
        ));
    }
}
```

- 어떤 경우든 쿼리 모델을 업데이트시키기 위해선 도메인 이벤트를 게시해야 한다

## 이벤트 주도 아키텍처 / 데이터 패브릭과 그리드 기반 분산 컴퓨팅은 생략