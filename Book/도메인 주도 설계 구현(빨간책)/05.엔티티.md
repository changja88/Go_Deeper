## 엔티티

- 개발자는 도메인보다 데이터에 초점을 맞추려는 경향이 있다. 주로 데이터의 속성(열)과 연결(외래 키)를 먼저 생각하려 한다
    - 이렇게 해서 데이터 모델을 대응하는 객체로 투영하게 되는데, 이로 인해 '도메인 모델'안에 있는 거의 모든 개념이 게터와 세터 메소드를 너무 많이 갖고 있는 엔티티로 코딩된다

- 로드맵
    - 고유한 대상을 설계할 떄 엔티티가 왜 올바른 위치를 가지는지 생각해보자
    - 엔티티를 위한 고유 시별자의 생성 방법을 확인하자
    - 팀이 엔티티 설게에서 유비쿼터스 언어를 잡아내느 설계 회의를 살펴보자
    - 엔티티의 역할과 책임을 표현하는 방법을 학습하자
    - 예제를 통해 엔티티의 유효성을 검사하는 방법과 그 결과를 저장소에 저장하는 방법을 살펴보자

## 엔티티를 사용하는 이유

- 개별성, 한 개념을 시스템내의 나머지 모든 객체와 반드시 구분해야 하는 제약 조건이 있을 때, 이를 엔티티로 설계한다
- 엔티티 고유한 대상으로 긴 시간에 걸쳐 계속해서 변화할 수 있다
- `고유 식별자와 변화 가능성(mutability)이라는 특징이 엔티티와 값 객체 사이의 차이점이다`
- 엔티티가 모델링 도구로 적합하지 않을 떄도 잇다. 잘못된 사용은 많은 사람들이 느끼는 것보다도 훨씬 더 자주 일어 난다
    - 대부분 개념은 값으로 모델링해야 한다
    - 만약 이에 동의할 수 없다면, DDD는 비즈니스 요구에 맞지 않을 수 있으며, CRUD기반의 시스템이 더 적합할 가능성이 상당히 높다
    - 문제는 CRUD 기반의 대안이 자원을 절약하게 해주진 않는다는 점이다

## 고유 식별자

- 엔티티의 설계 초기엔 특성이나 행동에 집중하기보단, 엔티티 객체를 식별하거나 매칭해서 찾을 때 사용되는 기본적인 특성을 파고 들어야 한다
    - 그 후에 개념적으로 필수적인 행동과 그 행동에서 필요로 하는 특성만을 추가해야 한다
    - `이는 시간이 흘러도 고유성(uniqueness)의 보존을 보장해주는 아주 중요한 일이다`
- 고유 실별자는 탐색이나 매칭에 실용적으로 사용될 수도 있지만, 그렇지 않을 수도 있다
    - 고유 식별자를 매칭에 사용할 수 있는지 여부는 식별자가 얼마나 사람이 릭기 쉽도록 돼 있는지에 달려 있다
    - 예를 들어 애플리키에션에서 사용자가 사용할 수 있는 사람의 이름을 검색 할 때, 사람의 이름이 Person 엔티티의 고유 식별자로 쓰일 가능성은 거의 없다. 많은 사람의 이름은 고유하지 않기 때문이다.
      반면 회사의 세무 식별자를 검색한다면, 이 세무 식별자는 company 엔티티의 일차적인 고유 식별자가 될 가능성이 크다. 세무 식별자는 정부가 발행하는 고유한 식별자이기 때문이다
- 식별자 생성의 일반적인 전략
    - 1>사용자는 애플리케이션에 하나 이상의 초기 교유 값을 입력한다. 애플리케이션은 입력한 값이 고유한지 확인해야 한다
    - 2>애플리케이션은 내부적 고유성이 보장되는 알고리즘을 사용해 식별자를 생성한다. 라이브러리나 프레임워크가 이를 대신할 수도 있지만, 애플리케이션이 직접 수행할 수도 있다
    - 3>애플리케이션이 데이터베이스와 같은 영속성 저장소를 사용해 고유 식별자를 생성한다
    - 4>또 하나의 바운디드 컨텍스트에서 먼저 고유 식별자를 결정한다. 이 식별자가 입력되거나, 사용자가 여러 선택지 중 하나를 선택한다
    - 각 단계에서 직면하게 되는 어려운 점과 개별적 전략을 하나씩 살펴보자

### 사용자가 식별자를 제공한다

<img src = "./img/IMG_6229.JPG" width = "600" height = "250">

- 사용자(개발자 말고)가 직접 고유 식별자의 세부사항을 입력하는 편이 간단해 보일 수 있다
- 실제로 간단하기는 하지만 몇가지 문제점이 있다
    - 양질의 식별자를 사용자에게 의하는 것은 문제가 될 수 있다. 고유하더라도 올바르지 않을 수 있다
    - 위 이미지 처럼 포럼과, 토론의 제목을 고유 식별자로 사용했다면, 제목을 잘못 쓴다거나 제목을 바꾸기 위해선 비용이 얼마나 뜰까?
    - `일반적으로 사용자 입력 값은 언제든 매칭에 사용할 엔티티의 속성으로 고려해도 되지만, 이를 고유 식별자로 사용해선 안된다`
- 사람이 읽을 수 있는 식별자가 반드시 필요한 상황에선 워크플로 지원이 가능하다면 식별자의 품질을 확보하기 위해서 몇 가지 사이클을 추가해 품질을 확보해야 한다

### 애플리케이션이 식별자를 생성한다

- 애플리케이션이 클러스터링 되거나 다수의 컴퓨팅 노드에 걸쳐 배포된 상황이라면 신경을 써야겠지만, 고유 식별자를 자동으로 생성할 수 있는 신뢰도 높은 방법이 있다
    - 보편적 고유 식별자(UUID)나 전역 고유 식별자(GUID)가 이런 접근법의 예이다

#### UUID

- UUID는 상대적으로 생성이 빠르너 식별자이고, 영속성 메커니즘과 같은 외부와의 상호 교류가 필요하지 않다
- 1초 동안 특정 종류의 엔티티가 무수히 생성되더라도, UUID 생성기는 그 속도를 유지할 수 있따
- 좀 더 고성능의 도메인에선 얼마나 많은 UUID 인스턴스든 배그라운드에서 캐시를 다시 채우며 캐싱할 수 있다. 만약 캐시된 UUID 인스턴스가 서버의 재시작으로 사라졌더라도, 임의의 만들어진 값에 기반했기 때문에
  식별자에는 빈 공간이 없다. 폐기된 값은 서버의 재시작으로 캐시를 다시 채우는 과정에 나쁜 영향을 미치지 않는다

#### 서드파티

- 써드파티 라이브러리와 프레임워크에서 식별자 생성기를 찾을 수 있다
- 아파치 커먼스 프로젝트는 컨먼스 Id 컴포넌트를 포마하고 있는데, 이는 다섯 종류의 식별자 생성기를 제공한다
- NoSQL인 리악(Riak)rhk 몽고DB등의 영속성 저장소는 식별자를 생성해줄 수 있다

### 영속성 메커니즘이 식별자를 생성한다

- 고유 식별자의 생성을 영속성 메커니즘에 위임하는 방식만의 이점이 있다
    - 데이터 베이스로 시퀀스나 증가 값을 호출한 결과는 언제나 고유하다
- 성능적 측면이 단점이 될 가능성도 있다
    - 값을 얻기 위해 데이터베이스까지 가야 한다는 점이 애플리케이션 안에서 식별자를 생성할 때 비해 유의미하게 많은 시간을 소모할 수 있다
    - 이는 데이터베이스의 부하와 애플리케이션의 요청에 따라 달라진다
    - 이런 문제를 피하는 방법으로 리파지토리 내부와 같이, 애플리케이션의 안쪽에 시퀀스/증가 값을 캐싱하는 방버비 있다
- 생성의 시점이 문제가 될 수도 있는데 이는 후반부에 다룬다
- 식별자 생성의 요구사항 (때론 식별자 엔티티의 생성과 할당이 일어나 시점이 중요하다)
    - 빠른 식별자 생성과 할당은 엔티티가 저장되기 전에 일어난다
    - 늦은 식별자 생성과 할당은 엔티티가 저장될 때 일어난다

### 또 하나의 바운디드 컨텍스트가 식별자를 할당한다

<img src = "./img/IMG_6230.JPG" width = "400" height = "350">

- 또 다른 컨텍스트가 식별자를 할당할 땐 각 식별자의 검색과 매칭과 할당을 위한 통합이 필요하다
    - DDD 통합은 컨텍스트 맵과 바운디드 컨텍스트의 통합에서 다룬다
- 정확하게 들어맞는 매칭이 가장 이상적이다
    - 이미지 처럼 사용자는 의도한 결과를 정확히 표시하기 위해 계좌 번호나 사용자명, 이메일 주소, 기타 고유 기호등 과 같은 속성을 하나이상 제공해야 한다
    - 확정되지 않은 입력에 따라 매칭할 땐 여러 검색 결과가 나올 수 있기 때문에 사용의 선택이 필요할 수 있다(위 이미지)

### 식별자 생성의 시점이 문제가 될 때

- 식별자 생성은 객체 구성의 일부로서 일찍 얼아나거나 영속성의 일부로서 늦게 일어날 수 있다. 시점이 중요한 상황이라면, 무엇이 관련됐는지 이해해야 한다

<img src = "./img/IMG_6231.JPG" width = "600" height = "350">

- 위 이미지는 가장 단순한 경우인 새 엔티티가 영속됐을 때, 즉 새로운 행이 데이터베이스에 삽입되었을 때이다
    - 클라이언트는 새 Product를 인스턴스화하고 이를 ProductRepository에 추가한다
    - Product인스턴스가 새롭게 생성되는 시점에서 클라이언트는 해당 식별자가 필요하지 않다
    - 오직 인스턴스를 저장한 이후에만 식별자를 사용할 수 있다

<img src = "./img/IMG_6232.JPG" width = "600" height = "350">

- 위 이미지에서는 오직 인스턴스를 저장한 이후에만 식별자를 사용할 수 있었다
    - 하지만 이 이미지에서는 식별자를 먼저 생성하기 때문에 인스턴스를 영속성에 저장하기 전에 식별자를 사용할 수 있다
    - 즉, 식별자가 영속성에 저장되기 전에 필요한 경우가 있고, 알아야 한다
- 식별자가 영속성에 저장되기 전에 필요한 경우
    - 첫 번째 이미지처럼 구성되어 있는 경우 클라이언트가 새로운 Product를 ProductRepository에 추가할 기회를 잡기 전에 도메인 이벤트를 수신한다
    - 따라서 이를 올바르게 처리하기 위해서는 식별자 생성을 빠르게 완료해야 한다 (위 그림처럼)
    - 즉, 레이스 컨디션이 발생할 수 있다 Repository에 저장을 완료하기 전에 새로운 Product를 요청하게 되면 저장하려고 한 Product와 새로운 요청의 Product의 식별자가 같아 질 수 있다

#### 대리 식별자

- 하이버네이트와 같은 ORM도구는 자신만의 고유한 방법으로 객체 식별자를 처리하길 원한다
    - 하이버네이트는 숫자 시퀀스와 같은 데이터베이스의 원시 타입을 각 엔티티의 1차 식별자로 사용한다
    - 만약 도메인에서 다른 유형의 식별자가 필요하다면, 하이버네이트와 충동을 일으키며 이를 해결하기 위해서는 두개의 식별자를 사용해야한다
    - 하나는 도메인 모델에 맞춰 도메인 요구사항에 따라 설계한다. 다른 하나는 하이버네이트를 위한 식별자로 대리 식별자 라고 부른다
- 구현 방법
    - 대리 식별자를 담을 특성을 엔티티에 추가한다. 일반적으로 long,int를 사용한다
    - DB에 엔티티 테이블 내에 열을 하나 생성하고, 기본 키 제약 조건을 추가한다
    - 하이버네이트 매핑 정의에 id 를 추가하고, 이는 도메인 식별자와 전형 상관없으며, ORM만을 위해서 사용된다
- 계층 슈퍼타입을 사용해서 한 가지 안전 장치를 추가할 수 있다

```java
public abstract class IdentifiedDomainObject implements Serializable {
    private long id = -1;

    public IdentifiedDomainObject() {
        super();
    }

    protected long id() {
        return this.id;
    }

    protected void setId(long anId) {
        this.id = anId;
    }
}
```

- IdentifiedDomainObject 은 Protected 접근자 메소드를 사용해 클라이언트 뷰에서 대리 기본 키를 감추는 추상 기본 클래스이며 계층 슈퍼타입이다
    - 해당 기본 클래스를 확장한 엔티티의 모듈 밖에서는 가시성이 없기 떄문에 클라이언트는 이 메소드를 사용해야 할지 고민할 필요가 없다
    - 심지어 private 범위도 가능하다
    - 도메인 식별자가 데이터베이스의 기본 키 역할을 수행해야 할 필요는 없으며, 다른 데이블 내에 외래 키로서, 참조 무결성을 제공한다
- 즉 id를 대기 기본키 데이터베이스 식별자로 사용하고 다른 필드를 추가해서 그걸 도메인 식별자로 사용한다는 뜻

#### 식별자 안전성

- 대부분의 경우 고유 식별자는 수정하지 못하도록 보호되고, 할당된 엔티티의 수명주기에 걸쳐 안정적으로 유지돼야 한다
- 식별자 수정을 방지하기 위해서 취할 수 있는 당연한 방법이 있다
    - 식별자 setter를 클라이언트로부터 숨기는 방법이 있고,
    - 이미 존재한다면 식별자의 상태 변화로부터 엔티티 자체를 보호하기 위해 setter 내에 가드를 만들 수 도 있다

```java
public class user extends Entitiy {
    protected void setUsername(String aUsername) {
        if (this.username != null) {
            throw new IllegalStateException("this username may not be changed.");
        }
        if (aUsername == null) {
            throw new IllegalArgumentException("The username may not be set to null");
        }
        this.username = aUsername;
    }
}
```

- 위 코드에서 username 특성은 User엔티티의 도메인 식별자이며, 단 한번만 그리고 내부적으로 변형이 가능하다
    - setUsername()이라는 세터는 클라이언트로부터 스스로를 숨기며 캡슐화를 제공한다
- 이 setter는 영속성으로부터 객체 상태를 재구성해야 할 떄 하이버네이트의 걸림돌이 되지 않는다
    - 객체는 애초에 인수가 없는 기본 생성자로 만들어지기 때문에 처음엔 username이 null이다
    - 이는 깔끔한 재초기화가 가능케 해주며, setter를 통해 일회성인 하이버네이트의 초기값 할당이 일어난다
    - 하이버네이트가 영속성과 복원을 위해 접근자가 아닌 필드(특성) 접근을 사용토록 설정했다면 이는 완전히 생략된다

## 엔티티의 발견과 그들의 내부적인 특성

- 엔티티와 속성을 알아내기
- 필수 행동 파헤치기
- 역활과 책임
- &rarr; 즉 OOP를 준수하자!!

### 유효성 검사

- 정합성을 검사하는 이유는 특성/속성, 전체 객체, 객체의 컴포지션 등의 정확성을 확인하기 위해서다

#### 특성/속성의 유효성 검사

- 특성/속성을 비유효한 값의 설정으로부터 보호해야 한다
    - 자기 캡슐화를 사용해서 보호해야 한다
    - 자기 캡슐화는 심지어 같은 클래스 내에서부터 모든 데이터로의 액세스가 접근자 메소드를 거쳐가도록 설계하는 방법이다. 이 기법의 사용에는 몇 가지 이점이 있다
        - 객체의 인스턴스 변수를 추상화할 수 있도록 해준다. 이를 통해 해당 객체를 담고 있는 많은 다른 객체에게 손쉽게 특성/속성 가오는 방법을 제공한다

```java
public final class EmailAddress {
    private String address;

    private void setAddress(String andAddress) {
        if (andAddress == null) {
            throw new IllegalArgumentException("THe address may not be set to null")
        }
    }
}
```

- EmailAddress는 엔티티가 아니고 값객체다
    - 1>값 객체를 사용하는 이유는 null확인에서부터 값 포맷팅에 이르기까지 다양한 전제 조건의 가드를 구현하기 좋기때문이다
    - 2>Person 엔티티는 ContactInformation 값을 통해 간접적으로, 이 값을 자신의 속성중 하나로 갖게 된다. 따라서 엔티티 클래스에 선언된 단순한 특성도 엔티티의 일부인 것과 마찬가지로,
      실제론 이 역시도 엔티티의 일부이다
- 일부 개발자들은 이런 종류의 전제 조건 확인을 방어적 프로그래밍이라 부른다

#### 전체 객체의 유효성 검사

- 완전히 유효한 특성/속성의 엔티티를 가지고 있더라도, 전체 엔티티가 유효하다는 의미는 아니다
- 전체 엔티티의 유효성을 검사하기 위해선 전체 객체의 상태로의 엑세스가 필요하며, 유효성 검사를 위해선 명세나, 전략이 필요하다
- 유효성 검사에는 엔티티의 전체 상태가 사용 가능해야 하므로, 이 시점을 유효성 검사 프로세스 로직을 엔티티로 직접 집어넣기에 알맞은 순간으로 볼 수 있다
    - 엔티티 내부에 유효성 검사를 집어 넣으면 너무 많은 책임을 부여하게 된다
    - 유효성 검사 클래스를 설계할 때, 이를 엔티티와 같은 모듈(패키지)안에 두어야 하며, 유효성 검사 클래스가 접근 할 수 있도록 protected가 적합하다
- 유효성 검사 클래스는 명세 패턴이나 전략 패턴을 구현할 수 있다

```java
public abstract class Validator {
    private ValidationNotificationHandler notificationHandler;

    public Validator(ValidationNotificationHandler aHandler) {
        super();
        this.setNotificationHandler(aHandler);
    }

    public abstract void validate();

    protected ValidationNotificationHandler notificationHandler() {
        return this.notificationHandler;
    }

    private void setNotificationHandler(ValidationNotificationHandler aHandler) {
        this.notificationHandler = aHandler;
    }
}

public class WarbleValidator extends Validator {
    private Warble warble;

    public Validator(Warble aWarble, ValidationNotificationHandler aHandler) {
        super(aHandler);
        this.setWarble(aWarble);
    }

    //1> 일반적인 구현 
    public void validate() {
        if (this.hasWarpedWarbleCondition(this.warble())) {
            this.notificationHandler().handelError("The warble is warped");
        }

    }

    //2> 이렇게 구현하면 에러 메시지나 메시지 속성 키나 일림에 관한 세부사항 등과 유효성 검사 사이에 결합이 일어나지 앟는다  
    public void validate2() {
        if (this.hasWackyWarbleState(this.warble())) {
            this.notificationHandler().handleWackyWarbleState();
        }
    }
}

// 유효성 검사가 필요한 모든 엔티티에 validate 메소드를 위치시키고, 계층 슈펴타입을 활용하는 방법도 있다 
public abstract class Entitiy extends IdentifiedDomainObject {
    public Entity() {
        super();
    }

    public void validate(ValidationNotificationHandler aHandler) {

    }
}

public class Warble extends Entitiy {
    @Override
    public void validate(ValidationNotificationHandler aHandler) {
        (new WarbleValidator(this, aHandler)).validate();
    }
}
```

#### 객체 컴포지션의 유효성 검사

- '단순한 활동과 그 밖의 부수적인 부분을 모두 아우르는 검사가 필요한, 더욱 복잡한 행동'이라 말한 대상에 지연 휴성 검사를 사용할 수 있다.
    - 여기에선 개별 엔티티가 유효한지뿐만 아니라, 하나 이상의 애그리게잇 인스턴스를 포함한 클러스터나 엔티티의 컴포지션이 모두 유효한지 판단한다
    - 이를 위해 구체적 Validator 서브클래스를 필요한 수만큼 인스턴스화할 수 있다. 하지만 이런 유형의 검사는 도메인 서비스를 사용하는 편이 최선일 수 있다
    - 도메인 서비스는 유효성 검사가 필요한 애그리게잇 인스턴스를 읽기 위해 리파지토리르 ㄹ사용할 수 있따. 그런 다음 각 인스턴스를 각각의 속도에 맞춰 별도로 실행하거나 다른 인스턴스와 묶어서 실행하게 된다
- 유효성 검사가 항상 필요한지 여부를 결정해야 한다

## 변화 추적

- 인티티의 정의에 따라 수명주기에 걸쳐 일어나는 모든 상태 변경을 추적할 필요는 없다
    - 오직 계속 변화하는 상태만을 지원해야 한다
- 정확하고 유용하면서 가장 실용적인 변경 추적은 도메인 이벤트와 이벤트 저장소를 통해 이뤄진다
    - 도메인 전문가가 신경 쓰고 있는 모든 애그리게잇에 간해, 해당 애그리게잇에서 실행되며 상태를 바꾸는 모든 중요한 커맨드마다 고유한 이벤트 타입을 생성한다
    - 이벤트 이름과 해당하는 속성을 좋바해서 명시적으로 변경을 기록할 수 있다
    - 커맨드 메소드가 완료되면 이벤트가 게시된다. 구독자는 모델에서 만들어지는 모든 이벤트를 수신하도록 등록한다. 구독자는 이벤트를 수신함에 따라 해당 이벤트를 이벤트 저장소에 저장한다
- 도메인 전문가가 모델에서 일어난 모든 변화를 시경쓰진 않을지라도, 기술 팀에 관심을 가질 수도 있다. 이는 보통 기술적인 이유 때문이며 이벤트 소싱이란 이름의 패턴을 사용한다 