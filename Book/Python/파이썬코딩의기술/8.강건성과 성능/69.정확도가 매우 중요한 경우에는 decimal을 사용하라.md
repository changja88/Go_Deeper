## 정확도가 매우 중요한 경우에는 decimal을 사용하라

- 파이썬은 수치 데이터를 처리하는 코드를 작성하기에 매우 좋은 언어이다
- 파이썬 정수 타입은 실용적으로 어떤 크기의 정수든 표현할 수 있따
- 2배 정밀도 (double percision)부동소수점 타입은 IEEE 754 표준을 따른다
- 파이썬은 허수값을 표현하는 표준 복소수 타입도 제공한다
- 하지만 이것 만으로는 부족한 경우가 있다

#### 예시

```python
rate = 1.45
seconds = 3 * 60 + 42
cost = rate * seconds / 60  # 5.3645499999999
```

- IEEE754 부동소수점 수의 내부(이진) 표현법으로 인해 결과는 올바른 값 5.36보다 0.000000000000001 만큼 더 작다
- 이걸 반올림 처리 하면 문제가 발생할 수 있다 -> 5.36이 되어서 최종 요금이 줄어 들게 된다
- 위 문제를 해결하기 위해서는 내장모듈 decimal에 있는 Decimal 클래스를 사용하는 것이다

### Decimal 클래스

- Decimal 클래스는 디폴트로 소수점 이하 28번째 자리까지 고정소수점 수 연산을 제공하며, 자릿수를 늘릴 수도 있다
    - 이 기능을 사용하면 IEEE 754 부동소수점 수에 존재하는 문제를 우회할 수 있다
    - 반올림 처리도 원하는 대로 더 정확히 할 수 있다
  ```python
  rate = 1.45
  seconds = Decimal(3 * 60 + 42)
  cost = rate * seconds / Decimal(60)  # 3.365 
  ```
- Decimal 인스턴스에 값을 지정하는 방법은 두 가지가 있따
    - 1> 숫자가 들어 있는 str을 Decimal 생성자에 전달 하는 방법
    - 2> int나 float인스턴스를 생성자에 전달하는 방법
  ```python
  print(Deciaml('1.45')) # 1.45
  print(Deciaml(1.45))   # 1.44999999999934593459234523452
  ```
    - 위 두개는 다른 값이다
    - 정수에서는 위 문제가 없다
    - 즉, 정확한 답이 필요하다면 타입 생성자에 str을 사용해야 한다

```python
rate = Decimal('0.05')
seconds = Decimal('5')
small_cost = rate * seconds / Decimal(60)
print(small_cost)  # 0.004166665666666
```

- 위 코드에서 small_cost는 너무 작기 때문에 센트 단위로 반올림을 하면 0이 나와버린다 -> 문제다
- 다행히 Decimal 클래스에는 원하는 소수점 이하 자리까지 원하는 방식으로 근삿값을 계산하는 내장 함수가 들어 있다

```python
rounded = small_cost.quantize(Decimal('0.01'), rounding=ROUND_UP)
# 반올림 전: 0.004166665666666 반올림 후: 0.01
```

- quantize 메서드를 위와 같은 방식으로 사용하면 통화 시간이 짧고 요금이 저렴한 통화료도 제대로 처리할 수 있다
- Decimal은 고정 소수점 수에 대해서는 잘 작동하지만 여전히 정밀도예 한계가 있다
    - 1/3 은 여전히 근사치를 사용해야 한다
    - 정밀도 제한이 없는 유리수를 사용하고 싶다면 fractions 내장 모듈에 있는 Fraction 클래스를 사용해야 한다 