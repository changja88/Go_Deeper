## 순환 의존성을 꺠는 방법을 알아두라

- 다음은 모듈이 임포트되면 파이썬이 실제로 어떤일을 한는지 깊이 우선순위이다
    - 1> sys.path에서 모듈 위치를 검색한다
    - 2> 모듈의 코드를 로딩하고 컴파일되는지 확인한다
    - 3> 임포트할 모듈에 상응하는 빈 모듈 객체를 만든다
    - 4> 모듈을 sys.modules에 넣는다
    - 5> 모듈 객체에 있는 코드를 실행해서 모듈의 내용을 정의한다
- 순환 의존 관게에서 문제는 어떤 모듈의 애트리뷰트를 정의하는 5단계가 실제로 실행되기 전까지는 모듈 애트리뷰트가 정의되지 않는다는 점이다
- 의존 관계 주입 같은 패턴을 적용할 수도 있지만, 코드 구조를 변경해서 명시적인 configure단계를 분리할 수 없을 떄도 있다
    - 모듈 안에 서로 다른 단계가 둘 이상 있으면, 객체를 정의하는 부분과 객체를 설정하는 부분이 분리되기 때문에 코드를 읽기가 더 어려워 진다

### 임포트 순서 바꾸기

```python
# app.py
class Prefs:
    ...


prefs = Prefs()

import dialog

dialog.show()
```

- 첫 번째 접근 방법은 임포틑 순서를 바꾸는 것이다
    - 예를 들어 app모듈의 다른 내용이 모두 실행된 다음, 맨 뒤에서 dialog모듈을 임포트할 수 있다
- 이 방식이 작동하는 이유는 dialog모듈이 나중에 로딩될 때 dialog안에서 재귀적으로 임포트한 app에 appl.prefs가 이미 정의돼 있기 땜쿤이다
- 하지만 PEP8 스타일 가이드에 위배된다 -> 항상 파이썬 파일의 맨 위에 임포트를 넣어야 한다

### 임포트, 설정, 실행

```python
# dialog.py
import app


class Dialog:
    ...


save_dialog = Dialog()


def configure():
    save_dialog.save_dir = app.prefs.get('save_dir')


# app.py
import dialog


class Prefs:
    ...


prefs = Prefs()


def configure():
    ...


# main.py
import app
import dialog

app.configure()
dialog.configure()
```

- 두 번째 해결 방법은 임포트 시점에 부작용을 최소화한 모듈을 사용하는 것이다
    - 모듈이 함수, 클래스, 상수만 정의하게 하고, 임포트 시점에 실제로 함수를 전혀 실행하지 않게 만든다
    - 그 후 다른 모듈이 모두 임포트를 끝낸 후 호출할 수 있는 configure함수를 제공한다
    - configure의 목적은 다른 모듈들의 애트리뷰트에 접근해 모듈 상태를 준비하는 것이다
    - 다른 모든 모듈을 임포트한 다음에 configure를 실행하므로 configure가 실행되는 시점에는 항상 모든 애트리뷰트가 정의돼 있다

### 동적 임포트

- 순환 임포트에 대한 세 번째 해결 방법은 import문을 함수나 메서드 안에서 사용하는 것이다
    - 이를 동적 임포트라고 부른다
- 일반적으로 이런 동적 임포트는 피하면 좋다
    - import 문의 비용이 무시하지 못할 만큼 크며, 자주 빠르게 반복된느 루프 안에서 임포트를 사용하면 악영향이 커진다
    - 동적 임포트를 사용하면 임포트 실행을 미루기 때문에 실행 시점에 예기치 못한 오류가 발생할 수 있다