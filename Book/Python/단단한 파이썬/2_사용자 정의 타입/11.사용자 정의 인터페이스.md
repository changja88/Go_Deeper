## 사용자 정의 인터페이스

### 자연 스러운 인터페이스 설계

- 목표는 코드의 호출자가 쉽고 분명하게 사용할 수 있도록 하는 것이다
- 코드가 쓰기 어렵다면 아래와 같은 현상이 발생한다
- `인터페이스는 사용자가 정확히 사용하도록 그리고 잘못 사용하지 못하게 쉽게 만들어야 한다 `

#### 기능 복제

- 사용하기 어렵다고 느끼고 스스로 타입을 만들고 기능을 스스로 만든 타입에 복제한다
- 이럴 경우 비슷한 두 타입이 서로 경합을 하게 되고 관리 포인트가 늘어나며 버그가 발생 확률과 추가 비용이 증가한다

#### 깨진 멘탈 모델

- 개발자들은 코드 작업을 할 때 추론을 위한 멘탈 모델을 세우는데, 어떤 타입들이 추론하게 어려우면 멘탈 모델을 흔들린다
- 멘탈 모델이 흔들리면 타입을 잘못 사용하게 되고 버그로 이어질 가능성이 커진다
    - 호출 순서가 있는 경우 지키지 않을 수도 있고, 코드를 잘 못 이해해 오용할수도 있다

#### 테스트 감소

- 사용하기 어려운 코드는 테스트도 어렵다
- 또한 테스트 코드 작성이 어려우면 자연스레 테스트 케이스도 줄어든다

### 사용자 처럼 생각하기

- 지식의 저주: 어떤 개인ㅇ이 다른 사람들과 의사소통을 할 때 다른 사람도 이해할 수 있는 배경을 갖고 있다고 자신도 모르게 추측해서 발생하는 인식적 편견
    - 이 저주 때문에 사용자 처럼 생각하기란 쉽지 않다
- 지식의 저주를 극복하기 위해서는 다음의 것들이 도움이 된다

#### 테스트 주도 개발

- TDD는 기본적으로 다음 루프를 기본으로 한다
    - 실패하는 테스트를 추가
    - 테스트를 통과하는 코드 작성
    - 리팩토링
- TDD의 의도는 타입 사용법을 이해하는 데 매우 유용하다
- 테스트 주도 개발의 효용은 개발 후 테스트와 동일하다고 생각한다 &rarr; 아니다
    - TDD를 테스트 방법론이 아니라 설계 방법론이다
    - 진짜 가치는 테스트가 인터페이스 설계를 얼마나 도와주는지에 있다
    - TDD를 사용하면 구현체를 작성하기 전에 어떻게 코드가 호출되는지를 미리 볼 수 있다
- 또한 잘 작성된테스트 코드는 타입이 어떻게 작동되는지 알려주는 좋은 문서 역할을 한다
- 코드가 시스템에서의 동작에 대한 유일한 진실이라면 테스트도 코드와 사용작용을 하는 유일한 소스가 된다

#### README 주도 개발

- RDD 역시 코드가 작성되기 전에 사용하기 어려울 것 같은 코드를 미리 알아내기 위한 설계 방법론이다
- RDD의 목표는 최상위 레벨에서의 아이디어와 중요한 코드와의 상호작용을 프로젝트 내의 단일 문서로 추출하는 것이다
    - 이 단일 문서가 README파일이다
    - 이는 코드의 다른 부분들이 어떻게 상호작용을 하는지 공식화하는 좋은 방법이며, 사용자가 따라할 수 있는 더 높은 레벨의 패턴을 제공할 수 있다
- RDD는 다음과 갖은 장점이 있다
    - 폭포수 방법론에서처럼 모든 레벨의 문서를 처음부터 작성할 필요가 없다
    - README 파일은 때로는 개발자가 제일 처음 만나는 부분이다. RDD는 개발자에게 좋은 첫 인상을 줄 수 있는 기회가 된다
    - 작성된 코드를 수정하는 것보다 팀의 토론에 기반을 두고 문서를 수정하는 것이 더 쉽다
    - 잘못된 코드 내 결정의 설명을 위해 README를 사용할 필요가 없다. 대신 코드가 이상적인 유스 케이스로 변경돼야 한다
- `미래의 개발자가 실제로 유지 보수를 할 수 있어야만 유지 보수가 가능한 소프트웨어 구축에 성공한 것이다`

#### 사용성 테스트

- 사용성 테스트는 제품에 대한 사용자가 어떤 생각을 하는지 실제로 물어보는 프로세스다
- 복도 테스트(Hallway testing)을 통해 사용자 테스트를 쉽게 시작할 수 있다
    - 인터페이스를 설계했다면 복도를 지나가는 첫 번째 사람을 붙들고 설계에 대해 피드백을 들어본다
    - 좀 더 공식적인 테스트를 원하는 경우 잠재 사용자들을 직접 인터페이스 앞에 세워 놓는 작업도 할 수 있다
        - 잠재 사용자들이 인터페이스를 어떻게 사용하는지 본다

### 자연스런 상호작용

- 매핑은 '실제 세계의 결과에 따른 동작과 제어와의 관계'로 묘사 된다
    - `물리적 비유와 문화적 표준을 활용해 이어져야 자연스럽다`
    - '제어와 동작' 은 인터페이스를 구성하는 함수와 타입을 의미한다
    - '실제 세계의 결과'는 코드의 작동을 의마한다
    - 즉 인터페이스를 보고 사용자가 직관적으로 이해할 수 있어야 한다
- 이를 위한 가장 좋은 방법은 작성자의 도메인과 다른 일반 지식을 코드로 매핑하는 것이다
    - 작성한 코드에 익숙하지 않은 사용자가 이해할 수 있는지를 확인 해야 한다
- 즉, 코드에 익숙하지 않더라도 도메인을 잘아는 사람이라면 쉽게 이해할 수 있도록 인터페이스를 모델링 해야 한다

### 자연스런 상호작용의 실제

- 자동화된 식료품 픽업 서비스의 일부를 위한 인터페이스를 설계하는 예제이다
    - 사용자가 스마트폰으로 레시피를 스캔하면 앱이 자동으로 어떤 재료가 필요한지 찾아낸다
    - 사용자가 주문을 승인하면 앱은 지역 식료품점들에 재료의 가용을 묻는 쿼리를 보내고, 그 결과에 따라 배송 일정을 잡는다
- 자세한 내용은 코드 참조

#### 매직 메서드

| 매직 메서드                    | 사용처                               |
|---------------------------|-----------------------------------|
| add, sub, mull, div       | 산술 연산                             |
| bool                      | if 체크에 대한 묵시적 불리언 변환              |
| and, or                   | 논리 연산                             |
| getattr, setattr, delattr | 속성의 접근(obj,name이나 del obj.name 등) |
| le, lt, eq, ne, gt, ge    | 비교연산                              |
| str, repr                 | 문자열로 변환(str) 또는 재현 기능(repr        |

#### 컨텍스트 관리자

- @contextmanager로 데코레이션된 모든 함수는 with 블록과 함께 사용할 수 있다

```python
@contextmanager
def create_grocery_list(order: Order, inventory: Invertory):
    grocery_list = _GroceryList(order, inventory)
    try:
        yield grocery_list
    finally:
        if grocery_list.has_reserved_items():
            grocery_list.unreserve_items()


with create_grocery_list(order, grocery_inventory) as grocery_list:
    grocery_list.reserve_items_from_stores()
    wait_for_user_grocery_confirmation(grocery_list)
    grocery_list.order_and_unreserve_items()
    deliver_ingredients(grocery_list)
```

- with 코드가 종료되면 실행이 yield문 바로 다음에 있는 컨텍스트 관리자로 반환된다
  - 이는 예외 발생이나 with블록의 정상 종료에 관계 없다 (try..finally)구문으로 감쌌기 때문