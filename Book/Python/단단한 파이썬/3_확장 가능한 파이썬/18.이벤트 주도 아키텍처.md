## 이벤트 주도 아키텍처

- `아키텍처는 일련의 고차원적 가이드라인이며 어떻게 소프트웨어를 설계할지에 대한 틀을 잡아준다`
    - 좋은 아키텍처는 확장성을 증진시키고 의존성을 잘 관리하고, 조합 가능성을 촉진시킨다
- `이벤트 주도 아키텍처는 시스템의 이벤트나 알림을 중심으로 운영된다`
    - 새로운 기능이나 성능을 위한 시스템 확장과 더불어 코드 베이스의 각기 다른 부분을 분리할 수 있는 최적의 방법이다
    - 주위에 영향을 최소화하면서 새로운 변경을 도입하게 도와준다
- `단일 이벤트와 스트리밍 이벤트를 알아야 한다`

### 동작방식

- 이벤트 주도 아키텍처에 초점을 맞추면 현상에 대한 반응을 중심으로 돌아가게 된다
    - 현상에 해당하는 것을 이벤트 생산자(producer)라고 부른다
    - 이벤트의 소비자(consumer)는 이 현상에 대한 반응에 해당한다
    - 무언갈르 반환하는 모든 함수는 생산자를 반환하며, 입력값으로는 소비자를 사용한다

```python
def complte_order(order: Order):
    package_order(order)
    notify_customer_that_order_id_done(order)
    notify_restaurant_that_order_is_done(order)
```

- 위 코드에서 comple_order는 완료된 주문의 형태로 정보를 생산하게 된다
  - 여기에는 생상자와 소비자 사이의 직접적인 연결 고리가 있다
    - 이베트 주도 아키텍처는 이러한 물리적 의존성을 제거하는 것을 목표로 한다
- `생산자는 소비자에 대해 알 수 없으며, 소비자도 생산자에 대해 알 수 없다`
    - 이것이 이벤트 주도 아키텍처가 만들수 있는 유연성이다
- 생산자와 소비자 사이의 모든 의존성을 대신해서 전송 메커니즘(transport mechanism)이 서로 데이터를 주고받는 방법을 제공한다

#### 단점

- 생산자와 소비자는 전송 메커니즘에 의존하기 떄문에 메시지의 포맷을 서로 맞춰야 한다
    - 이는 논리적 의존성을 발생시킨다 -> 타입체커의 도움을 받을 수 없고, 버그를 찾기 어렵다
    - 디버깅을 하다보면 전송 메커니즘을 만나서 서드파티 코드로 들어가 버린다
- 오류 처리가 어렵다
    - 생산자와 소비자를 분리하기 떄문에, 소비자 쪽에서 예외가 발생하거나 오류를 반환하면 생산자 측에서는 이를 처리하는 것이 어렵다

### 단일 이벤트

- 이벤트 기반 아키텍처의 가장 간단한 사례는 어떤 조건이 바뀌면 알림이나 동작을 하는 단일 이벤트(simple event)이다
    - 정보의 생산자는 이벤트를 보내는 측이며 소비자는 이 이벤트를 받고 이에 근거해 실행하는 측이다
    - 이를 실행하는 방법에는 두가지가 있다 -> 메시지 중재자가 있는 경우와 없는 경우

#### 메시지 중개자가 있는 경우

- 메시지 중개자란 데이터를 전달하는 역할을 하는 특정 프로그램을 의미한다
    - 생산자는 메시지 브로커의 특정 항목에 대해 메시지로 불리는 테이터를 만든다
    - 항목은 문자열 같은 것으로 이뤄진 간단한 고유의 식별자며 '주문'이나 '샌드위치 주문 완료'등이 있을 수 있다 -> 단순시 채널 사이의 구분을 위한 이름
    - 소비지나는 이 항목을 구독하고 동일한 식별자를 가진다
    - 메시지 중개자는 그 후에 항목을 구독하는 모든 소비자에게 메시지를 보낸다 -> 발행자/구독자 패턴
- PyPubSub이라는 파이썬 라이브러리를 사용할 수 있다
    - 이 라이브러리는 단일 프로세스 애플리케이션에서 사용되는 발행-구독 API이다
    - 항목 구독 설정을 해야 하며, 항목을 발행하기 위한 코드도 준비 해야 한다

```python
def notify_customer_that_meal_is_done(order: Order):
    ...


pub.subscribe(notify_customer_that_meal_is_done, "meal-done")
```

- 위 코드는 항목을 구독하기위해 항목화 호출할 함수를 정의한 부분이다

```python
def complte_order(order: Order):
    package_order(order)
    pub.publish("meal-done", order)
```

- 위 코드는 항목을 발행하는 코드이다
- `위 두개의 코드는 서로에 대해 알 지 못하는 부분이 핵임이다 -> 모두 항목/메시지 데이터 규측을 따르면 라이브러리에 의존하고 있다`
- 유연성의 장점은
    - 구독자를 아주쉽게 추가할 수 있다
    - 그냥 추가하고 구독만 시키면 된다
- 또한 PyPubSub 라이브러리는 디버깅을 위한 몇 가지 옵션을 제공한다
    - 작성 중인 새로운 항목이 발송되는 메시지와 같은 항목에 기능을 추가해 감시 작업을 실행시킬 수 있다
    - 구독자가 던지는 모든 예외에 대해 오류 처리를 추가할 수 있으며 모든 항목에 대해 한 번에 구독자를 설정할 수 있다

#### 관찰자 패턴

```python
def complete_order(order: Order, observers: list[Callabel[Order]]):
    package_order(order)
    for observer_func in observers:
        observer(order)
```

- 메시지 중개자를 사용하지 않고 관찰자 패턴(Observer Pattern)을 사용할 수 있다
    - 관찰자 패턴에서 생산자는 관찰자 리스트를 갖게 된다 (관찰자 = 소비자 )
    - 관찰자 패턴은 메시지 중계를 위해 라이브러리를 별도로 분리할 필요가 없다
    - 생산자와 소비자의 직접적인 연결을 피하기 ㅇ위해서 관찰자 정보를 제네릭으로 유지해야 한다
        - 관찰자에 대한 구체적인 정보는 추상화하면 안된다
        - 이를 함수 구현으로 해결한다 (함수의 타입은 Callable로 한다)
- 위 코드에서 중요한 점은 생산자는 알림을 보낼 함수의 목록밖에는 정보가 없다는 점이다
    - 새로운 관찰자를 추가하려면 파라미터로 전달되는 함수의 리스트에 새롭게 추가만 하면 된다
    - 또한 이는 함수이기 때문에 타입 체커가 호환되지 않는 방식으로 생산자를 수정할 때 캐치를 할 수 있으며, 중개자에서는 볼수 없는 중요한 부분이다
    - 서드파티가 없기떄문에 디버깅도 비교적 쉽다
- 위 코드는 전형적인 패턴은 아니다
    - 전통적인 방식은 클래스, 하위 클래스, 상속, 인터페이스 등을 이용한 객체지향 방식으로 표현된다 (Callabe을 안쓰고 그냥 내가 알고는 옵저버 패턴)

#### 단점

- 오류에 대해 좀더 민감하다
    - 관찰자가 예외를 던지면 생산자는 이를 바로 처리할 수 있어야 한다
- 생산자와 관찰자를 연결하느 ㄴ것은 메시지 중개자 패러다임에 비해 더 직접적이다
  - 중개자를 쓰면 발행자와 구독자가 코드의 위치에 상관없이 연결될 수 있다
    - 관찰자 패턴은 관찰자가 누군지 알고 알림의 호출자가 필요하다 -> 호출자가 관찰자를 알지 못하면 호출자는 관찰자를 그냥 패스한다

### 이벤트 스트리밍

- 예를 들어 모든 데이터가 각 드론에서 날아온다 (데이터들은 위치, 베터리 수준, 현재 속도, 바람, 날씨 등등)
    - 이런 데이터는 일정한 간격으로 전송될 거이다
- 위의 경우 발행자/구독자 또는 관찰자 모델로 처리하면 안된다
    - 이벤트에 중점을 두고 모든 단일 이벤트를 처리하기 위한 워크플로를 정의하는 프로그래밍 모델이 필요하다
    - 즉, 반응형 프로그램이이 필요하다
- 반응형 프로그래밍(Reactive Programming)은 스트리밍 형태의 이벤트를 다루는 아키텍처의 한 형태다
    - 스트림의 데이터 생산자를 정의하고 다수의 관찰자에 연결한다
    - 각 관찰자는 데이터의 변경이 있을 때마다 알림을 받으며 데이터 스트림에 대한 일련의 동작을 정의한다
- 이런 반응형 방식의 프로그램이 스타일은 ReactiveX에의해 유명해 졌고, RxPY가 이를 파이썬으로 구현하고 있다

```python
observable = rx.of(
    LocationData(x=3, y=12, z=40),
    BetteryLevel(percent=95),
    BetteryLevel(percent=94),
    WindData(Speed=15, direction=Direction.NORTH),
    ...

)
```

- 위 관찰 대상은 드론 데이터에 대한 서로 다른 타입의 이벤트 리스트에서 생성된 데이터 이다

```python
def handle_drone_data(value):
    ...


observable.subscribe(handle_drone_data)
```

- 위 코드는 각 이벤트에 대해 어떤 처리를 해야 할지 정의한다
    - 관찰 대상을 정했다면 관찰자는 위 처럼 기술할 수 있다
    - 발행/구독 메터니즘과 비슷하다

```python
get_average_weight = observable.pipe(
    rx.operators.filter(lambda data: isinstance(data, CurrentWeight)),
    rx.operators.map(lambda cw: cw.grams),
    rx.operators.average()
)
get_average_weight.subscribe(get_average_weight)
```

- 차이점은 pipe 연산자에 있다
    - PxPY는 파이프라인 필터를 생성, 전달, 계산하기 위한 pipe또는 체인 연산자를 지원한다
    - 이는 조합 가능성을 의미한다