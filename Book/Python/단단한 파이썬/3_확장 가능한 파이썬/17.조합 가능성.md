## 조합 가능성

- 조합 가능성을 염두해 두고 개발을 하면 코드를 소규모로 분산 시키며 재사용할 수 있게 만들 수 있다

### 조합 가능성

- 조합 가능성은 최소한의 상호의존성 및 비즈니스 로직이 들어간 소규모 컨포넌트의 구성에 초점을 맞춘다
- `조합 가능성의 목표는 향후의 개발자들이 자신의 솔루션을 만들 때 이 컴포넌트 중 하나를 쓸 수 있게 하는 것이다`
    - 컴포넌트가 작을수록 이해하기 쉽다
    - 의존성을 줄일수록 향후에 비용이 적다
- 컴포넌트들을 비즈니스 로직과의 분리를 유지함으로써 향후 문제가 될 여지를 남기지 않을 수 있다
- 조합 가능성이 좋은 컴포넌트가 많아질수록 새로운 코드와 쉽게 섞어서 만들 수 있다
- 조합 가능성에 초점을 맞추면 코드의 재사용성이나 확장성이 크게 좋아진다
- 조합 가능성을 높이려면 비즈니스 로직에 독립적으로 만들어야 한다 -> 정책과 메커니즘을 분리할 필요가 있달

### 정책과 메커니즘

- `정책은 비즈니스 로직이거나 당장 비즈니스 요구 사항을 해결해야 하는 책임이 있는 코드들이다`
- `메커니즘은 이런 정책들을 "어떻게"동작 시키는지를 제공한다`
- 메커니즘은 정책과 연결돼 있으면 재사용하기 어렵다
- ex) 파이썬 로깅 모듈
    - 정책 : 어디에 로그를 남겨야 할지
    - 메커니즘 : 로그의 포맷, 필터, 로그 레벨을 정하는 방법
    - 로깅 모듈은 무엇을 로깅하는지, 어떤 포맷의 로그를 남기는지 신경쓰지 않는다. 로깅 모듈은 "어떻게"로깅을 하는지만 제공한다
    - 정책은 이를 사용하는 애플리케이션 또는 로그로 남겨져야 할 "무엇"에 따른다

### 더 작은 스케일로 구성

#### 함수의 조합

- 함수형 프로그래밍의 창적음 순수 함수이기 때문에 다른 부수 효과가 없고, 조합하기 쉽다는 것이다
    - 순수 함수라면 함수 호출 그래프상에 없는 물리적 의존성은 존재하지 않는다
    - 복잡한 설정이나 전역 변수등을 가져올 필요도 없다
- 파이썬에는 functoll 이라고 하는 고차함수를 전담하는 모듈이 있다
    - 대부분 functool은 모든 함수의 조합과 마찬가지로 데코레이터의 형태로 존재한다

#### 데코레이터

- 데코레이터는 다른 함수를 취해 감싸는 역학을 한다
    - 함수가 수행되기 전에 먼저 수행되는 함수다
    - 데코레이터는 함수의 본문을 서로 알 필요 없이 함수의 조합을 만드는 방법을 제공한다
- 데코레이터를 통해 함수 자체를 수정하지 않고 동작을 수정할 수 있다

#### 알고리즘의 조합

- 작은 단위의 조합은 함수만 있는 것이 아니며 알고리즘도 가능하다
- 알고리즘 자체에 조합 가능성의 원칙을 적용할 수 있다
- 