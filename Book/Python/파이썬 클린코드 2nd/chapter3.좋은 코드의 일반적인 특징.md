# 계약에 의한 디자인

- 컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 클라이너트에게는 애플리케이션 프로그래밍 인터페이스(API)를 노출해야 한다
- API를 디자인할 때 예상되는 입출력과 부작용을 문서화해야 한다
    - 하지만 문서화가 런타임 시의 소프트웨어의 동작까지 강제할 수는 없다
    - 때문에 계약(contract)라는 개념이 생긴다
- 계약에 의한 디자인(Design by Contract)란
    - 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는지 예외를 발생시키는 것이다
    - 계약은 주로 사전조건과 사후조건을 명시하지만 때로는 불변식과 부작용을 기술한다
    - 사전조건(precondition)
        - 코드가 실행되기 전에 체크해야 하는 것들
    - 사후조건(postcondition)
        - 사전조건과 반대로 함수 반환값의 유효성 검사
    - 불변식(invariant)
        - 때로는 함수의 docstring에 불변식에 대해 문서화하는 것이 좋다. 불변식은 함수가 실행되는 동안에 일정하게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한 것이다
    - 부작용(side-effect)
        - 선택적으로 코드의 부작용을 docstring에 언급하기도 한다
    - 이상적으로는 위 4가지 모두 문서화해야 하지만 사전/사후 조건만 저수준(코드) 레벨에서 강제한다
- 계약에 의한 디자인을 하는 이유는
    - 오류를 쉽게 찾아낼 수 있다
    - 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지하기 위해서이다. 애플리케이션의 어떤 부분에서 실패했다는 에러를 발생시키는데서 그치는 것이 아니라 책임의 한계를 명확히 하는데 도움이 된다
    - 책임소재를 신속하게 파악할 수 있다 (사전 조건 -> 클라이언트, 사후조건 -> 제공자)

## 사전조건(Precondition)

- 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것
    - 타입체킹과는 다르다. 필요로 하는 값이 정확한지 확인 하는 것에 가깝다
    - 함수는 처리할 정보에 대한 적절한 유효성 검사를 해야한다
- 문제는 이 유효성 검사를 어디에서 할지이다
    - 호출이전에 유효성 검사를 해야할까. 함수가 자체적으로 검사를 해야할까?
    - 전자는 관대한(tolerant) 접근법이다
        - 함수 입장에서 여전히 어떤 값이라도 수용하고 있기 때문
    - 후자는 까다로운(demanding) 접급법
        - 일반적으로 가장 안전하고 견고한 방법이며 업게에서 가장 널리 쓰이는 방법이다
    - 어떤 방식을 택하든 중복 제거 원칙을 지켜야한다
        - 사전 조건 검증을 양쪽에서 하지 말고 오직 어느 한쪽에서만 해야한다
        - 즉, 검증 로직을 클라이언트에 두거나 함수 자체에 두어야 한다

## 사후조건(Postcondition)

- 함수가 적절하게 호울되었다면 사후조건은 특정 속성이 보존되어야 한다
- 클라이언트는 사후조건을 사용하여 필요로하는 모든 조건을 확인해 볼 수 있다
    - 메서드가 적절히 실행되었다면 계약이 이루어졌으므로 사후조건 검증에 모두 통과해야 하고 클라이언트는 반환 객체를 아무 문제 없이 사용할 수 있어야 한다

## 파이썬스러운 계약

```python
def add_positive_numbers(a, b):
    assert a > 0 and b > 0, "입력 값은 양수여야 합니다"  # 사전 조건
    result = a + b
    assert result > 0, "결과 값은 양수여야 합니다"  # 사후 조건
    return result
```

- PEP-316(Programing by Contract for Python)은 연기(deferred) 상태이다.
- 메서드, 함수, 클래스에 제어 메커니즘을 추가하고 검사에 실패할 경우 RuntimeError나 ValueError를 발생시키는 것이다
- 또한 코드는 격리된 상태를 유지하는 것이 좋다
    - `사전조건에 대한 검사와 사후조건에 대한 검사 그리고 핵심 기능에 대한 구현을 구분하는 것이`
    - 데코라이터를 사용하는 것도 좋은 방법이다

## 계약에 의한 디자인 (DbC) -결론

- `디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별하는데 있다`
    - 계약을 정의함으로써 런타임 오류가 발생했을 때 코드의 어떤 부분이 손상되었는지 그리고 무엇이 계약을 파손시켰는지 명확해진다
- 이 원칙을 따르게 되면 코드가 더욱 견고해진다
    - 각 컴포넌트는 자체적으로 제약 조건과 불변식을 관리하며 불변식이 유지되는 한 프로그램이 정상 동작하는 것으로 볼 수 있다
- 프로그램의 구조를 명확히 하는 목적으로도 사용할 수 있다
    - 즉흑적으로 유효성 검사를 해보거나 실패 시나리오를 검증하는 대신 계약을 사용하면 명시적으로 함수나 메서드가 정상적으로 동작하기 위해 필요한 것이 무엇인지, 그리고 정상적으로 동작한 후에 무엇을 반환하는지
      알 수 있다
- 하지만 추가 작업이 발생한다
    - 계약을 작성해야 하기 때문이다
    - 계약에 대한 단위 테스트를 추가해야할 수 있다
    - 하지만 장기적으로 품질이 보장된다 -> 해라
- `이 방법을 효과적으로 사용하기 위해서는 무엇을 기꺼이 검증할 것인지 신중하게 검토해봐야 한다`
    - 예를 들어 함수에 제공된 파라미터의 올바른 데이터 타입만 검사하는 제약을 정의하는 것은 별로 의미가 없다 