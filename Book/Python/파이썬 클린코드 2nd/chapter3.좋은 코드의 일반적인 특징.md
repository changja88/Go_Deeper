# 계약에 의한 디자인

- 컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 클라이너트에게는 애플리케이션 프로그래밍 인터페이스(API)를 노출해야 한다
- API를 디자인할 때 예상되는 입출력과 부작용을 문서화해야 한다
    - 하지만 문서화가 런타임 시의 소프트웨어의 동작까지 강제할 수는 없다
    - 때문에 계약(contract)라는 개념이 생긴다
- 계약에 의한 디자인(Design by Contract)란
    - 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는지 예외를 발생시키는 것이다
    - 계약은 주로 사전조건과 사후조건을 명시하지만 때로는 불변식과 부작용을 기술한다
    - 사전조건(precondition)
        - 코드가 실행되기 전에 체크해야 하는 것들
    - 사후조건(postcondition)
        - 사전조건과 반대로 함수 반환값의 유효성 검사
    - 불변식(invariant)
        - 때로는 함수의 docstring에 불변식에 대해 문서화하는 것이 좋다. 불변식은 함수가 실행되는 동안에 일정하게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한 것이다
    - 부작용(side-effect)
        - 선택적으로 코드의 부작용을 docstring에 언급하기도 한다
    - 이상적으로는 위 4가지 모두 문서화해야 하지만 사전/사후 조건만 저수준(코드) 레벨에서 강제한다
- 계약에 의한 디자인을 하는 이유는
    - 오류를 쉽게 찾아낼 수 있다
    - 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지하기 위해서이다. 애플리케이션의 어떤 부분에서 실패했다는 에러를 발생시키는데서 그치는 것이 아니라 책임의 한계를 명확히 하는데 도움이 된다
    - 책임소재를 신속하게 파악할 수 있다 (사전 조건 -> 클라이언트, 사후조건 -> 제공자)

## 사전조건(Precondition)

- 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것
    - 타입체킹과는 다르다. 필요로 하는 값이 정확한지 확인 하는 것에 가깝다
    - 함수는 처리할 정보에 대한 적절한 유효성 검사를 해야한다
- 문제는 이 유효성 검사를 어디에서 할지이다
    - 호출이전에 유효성 검사를 해야할까. 함수가 자체적으로 검사를 해야할까?
    - 전자는 관대한(tolerant) 접근법이다
        - 함수 입장에서 여전히 어떤 값이라도 수용하고 있기 때문
    - 후자는 까다로운(demanding) 접급법
        - 일반적으로 가장 안전하고 견고한 방법이며 업게에서 가장 널리 쓰이는 방법이다
    - 어떤 방식을 택하든 중복 제거 원칙을 지켜야한다
        - 사전 조건 검증을 양쪽에서 하지 말고 오직 어느 한쪽에서만 해야한다
        - 즉, 검증 로직을 클라이언트에 두거나 함수 자체에 두어야 한다

## 사후조건(Postcondition)

- 함수가 적절하게 호울되었다면 사후조건은 특정 속성이 보존되어야 한다
- 클라이언트는 사후조건을 사용하여 필요로하는 모든 조건을 확인해 볼 수 있다
    - 메서드가 적절히 실행되었다면 계약이 이루어졌으므로 사후조건 검증에 모두 통과해야 하고 클라이언트는 반환 객체를 아무 문제 없이 사용할 수 있어야 한다

## 파이썬스러운 계약

```python
def add_positive_numbers(a, b):
    assert a > 0 and b > 0, "입력 값은 양수여야 합니다"  # 사전 조건
    result = a + b
    assert result > 0, "결과 값은 양수여야 합니다"  # 사후 조건
    return result
```

- PEP-316(Programing by Contract for Python)은 연기(deferred) 상태이다.
- 메서드, 함수, 클래스에 제어 메커니즘을 추가하고 검사에 실패할 경우 RuntimeError나 ValueError를 발생시키는 것이다
- 또한 코드는 격리된 상태를 유지하는 것이 좋다
    - `사전조건에 대한 검사와 사후조건에 대한 검사 그리고 핵심 기능에 대한 구현을 구분하는 것이`
    - 데코라이터를 사용하는 것도 좋은 방법이다

## 계약에 의한 디자인 (DbC) -결론

- `디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별하는데 있다`
    - 계약을 정의함으로써 런타임 오류가 발생했을 때 코드의 어떤 부분이 손상되었는지 그리고 무엇이 계약을 파손시켰는지 명확해진다
- 이 원칙을 따르게 되면 코드가 더욱 견고해진다
    - 각 컴포넌트는 자체적으로 제약 조건과 불변식을 관리하며 불변식이 유지되는 한 프로그램이 정상 동작하는 것으로 볼 수 있다
- 프로그램의 구조를 명확히 하는 목적으로도 사용할 수 있다
    - 즉흑적으로 유효성 검사를 해보거나 실패 시나리오를 검증하는 대신 계약을 사용하면 명시적으로 함수나 메서드가 정상적으로 동작하기 위해 필요한 것이 무엇인지, 그리고 정상적으로 동작한 후에 무엇을 반환하는지
      알 수 있다
- 하지만 추가 작업이 발생한다
    - 계약을 작성해야 하기 때문이다
    - 계약에 대한 단위 테스트를 추가해야할 수 있다
    - 하지만 장기적으로 품질이 보장된다 -> 해라
- `이 방법을 효과적으로 사용하기 위해서는 무엇을 기꺼이 검증할 것인지 신중하게 검토해봐야 한다`
    - 예를 들어 함수에 제공된 파라미터의 올바른 데이터 타입만 검사하는 제약을 정의하는 것은 별로 의미가 없다

# 방어적(defensive)프로그래밍

- Dbc와는 다소 다른 접근 방식을 따른다
    - `계약에서 예외를 발생시키고 실패하게 되는 모든 조건을 기술하는 대신, 코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호할 수 있게 한다`
- 여러 측면을 고려한 기술이며 다른 디자인 원칙과 결합할 경우 특히 유용하다
- `주요 주제는 예상할 수 있는 시나리오의 오류를 처리하는 방법과 발생하지 않아야하는 오류를 처리하는 방법에 대한 것이다`
    - 전자는 에러 핸들링 프로시저
    - 후자는 어설션

## 에러 핸들링

- 에러 핸들링의 주요 목적은 예상되는 에러에 대해서 실행을 계속할 수 있을지 아니면 프로그램을 중단할지를 결정하는 것이다
- 일반적인 예외 처리 방법
    - 값 대체(value substitution)
    - 에러 로깅
    - 예외 처리

### 값 대체

- 잘못된 결과를 만들어 낼 수 있는 경우, 결과 값을 안전한 다른 값으로 대체할 수 있다 -> 값 대체
    - 잘못된 결과를 정합성을 깨지 않는 다른 값으로 대체
    - 기본 값 또는 잘 알려진 상수, 초기 값으로 바꾼다
    - 예를 들어 결과값을 누적시키는 경우 0을 반환하면 영향을 미치지 않게 된다
- 값 대체가 항상 가능하지는 않다
    - `정확성과 견곻함의 트레이드오프`

### 예외 처리

- 어떤 경우에는 잘못된 데이터를 사용하여 계속 실행하는 것보다 차라리 실행을 멈추는 것이 더 좋을 수 있다
    - DbC에서 사전 조건 검증에 실패한 것과 같은 경우
- `예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지하는 것 -> 예외 메커니즘`
    - 정상적인 시나리오나 비즈니스 로직을 예외 처리하려고 하면 프로그램의 흐름을 읽기가 어려워 진다 (go-to문 처럼 사용하는 것과 같다)
    - 예외가 호출 스택의 여러 레벨에서 사용될 경우 올바른 위치에서 추상화를 하지 못하게 되고 로직을 캡슐화하지도 못하게 된다
- 프로그램이 꼭 처리해야 하는 정말 예외적인 비지니스 로직을 except블록과 혼합하여 사용하면 더욱 악화될 수 있다
    - 이렇게 되면 유지보수가 필요한 핵심 놀리와 오류를 구별하는 것이 더 어려워 진다
- 예외는 대게 호출자에게 잘못을 알려주는 것이다
    - 예외는 캡슐화를 약화시키기 때문에 신중하게 사용해야 한다
    - 함수에 예외가 많을 수록 호출자는 함수에 대해 더 많은 것을 알아야만 한다
    - 함수가 너무 많은 예외를 발생시킨다는 것은 문맥에서 자유롭지 않다는 것을 의미하며 이는 함수가 응집력이 약하고 너무 많은 책임을 가지고 있다는 것을 의미할 수도 있다

#### 올바른 수준의 추상화 단계에서 예외 처리

- 예외는 오직 한가지 일을 하는 함수의 한 부분이어야 한다. 함수가 처리하는(또는 발생시키는)예외는 함수가 캡슐화하고 있는 로직에 대한 것이어야 한다

```python
class DataTransport:
    """다양한 수준의 예외를 처리하는 예"""
    _RETRY_BACKOFF: int = 5
    _RETRY_TIMES: int = 3

    def __init__(self, connector: Connector) -> None:
        self._connector = connector
        self.connection = None

    def deliver_event(self, event: Event):
        try:
            self.connect()
            data = event.decode()
            self.send(data)
        except ConnectionError as e:
            logger.info("커넥션 오류 발견")
        except ValueError as e:
            logger.error("이벤트에 잘못된 데이터 포함")

    def connect(self):
        for _in range(self._RETRY_TIMES):
            try:
                self.connection = self._connector.connect()
            except ConnectionError as e:
                logger.info("새로운 커넥션 시도")
            else:
                return self.connection
        raise ConnectionError("연결실패 재시도 횟수")

    def send(self, data: bytes):
        return self.connection.send(data)

```

- 위 코드는 서로 다른 수준의 추상화를 혼합하는 예제이다
    - ValueError와 ConnectionError는 별로 관계가 없다
    - 이렇게 매우 다른 유형의 오류를 살펴봄으로써 책임을 어떻게 분산해야 하는지에 대한 아이디어를 얻을 수 있다
    - ConnectionError는는 connect 메서드 내에서 처리되어야한다
    - ValueError는 event의 decode 메서드에 속한 에러이다

#### 엔드 유저에서 Traceback 노출 금지

- 보안을 위한 고려 사항이다
- 악의적인 사용자에게도 유용한 정보여서 노출하면 위험하다

#### 비어있는 except 블록 지양

- 파이썬의 안티패턴중에서도 가장 악마 같은 패턴이다
    - 너무 방어적이어서 아무것도 하지 않은 채로 조용히 지나쳐버리는 비어있는 except 블록은 피해라

#### 원본 예외 포함

- 오류 처리 과정에서 기존 오류와 다른 새로운 오류를 발생시키고 오류 메시지를 변경할 수도이 있다. 이런 경우 원래 어떤 오류가 있었는지에 대한 정보를 포함하는 것이 좋다

```python
class InternalDataError(Exception):
    """업무 도메인 데이터의 예외"""


def process(data_dictionary, record_id):
    try:
        return data_dictionary[record_id]
    except KeyError as e:
        raise InternalDataError("데이터가 존재하지 않음") from e
```

- 위 코드처럼 PEP-3134에서 소개된 raise e from 구문을 사용하면 여러 예외를 연결할 수 있다
    - 이렇게 하면 원본 오류의 traceback 정보가 새로운 exception에 포함되고, 원본 오류는 새로운 오류의 원인으로 분류되어 __cause__속성에 할당된다

### 파이썬에서 어설션(assertion)사용하기

- `어설션은 절대로 일어나지 않아야 한느 상황에 사용되므로 assert 문에 사용된 표현식은 불가능한 조건을 의미한다`
    - 잘못된 시나리오에 도달할 경우 프로그램이 더 큰 피해를 입지 않도록 하기 위한 장치
    - 즉, 극복할 수 없는 예외 상황이며, 비지니스 로직과 섞거나 소프트웨어의 제어 흐름 메커니즘으로 사용해서는 안된다

```python
try:
    assert condition.holds(), "조건에 맞지 않음"
except AssertionError:
    alternative_procedure()
```

- 위 코드처럼 assert구문에 비즈니스 로직을 넣으면 안된다
    - 또한 assertion catch가 함수면 안된다
    - 그 함수가 또 AssertionError를 발생시킬지도 모른다
- 일반적으로 AssertionError는 더 이상 처리가 불가능한 상황을 의미하므로 catch이후에 프로그램을 계속 실행하면 안된다
    - 하지만 우아하게(gracefull) 종료하고 싶은 경우도 있따
    - AssertionError를 catch하여 일반적인 에러 메시지를 보여주고 상세 에러를 내부 시스템에 기록하고 종료시킬 수도 있다
    - 시스템에 기록하고 나중에 개선을 위한 목적으로 사용해야한다
- 예러 처리와의 관계
    - 일반적으로 예외는 예상하지 못한 상황을 처리하기 위한 것이도 어설션은 정확성을 보장하기 위해 스스로 체크하기 위한 것이다
    - 이러한 이유로 예외를 발생시키는 것이 어설션 구문을 사용하는 것보다 훨씬 일반적이다
    - 어설션 구문은 항상 변하지 않는 고정된 조건에 대해서 검증할 때 사용한다

# 관심사의 분리

- 프로그램의 각 부분은 기능의 일부분에 대해서만 책임을 지며 나머지 부분에 대해서는 알 필요가 없다

## 응집력(cohesion)과 결합력(coupling)

- `응집력이란 작고 잘 정의된 목적을 가지고 있고 기능하며 작아야 한다는 것을 의미한다`
- 객체의 응집력이 높을스록 더 유리하고 재사용성이 높아지므로 더 좋은 디자인이다
- '결합력이란 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타낸다'
    - 이 종송석은 제한을 의미한다. 객체 또는 메서드의 두 부분이 서로 너무 의존적이라면 다음과 같은 바람직 하지 않은 결과를 가져온다
    - 낮은 재사용성
    - 파급효과
    - 낮은 수준의 추상화 : 두 함수가 너무 가깝게 과련되어 있으면 서로 다른 추상화 레벨에서 문제를 해결하기 어렵기 때문에 관심사가 분리되어 있다고 보기 어렵다

# 개발 지침 약어

## DRY/OAOO

- DRY(Do not Repeat Yourself)/ OAOO(Once and Only Once)
    - 코드에 있는 지식은 단 한번, 단 한 곳에 정의도어야 한다
    - 코드를 변경하려고 할 때 수정이 필요한 곳은 단 한군데만 있어야 한다

```python
def process_students_list(students):
    # 중각 생략 ...
    students_ranking = sorted(
        students, key=lambda s: s.passed * 11 - s.failed * 5 - s.years * 2
    )
    # 학생별 순위 출력
    for student in students_ranking:
        print(
            "이름: {0}, 점수: {1}".format(student.name, (student.passed * 11 - student.failed * 5 - student.years * 2)),
        )
```

- 위 코드에는 중복이 있다 sorted 함수의 key로 사용되는 lambda가 특별한 도메인 지식을 나타내지만 아무런 정의가 없는 것이 문제다
  코드에서 의미를 부옇하지 않았기 때문에 순위를 출력할 때 중복이 발생한다
- 도메인 지식을 나타내는 것에는 의미를 부여하여 중복을 방지해야한다
    - 클래스나, 함수나, 뭐로든 분맇해야한다

## YAGNI

- YAGNI(You Ain't Gonna Need it)
    - 과잉 엔지니어링을 하지 않기 위해 계속 염두해 두어야 하는 원칙이다
- 유지보수가 가능한 소프트웨어를 만드는 것은 미래의 요구 사항을 예측하는 것이 아니달
    - `오직 현재 요구사항을 잘 해결하기 위한 소프트웨어를 작성하고 가능한 나중에 수정하기 쉽도록 작성하는 것이다`
- 이것이 바로 객체 지향에서 동작하는 상향식 (bottom-up)설계 원리이다

## KIS

- KIS(Keep It Simple)
- 선택한 솔루션이 문제에 적합한 최소한의 솔루션인지 자문해야 한다
    - 높은 수준에서 컴포넌트를 생각해보자 정말 모든 기능이 필요할까? `지금 당장` 필요할까?
- 코드를 단순하게 유지하기 위해 메타 클래스와 같은 파이썬의 고급 기능을 사용하는 것은 피하는 것이 좋다
    - 이런 기능이 필요한 경우는 매우 한정적이고, 사용하면 읽기 어려워지고 유지보수가 어려워 진다

## EAFP/LBYL

```python
try:
    with open(filename) as f:
        ...
except FileNotFoundError as e:
    ...
```

- EAFP(Easier to Ask Forgiveness than Permission) 허락보다는 용서를 구하는 것이 쉽다
    - 일단 코드를 실행하고 실제 동작하지 않을 경우에 대응한다는 뜻이다
    - 일반적으로 이 방식으로 구현하면 일단 코드를 실행하고 발생한 예외를 catch하고 except블록에서 바로 잡는 코드를 실행하게 된다
    - 대부분의 경우 이 방식이 더 의미를 명확하게 드러낸다 -> 가독성이 높다

```python
if os.path.exists(filename):
    with open(filename) as f:
        ...
```

- LBYL(Look Before You Leep) 도약하기 전에 미리 살펴라
    - 위에 반대되는 방식이다
    - 위 코드 처럼 도약하기 전에 무엇을 사용하려고 하는지 확인한다

# 상속

- 상속은 강력한 개념이지만 위험도 있다
    - 부모 클래스를 확장하여 새로운 클래스를 만들 때마다 부모와 강력하게 결합된 새로운 클래스가 생긴다는 점이다
- 재사용성, 단지 부모 클래스에 있는 메서드를 공짜로 얻을 수 있기 때문에 상속을 하는 것은 좋지 않다

## 상속이 좋은 선택인 경우

- 올바른 상속인지 확인 하는 가장 쉬운 방법은 자식 클래스가 부모 클래스의 모든 기능을 사용하는지 확인하는 것이다
    - 상위 클래스는 잘 정의된 인터페이스 대신 막연한 정의와 너무 많은 책임을 가졌다
    - 하위 클래스는 확장하려고 하는 상위 클래스의 적절한 세분화가 아니다
- 상속의 올바른 케이스
    - public 메서드의 속성을 인터페이스로 잘 정의한 클래스가 있다
    - 그리고 이 클래스와 같은 기능을 하지만 ㅇ리부 기능을 수정하거나 새로운 것을 수가하고 싶어서 상속을 한 경우이다
- 인터페이스 정의는 상속의 또 다른 좋은 예이다
    - 어떤 객체에 인터페이스 방식을 강제하고자 할 때 세부 구현을 하지 않은 기본 추상 클래스를 만들고, 실제 이 클래스를 상속하는 하위 클래스에서 적절한 구현을 하도록 하는 것이다

## 상속 안티패턴

- 자식 클래스의 public 메서드는 부모 클래스에서 정의한 것과 일관성을 가져야 한다

## 파이썬의 다중상속

- 파이썬은 다중상속을 지원하지만 부적절하게 사용된 다중상속은 디자인 문제를 유발하며 더 큰 문제를 초해라 수도 있다
- 다중상속 보다는 9장에 나올 어답터나 믹스인에 활용할 수 있다

### 메서드 결정 순서(MRO)

- 다른 프로그래밍 언어에 존재하는 소위 다이아몬드 문제와 같은 제약조건이 생기기 때문에 다중 상속을 싫어 한다
- 파이썬은 C3 linearization 또는 MRO 라는 알고리즘을 사용하여 이무제를 해결한다

### 믹스인(mixin)

- 믹스인은 코드를 재사용하기 위해 일반적인 행동을 캡슐화해 놓은 부모 클래스이다
- 일반적으로 믹스인 클래스 자체만으로는 유용하지 않고, 믹스인 클래스만 확장하는 경우에도 큰 의미가 없다
    - 왜냐하면 믹스인 클래스는 대부분 다른 클래스의 메서드나 속성과 결합하여 사용되기 때문이다
    - 보통은 다른 클래스와 믹스인 클래스를 다중 상속하고, 믹스인 클래스의 메서드와 속성을 다른 클래스에서 활용한다

```python
class BaseTokenizer:
    def __init__(self, str_token):
        self.str_token = str_token

    def __iter__(self):
        yield from self.str_token.split('-')
```

- 위 클래스를 변경하지 않고 값을 대문자로 변환해보자

```python
class UpperIterableMixin:
    def __iter__(self):
        return map(str.upper, super().__iter__())


class Tokenizer(UpperIterableMixin, BaseTokenizer):
    pass
```

- 새로운 Tokenizer 클래스는 매우 간단하다
    - 믹스인을 이용하기 때문에 새로운 코드가 필요 없다
    - 이렇한 유형의 혼합은 일종의 데코레이터 역할을 한다

# 함수와 메서드의 인자

## 파이썬의 함수 인자 동작 방식

### 인자는 함수에 어떻게 복사되는가

- 파이썬은 항상 모든 인자를 값에 의해 전달(pass by value)해야 한다
    - 함수에 값을 전달하면 함수의 서명에 있는 변수에 할당하고 나중에 사용된다
    - 만약 변경 가능한 객체를 전달했는데 함수안에서 값을 변경했다면 실제로 파리멑의 내용이 변경되는 부작용이 발생한다(아래코드)

```python
def function(arg):
    arg += " in function"
    print(arg)


imutable = "hello"
function(imutable)  # -> hello in function
mutable = list('hello')
print(imutable)  # -> hello
function(mutable)  # ['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']
print(mutable)
```

- string 객체는 불변형 이므로 arg += <expression> 문장은 사실 새로운 객체를 만들어서 arg에 할당한다
- 반면 변형 객체 mutable은 arg += <expression>은 실제로 list의 extend()를 호출하는 것과 같다
    - 이 연산자는 원래 리스트 객체에 대한 참조를 통해 값을 수정하므로 함수 외부에서도 값을 수정할 수 있다

```python
a = list(range(5))
b = a
b.append(99)
print(b)  # [0, 1, 2, 3, 4, 99]
print(a)  # [0, 1, 2, 3, 4, 99]
```

- 마찬가지로 b에서 추가한 99 값이 a 리스트에도 같이 반영된다
- 위와 같은 방식으로 변경하는 것이 꼭 필요한 상황이 아니라면 가급적 다른 대안을 찾아야 한다

### 가변인자

- 가변인자를 사용하려면 해당 인자를 패킹ㅇ할 변수의 이름 앞에 * 를 사용한다

```python
def f(first, second, thrid):
    pass


i = [1, 2, 3]
f(i)
```

- 부분적이 언패킹도 가능하다

```python
def show(e, rest):
    print(f'요소 {e} 나머지{rest}')


first, *rest = [1, 2, 3, 4]
show(first, rest)

*rest, last = range(6)
show(last, rest)

first, *middle, last = range(6)
show(first, last)

first, last, *empty = 1, 2
```

- 변수 언패킹의 가장 좋은 사용 예는 반복이다

```python
USERS = [
    (i, f'first_name_{i}', f'last_name{i}')
    for i in range(1_000)
]


@dataclass
class User:
    user_id: int
    first_name: str
    last_name: str


def bad_users_from_rows(dbrows) -> list:
    return [User[row[0], row[2], row[2]] for row in dbrows]


def users_from_rows(dbrows) -> list:
    return [
        User(user_id, first_name, last_name)
        for (user_id, first_name, last_name) in dbrows
    ]

```

- 두번째(users_from_rows) 버젼이 훨씬 읽기 쉽다
- 비슷한 표기법으로 이중별표 **를 키워드 인자에 사용할 수 있다
    - 사전에 이중 별표를 사용하여 함수에 전달하면 사전의 키를 파라미터 이름으로 사용하고, 사전의 값을 파라미터 값으로 사용한다
    - 반대로 이중 별표로 시작하는 파라미터를 함수에 사용하면 반대 현상이 벌어진다
    - 남발하면 가독성이 떨어진다
    -

```python
def function(**kwargs):
    print(kwargs)


function(key='value')
```

### 위치 전용(positional-only)인자

- 하나의 인수를 키워드로 전달했다면 이후의 모든 인자도 키워드로 전달해야 한다
- PEP-570부터 반드시 위치 인자만 사용해야 하는 새로운 구문이 추가되었따(아래코드)

```python
def my_function(x, y, /):
    pass


my_function(1, 2)
my_function(x=1, y=2)  # 에러발생
```

- 키워드 인자를 사용하는 것이 큰 의미가 없는 경우 사용할수 있다

### 키워드 전용 인자(keyword-only)인자

- 일부 인수를 키워드 전용으로 만들 수도 있다
- 위치 전용 인자와 달리 키워드 전용 인자는 *를 사용하여 그 시작을 알린다
  -
        * 뒤에 오는 것들은 키둬으 전용 인자가 된다

```python
def my_function(x, y, *args, kw1, kw2=0):
    pass


my_function(1, 2, kw1=1, kw2=2)
my_function(1, 2, kw1=1)
```

- 처음 두 개 이후에 더 이상의 위치 읹자를 원하지 않으면 *args 대신 *를 넣으면 된다
- 이 기능은 하위 호환을 유지하면서 기존 함수를 확장할 수 있기 때문에 유용하다
- 정확한 문맥을 제공해야 하는 경우 키워드 전용 인자를 사용하는 것이 좋다

## 함수 인자의 개수

- 이 섹션에서는 너무 많은 인자를 사용하는 함수나 메서드가 왜 나쁜 디자인의 징후인지, 그런다음 해결방법을 알아본다
- 첫번째 대안은 일반적인 소프트웨어 디자인 원칙인 구체와(reification)을 하는 것이다
    - 전달하는 모든 인자를 포함하는 새로운 객체를 만드는 것이다
    - 인자가 많다는 것은 아마도 추상화를 빼먹었기 때문일 것이다
    - 여러 인자를 새로운 객체로 압축하는 것은 파이썬만의 고유한 솔루션이 아니라 모든 프로그래밍 언어에서 적용할수 있는 방법이다
- 다른 방법은 파이썬의 트겅 기능을 사용하는 것이다
    - 가변 인자나 키워드 인자를 사용하여 동적 서명을 가진 함수를 만든다
    - 파이썬 스러운 방법일지 모르나 남용하지 않도록 주의해야 한다
    - 동적이어서 유지보수가 어렵기 떄문이다

### 함수 인자와 겷합력

- 함수 서명의 인수가 많을수록 호출자 함수와 밀접하게 결합될 가능성이 커진다
    - f1이 f2함수를 호출 하는 경우
    - f2가 많은 파라미터를 사용한다고 하면 f1이 이 많은 파라미터를 모두 수집하는 것이 점점 어려워질 수 있다
    - 정보가 다 있는 경우에도,
    - f2는 아마도 추상화가 부족했을 것이다
        - f1은 f2가 필요로 하는 모든 것을 알고 있기 때문에 f2 내부적으로 무엇을 하는지 알아낼 수 있으며 거의 자체적으로 수행할 수 있다
        - 결국 f2는 그렇게 많은 것을 추상화하지 않은 것이다
    - f2는 다른 환경에서 사용하기가 어려워 f1에서만 유용하기 때문에 재사용이 떨어진다

### 많은 인자를 가진 함수의 서명 간소화

```python
track_reqeusst(reqeust.headers, reqeust.ip_addr, reqeusst.request_id)
```

- 위 코드 같은 경우 차라리 그냥 request를 전달하는 것이 좋다
    - 하지만 객체를 전달할 때는 부작용에 주의해야 한다
    - `함수는 전달 받은 객체를 변경해서는 안 된다`
- 최후의 수전은 *args, **kwargs를 사용하면 된다
    - 하지만 더 이해하기 어려운 상황을 만들 수도 있다
    - 이런 경우 인터페이스에 대해서 적절히 문서화를 하고 인터페이스를 올바르게 구현했는지 확실히 해야 한다 