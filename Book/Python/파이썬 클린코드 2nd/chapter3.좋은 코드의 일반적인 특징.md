# 계약에 의한 디자인

- 컴포넌트는 기능을 숨겨 캡슐화하고 함수를 사용할 클라이너트에게는 애플리케이션 프로그래밍 인터페이스(API)를 노출해야 한다
- API를 디자인할 때 예상되는 입출력과 부작용을 문서화해야 한다
    - 하지만 문서화가 런타임 시의 소프트웨어의 동작까지 강제할 수는 없다
    - 때문에 계약(contract)라는 개념이 생긴다
- 계약에 의한 디자인(Design by Contract)란
    - 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는지 예외를 발생시키는 것이다
    - 계약은 주로 사전조건과 사후조건을 명시하지만 때로는 불변식과 부작용을 기술한다
    - 사전조건(precondition)
        - 코드가 실행되기 전에 체크해야 하는 것들
    - 사후조건(postcondition)
        - 사전조건과 반대로 함수 반환값의 유효성 검사
    - 불변식(invariant)
        - 때로는 함수의 docstring에 불변식에 대해 문서화하는 것이 좋다. 불변식은 함수가 실행되는 동안에 일정하게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한 것이다
    - 부작용(side-effect)
        - 선택적으로 코드의 부작용을 docstring에 언급하기도 한다
    - 이상적으로는 위 4가지 모두 문서화해야 하지만 사전/사후 조건만 저수준(코드) 레벨에서 강제한다
- 계약에 의한 디자인을 하는 이유는
    - 오류를 쉽게 찾아낼 수 있다
    - 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지하기 위해서이다. 애플리케이션의 어떤 부분에서 실패했다는 에러를 발생시키는데서 그치는 것이 아니라 책임의 한계를 명확히 하는데 도움이 된다
    - 책임소재를 신속하게 파악할 수 있다 (사전 조건 -> 클라이언트, 사후조건 -> 제공자)

## 사전조건(Precondition)

- 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것
    - 타입체킹과는 다르다. 필요로 하는 값이 정확한지 확인 하는 것에 가깝다
    - 함수는 처리할 정보에 대한 적절한 유효성 검사를 해야한다
- 문제는 이 유효성 검사를 어디에서 할지이다
    - 호출이전에 유효성 검사를 해야할까. 함수가 자체적으로 검사를 해야할까?
    - 전자는 관대한(tolerant) 접근법이다
        - 함수 입장에서 여전히 어떤 값이라도 수용하고 있기 때문
    - 후자는 까다로운(demanding) 접급법
        - 일반적으로 가장 안전하고 견고한 방법이며 업게에서 가장 널리 쓰이는 방법이다
    - 어떤 방식을 택하든 중복 제거 원칙을 지켜야한다
        - 사전 조건 검증을 양쪽에서 하지 말고 오직 어느 한쪽에서만 해야한다
        - 즉, 검증 로직을 클라이언트에 두거나 함수 자체에 두어야 한다

## 사후조건(Postcondition)

- 함수가 적절하게 호울되었다면 사후조건은 특정 속성이 보존되어야 한다
- 클라이언트는 사후조건을 사용하여 필요로하는 모든 조건을 확인해 볼 수 있다
    - 메서드가 적절히 실행되었다면 계약이 이루어졌으므로 사후조건 검증에 모두 통과해야 하고 클라이언트는 반환 객체를 아무 문제 없이 사용할 수 있어야 한다

## 파이썬스러운 계약

```python
def add_positive_numbers(a, b):
    assert a > 0 and b > 0, "입력 값은 양수여야 합니다"  # 사전 조건
    result = a + b
    assert result > 0, "결과 값은 양수여야 합니다"  # 사후 조건
    return result
```

- PEP-316(Programing by Contract for Python)은 연기(deferred) 상태이다.
- 메서드, 함수, 클래스에 제어 메커니즘을 추가하고 검사에 실패할 경우 RuntimeError나 ValueError를 발생시키는 것이다
- 또한 코드는 격리된 상태를 유지하는 것이 좋다
    - `사전조건에 대한 검사와 사후조건에 대한 검사 그리고 핵심 기능에 대한 구현을 구분하는 것이`
    - 데코라이터를 사용하는 것도 좋은 방법이다

## 계약에 의한 디자인 (DbC) -결론

- `디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별하는데 있다`
    - 계약을 정의함으로써 런타임 오류가 발생했을 때 코드의 어떤 부분이 손상되었는지 그리고 무엇이 계약을 파손시켰는지 명확해진다
- 이 원칙을 따르게 되면 코드가 더욱 견고해진다
    - 각 컴포넌트는 자체적으로 제약 조건과 불변식을 관리하며 불변식이 유지되는 한 프로그램이 정상 동작하는 것으로 볼 수 있다
- 프로그램의 구조를 명확히 하는 목적으로도 사용할 수 있다
    - 즉흑적으로 유효성 검사를 해보거나 실패 시나리오를 검증하는 대신 계약을 사용하면 명시적으로 함수나 메서드가 정상적으로 동작하기 위해 필요한 것이 무엇인지, 그리고 정상적으로 동작한 후에 무엇을 반환하는지
      알 수 있다
- 하지만 추가 작업이 발생한다
    - 계약을 작성해야 하기 때문이다
    - 계약에 대한 단위 테스트를 추가해야할 수 있다
    - 하지만 장기적으로 품질이 보장된다 -> 해라
- `이 방법을 효과적으로 사용하기 위해서는 무엇을 기꺼이 검증할 것인지 신중하게 검토해봐야 한다`
    - 예를 들어 함수에 제공된 파라미터의 올바른 데이터 타입만 검사하는 제약을 정의하는 것은 별로 의미가 없다

# 방어적(defensive)프로그래밍

- Dbc와는 다소 다른 접근 방식을 따른다
    - `계약에서 예외를 발생시키고 실패하게 되는 모든 조건을 기술하는 대신, 코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호할 수 있게 한다`
- 여러 측면을 고려한 기술이며 다른 디자인 원칙과 결합할 경우 특히 유용하다
- `주요 주제는 예상할 수 있는 시나리오의 오류를 처리하는 방법과 발생하지 않아야하는 오류를 처리하는 방법에 대한 것이다`
    - 전자는 에러 핸들링 프로시저
    - 후자는 어설션

## 에러 핸들링

- 에러 핸들링의 주요 목적은 예상되는 에러에 대해서 실행을 계속할 수 있을지 아니면 프로그램을 중단할지를 결정하는 것이다
- 일반적인 예외 처리 방법
    - 값 대체(value substitution)
    - 에러 로깅
    - 예외 처리

### 값 대체

- 잘못된 결과를 만들어 낼 수 있는 경우, 결과 값을 안전한 다른 값으로 대체할 수 있다 -> 값 대체
    - 잘못된 결과를 정합성을 깨지 않는 다른 값으로 대체
    - 기본 값 또는 잘 알려진 상수, 초기 값으로 바꾼다
    - 예를 들어 결과값을 누적시키는 경우 0을 반환하면 영향을 미치지 않게 된다
- 값 대체가 항상 가능하지는 않다
    - `정확성과 견곻함의 트레이드오프`

### 예외 처리

- 어떤 경우에는 잘못된 데이터를 사용하여 계속 실행하는 것보다 차라리 실행을 멈추는 것이 더 좋을 수 있다
    - DbC에서 사전 조건 검증에 실패한 것과 같은 경우
- `예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지하는 것 -> 예외 메커니즘`
    - 정상적인 시나리오나 비즈니스 로직을 예외 처리하려고 하면 프로그램의 흐름을 읽기가 어려워 진다 (go-to문 처럼 사용하는 것과 같다)
    - 예외가 호출 스택의 여러 레벨에서 사용될 경우 올바른 위치에서 추상화를 하지 못하게 되고 로직을 캡슐화하지도 못하게 된다
- 프로그램이 꼭 처리해야 하는 정말 예외적인 비지니스 로직을 except블록과 혼합하여 사용하면 더욱 악화될 수 있다
    - 이렇게 되면 유지보수가 필요한 핵심 놀리와 오류를 구별하는 것이 더 어려워 진다
- 예외는 대게 호출자에게 잘못을 알려주는 것이다
    - 예외는 캡슐화를 약화시키기 때문에 신중하게 사용해야 한다
    - 함수에 예외가 많을 수록 호출자는 함수에 대해 더 많은 것을 알아야만 한다
    - 함수가 너무 많은 예외를 발생시킨다는 것은 문맥에서 자유롭지 않다는 것을 의미하며 이는 함수가 응집력이 약하고 너무 많은 책임을 가지고 있다는 것을 의미할 수도 있다

#### 올바른 수준의 추상화 단계에서 예외 처리

- 예외는 오직 한가지 일을 하는 함수의 한 부분이어야 한다. 함수가 처리하는(또는 발생시키는)예외는 함수가 캡슐화하고 있는 로직에 대한 것이어야 한다

```python
class DataTransport:
    """다양한 수준의 예외를 처리하는 예"""
    _RETRY_BACKOFF: int = 5
    _RETRY_TIMES: int = 3

    def __init__(self, connector: Connector) -> None:
        self._connector = connector
        self.connection = None

    def deliver_event(self, event: Event):
        try:
            self.connect()
            data = event.decode()
            self.send(data)
        except ConnectionError as e:
            logger.info("커넥션 오류 발견")
        except ValueError as e:
            logger.error("이벤트에 잘못된 데이터 포함")

    def connect(self):
        for _in range(self._RETRY_TIMES):
            try:
                self.connection = self._connector.connect()
            except ConnectionError as e:
                logger.info("새로운 커넥션 시도")
            else:
                return self.connection
        raise ConnectionError("연결실패 재시도 횟수")

    def send(self, data: bytes):
        return self.connection.send(data)

```

- 위 코드는 서로 다른 수준의 추상화를 혼합하는 예제이다
    - ValueError와 ConnectionError는 별로 관계가 없다
    - 이렇게 매우 다른 유형의 오류를 살펴봄으로써 책임을 어떻게 분산해야 하는지에 대한 아이디어를 얻을 수 있다
    - ConnectionError는는 connect 메서드 내에서 처리되어야한다
    - ValueError는 event의 decode 메서드에 속한 에러이다

#### 엔드 유저에서 Traceback 노출 금지

- 보안을 위한 고려 사항이다
- 악의적인 사용자에게도 유용한 정보여서 노출하면 위험하다

#### 비어있는 except 블록 지양

- 파이썬의 안티패턴중에서도 가장 악마 같은 패턴이다
    - 너무 방어적이어서 아무것도 하지 않은 채로 조용히 지나쳐버리는 비어있는 except 블록은 피해라

#### 원본 예외 포함

- 오류 처리 과정에서 기존 오류와 다른 새로운 오류를 발생시키고 오류 메시지를 변경할 수도이 있다. 이런 경우 원래 어떤 오류가 있었는지에 대한 정보를 포함하는 것이 좋다

```python
class InternalDataError(Exception):
    """업무 도메인 데이터의 예외"""


def process(data_dictionary, record_id):
    try:
        return data_dictionary[record_id]
    except KeyError as e:
        raise InternalDataError("데이터가 존재하지 않음") from e
```

- 위 코드처럼 PEP-3134에서 소개된 raise e from 구문을 사용하면 여러 예외를 연결할 수 있다
    - 이렇게 하면 원본 오류의 traceback 정보가 새로운 exception에 포함되고, 원본 오류는 새로운 오류의 원인으로 분류되어 __cause__속성에 할당된다

### 파이썬에서 어설션(assertion)사용하기

- `어설션은 절대로 일어나지 않아야 한느 상황에 사용되므로 assert 문에 사용된 표현식은 불가능한 조건을 의미한다`
    - 잘못된 시나리오에 도달할 경우 프로그램이 더 큰 피해를 입지 않도록 하기 위한 장치
    - 즉, 극복할 수 없는 예외 상황이며, 비지니스 로직과 섞거나 소프트웨어의 제어 흐름 메커니즘으로 사용해서는 안된다

```python
try:
    assert condition.holds(), "조건에 맞지 않음"
except AssertionError:
    alternative_procedure()
```

- 위 코드처럼 assert구문에 비즈니스 로직을 넣으면 안된다
    - 또한 assertion catch가 함수면 안된다
    - 그 함수가 또 AssertionError를 발생시킬지도 모른다
- 일반적으로 AssertionError는 더 이상 처리가 불가능한 상황을 의미하므로 catch이후에 프로그램을 계속 실행하면 안된다
    - 하지만 우아하게(gracefull) 종료하고 싶은 경우도 있따
    - AssertionError를 catch하여 일반적인 에러 메시지를 보여주고 상세 에러를 내부 시스템에 기록하고 종료시킬 수도 있다
    - 시스템에 기록하고 나중에 개선을 위한 목적으로 사용해야한다
- 예러 처리와의 관계
    - 일반적으로 예외는 예상하지 못한 상황을 처리하기 위한 것이도 어설션은 정확성을 보장하기 위해 스스로 체크하기 위한 것이다
    - 이러한 이유로 예외를 발생시키는 것이 어설션 구문을 사용하는 것보다 훨씬 일반적이다
    - 어설션 구문은 항상 변하지 않는 고정된 조건에 대해서 검증할 때 사용한다 