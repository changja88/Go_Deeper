# 코드 포매팅과 도구

- 파이썬이 제공하는 기능을 사용하여 자체 문서화된 코드를 작성하는 방법
- 코드의 레이아웃을 일정하게 유지하여 팀 멤버들이 문제의 본질을 해결하는데 초점을 맞출 수 있도록 도구를 설정하는 방법

## 서론

- 기술 부채를 갚기 위한 리팩토링을 하지 않는 것이 오히려 비용 효율적일 수 있는 상황에 대한 논의
- 결국은 예외가 있기 때문에 일반적인 규칙을 모든 곳에 무조건 적용할 수는 없다
- 중요한 것은 왜 기꺼이 예외를 인정해야 하는지 정확히 이해하는 것이다
- 실제로는 개선되어야 하는 것을 개선하지 않아도 된다고 오해하지 않도록 유의해야 한다

### 클린 모드의 의미

- 클린 코드를 측정할 방법은 없다
- 프로그래밍 언어의 진정한 의미는 아이디어를 다른 개발자에게 전달하는 것이다
    - 여기에 클린 코드의 본질이 있다
    - `즉 클린 코드인지 아닌지는 다른 엔지니어가 코드를 읽고 유지 관리할 수 있는지 여부에 달려 있다`

### 클린 코드의 중요성

- 유지 보수성 향상, 기술 부채의 감소, 애자일 개발을 통한 효과적인 작업 진행, 성공적인 프로젝트 관리

### 예외 상황

- 다음 상황에서는 일부 품질 검사를 하지 않을 수 있다
    - 해커톤
    - 일회성 작업을 위한 간다한 스크립트
    - 프로그래밍ㅇ 경진 대회
    - 기존에 없던 개념을 검증하기 위해 개발하느 ㄴ경우
    - 나중에 버려질 것이 확실한 프로토타입 개발
    - 앞으로 버려질것이 확실한 레거지 유지보수

## 클린 코드에서 코드 포매팅의 역할

- 클린 코드는 코딩 표준, 포매팅, 린팅 도구나 다른 검사 도구를 사용한 코드 레이아웃 설정과 같은 것 그 이상을 뜻한다
    - PEP-8 표준을 100% 준수한다 하여도 여전히 클린 코드가 아닐 수 있다
- 포맷팅이 주요 목표는 아니지만, 코드 구조에 주의를 기울이지 않으면 몇 가지 위험이 따른다

### 프로젝트 코딩 스타일 가이드 준수

- 코딩 가이드라인은 품질 표준을 지키기 위해 프로젝트에서 따라야만 하는 최소한의 요구사항이다
- 좋은 코드 레이아웃에서 가장 필요한 특성은 일관성이다
    - 코드가 일관되게 구조화되어 있으면 가독성이 높아지고 이해하기 쉬워진다
- 프로젝트에 어떠한 코딩 표준도 없다면 PEP-8을 사용하자
- PEP-8의 특징
    - 검색 효율성
        - 코드에서 원하는 부분을 빠르게 검색할 수 있도록 도와준다
        - 예를 들어 변수에 값을 할당하는 경우와 함수의 키워드 파리미터에 값을 할당하는 경우를 구분한다
        - location 파라미터에 값을 항당하는 곳을 찾고 싶은 경우 -> location= 으로 검색하면 된다
    - 일관성
    - 더 나은 오류 처리
        - PEP-8에서 제안한 것중 하나는 try/except 블록 내부의 코드를 최소화하자는 것이다
        - 이것은 실수로 예외를 숨기는 것을 방지하기 위한 것이다
        - 이 기능은 분명 자동화하기는 어려운 부분이므로 코드 리뷰를 하는 동안 유의해서 볼 필요가 있다
    - 코드 품질
        - 코드를 구조화하여 살펴보면 한 눈에 코드를 이해하고 버그와 실수를 쉽게 찾을 수 있다
        - 추가로 코드 품질 도구를 사용하면 잠재적인 버그를 찾을 수도 있다

## 문서화

- `코드 문서화는 코드에 주석을 추가하는 것과는 다르다`

### 코드 주석(code comments)

- 가능한 한 적은 주석을 갖는 것을 목표로 해야한다
    - 좋은 코드는 코드 자체가 문서화되어 있기 때문
    - 올바른 추상화를 했고 명확하게 일믕르 지정했따면 주석이 필요하지 않아야 한다
- 하지만 어떤 경우에는 코드에 주석을 추가하는 것을 피할 수 없다
    - 외부 함수의 문제를 피하기 위해 특정한 파라미터를 넘겨야 하는 경우와 같은 경우

### Docstring

- docstring은 소크 코드에 포함된 문서라고 말할 수 있다
    - `문서라는 말에서 알 수 있듯이 이유가 아니라 설명이다`
- Docstring은 모듈, 클래스, 메서드 또는 함수에 대해 문서를 제공하기 위한 것이다
    - 내가 작성한 컴포넌트를 다른 엔지니어가 사용하려고 할 때 docstring을 보고 동작방식과 입출력 정보 등을 확인할 수 있어야 한다
    - 최대한 docstring을 추가하려고 노력하는 것은 좋다
- Docstring은 프로그램 디자인과 아키텍처에 대해 문서화하는 데에도 유용하다
    - 전체적인 관점에서 해당 컴포넌트가 어떻게 설계되었는지 힌트를 줄 수 있기 때문에 중요한 모듈, 함수 및 클래스에 대해서는 docstring을 추가하는 것이 좋다
- Docstring이 파이썬에서 중요한 이유는 파이썬이 동적인 데이터 타입을 갖기 때문이다
- Docstring은 런타임 중에 접근할 수 있고 심지어 소스 코드에서 docstring 내용을 추가하거나 컴파일 하는 것이 가능하다
    - Sphinx(스핑크스)를 실행하면 프로젝트 문서화를 위한 기본 골격을 만들어 준다
    - 특히 autodoc 익스텐션(sphinx.ext.autodoc)을 사용하면 코드에서 docstring을 가져와 문서화된 페이지를 만들어 준다
    - 문서와 프로젝트가 하나가 되도록 해당 도구를 오픈해야 한다
        - 오픈소스 프로젝트라면 read the docs 와 같은 도구를 사용하여 브랜치나 버젼별로 문서를 자동으로 생성할 수도 있다
- Docstring의 단점은 모든 문서화가 그렇듯이 지속적으로 수작업을 해야 한다는 것이다
    - 만약 함수가 너무 간단하고 자명한 코드라면 중복된 의미를 가진 docstring을 피하는 것이 더 나은 선택일 수도 있다

### 어노테이션(Annotation)

- PEP-3107에서 어노테이션을 소개했다
    - 기본 아이디어는 코드 사용자에게 함수 인자로 어떤 값이 와야 하는지 힌트를 주자는 것이다
    - 즉, 어노테이션은 타입 힌팅을 활성화한다

```python
@dataclass
class Point:
    lat: float
    long: float


def locate(latitude: float, longitude: float) -> Point:
    """맵에서 좌표에 해당하는 객체를 검색"""
```

- float를 타입의 변수를 알 수 있지만 파이썬이 타입을 검사하거나 강제하지는 않는다
- 반환 값에 대한 예상 타입을 지정할 수도 있다

```python
def launch_task(delay_in_seconds):
    ...


Seconds = float


def launch_task(deplay: Seconds):
    ...
```

- delay_in_seconds는 많은 정보를 담고 있는 것 같아 보이지만 사실은 충분한 정보를 제공하지 못하고 있다
    - 분수를 넣어도 되나? 허용 가능한 지연시간은 몇 초 일까?
- 위 코드에서 아래는 코드는 자신의 기능에 대해 말을 하고 있다
    - Seconds 어노테이션을 사용하여 시간을 어떻게 해석할지에 대해 작은 추상화를 했다고 볼 수 있다

```python
def process_clients(clients: list):
    ...


def process_clients(clients: list[tuple[int, str]]):
    ...


Client = tuple[int, str]


def process_clietns(clients: list[Client]):
    ...
```

- 즉 타입 힌트가 단순히 데이터 타입을 확인하기 위한 것만은 아니다
    - 유의미한 이름을 사용하거나 적절한 데이터 타입 추상화를 하도록 도와줄 수 있다

### 어노테이션은 docstring을 대체하는 것일까?

- docstring과 어노케이션은 서로 보완적인 개념이다 -> 둘다 필요하다
    - docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 는 있는 것이 사실이다
    - 어노테이션으로 표현할 수 없는 것들은 여전히 docstring으로 담겨야 한다

## 도구 설정

- 포매팅, 일관된 레이아웃 만으로는 충분하지 않다
- 이 모든 검사는 자동화 해야한다. 테스트와 체크리스트가 지속적으로 통합빌드(CI)의 하나가 되도록 해야 한다

### 데이터 타입 일관성 검사

- 검사 도구로는 mypy, pytype 이 유명하다
- type_to_ignore = "something"  # type: ignore 와 같이 검사를 무시하도록 할 수 있다

```python
def broadcast_notification(message: str, relevant_user_meails: Iterable[str]):
    for email in relevant_user_meails:
        logger.info(f"{message} 메시지를 {email}에게 전달")


broadcast_notification("welcom", "user1@domain.com")
```

- 위 코드의 문제는 마지막줄 함수 호출을 하더라도 mypy가 오류를 보고하지 않는다는 것이다
    - "u","s" ... 와 같이 Iterable 하기 때문
    - 이런 경우 더 강력한 타입 제한을 줄 수 있다 -> 리스트나, 튜플만 허용하도록

```python
def get_list() -> List[str]:
    list = ["PyCon"]
    list.append(2022)  # mypy에서는 오류지만 pytype에서는 허용
    return [str(x) for x in list]
```

- mypy와 pytype의 큰 차이점은 오류를 확인하는 시점이다
    - pytype에서는 일시적으로 지정된 데잍터 타입과 다른 타입을 사용하여도 최종 결과가 선언된 유형을 준수하는 한 문제로 간주하지 않는다
    - 일반적으로는 코드에서 설정한 일관성을 유지하는 것이 좋다
    - list.append(2022)는 문자형이 아닌 숫자형을 추가하지만 마지막 줄에서 최종적으로 문자열로 변환한다 -> Pytype에서는 문제 없다고 간준한다

### 일반적인 코드 검증

- 데이터 타입을 검사하는 것 외에도 다른 도구를 사용하여 보다 일반적인 유형의 품질 검사를 하는 것도 가능하다
- 대표적으로 pycodestyle(pep8), flask8과 같은 도구가 있다
    - PEP-8 준수 여부를 검증한다
- PEP-8 준수 여부 검증 뿐만 아니라 PEP-8이상의 더 복잡한 것에 대한 추가 검사를 제공하는 도구도 있따
    - pylint
    - pylint는 가장 엄격한 수준의 검증을 하는 도구이며 기다 다른 여러 기능들도 포함하고 있다
- Coala
    - 파이썬뿐만 아니라 다른 여러 언어도 지원한다
    - 설정 파일이 있고, 커맨드 라인 도구가 있다 &rarr; 파일을 검사하고 에러를 발견하면 자동으로 수정 가능한 코드도 제안한다

### 자동 포매팅

- flask8은 여러 옵션을 설정 가능하고 프로젝트에 맞게 수정할 수 있따
    - 이렇게 설정 가능하고 유연함을 가진 도구와는 정반대되는 개념을 가진 도구가 있다 &rarr; black
- black
    - black은 라인 길이 제외와 같은 옵션을 허용하지 않으면서 고유하고 결정적인 방식으로 코드 형식을 지정하는 특징이 있다
    - ex) 따옴표는 항상 큰따옴표만 사용하고, 파라미터의 순서는 항상 동일한 구조를 따라야 한다
    - PEP-8은 코드의 구조에 대해서 가이드라인을 제시 하지만 그것을 지키는 방법에는 몇가지 옵션이 존재한다
        - black은 이점에 문제를 제기하고 보다 엄격한 하위 집합을 관리함으로써 항상 결정적인 형태의 포맷을 갖게한다

### 자동 검사 설정

- 리눅스 개발환경에서 빌드를 자동화하는 가장 일반적인 방법은 MakeFile을 사용하는 것이다
    - Makefile은 프로젝트를 컴파일하고 실행하기 위한 설정을 도와주는 강력한 도구이다
    - 빌드 외에 포매팅 검사나 코딩 컨벤션 검사를 자동화하기 위해 사용할 수도 있다
- 이러한 black, pylint, mypy와 같은 도구를 IDE에 연결하면 보다 편리하게 사용할 수 있다