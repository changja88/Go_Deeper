## 레코드, 구조체, 데이터 전송 객체

- 배열과 비교하여 레코드 데이터 구조는 고정된 수의 필드를 제공하며 각 필드는 이름을 가질 수 있고 서로 다른 타입을 담을 수도 있다

### dict: 간단한 데이터 객체

- 딕셔너리는 '맵' 또는 '연관 배열'이라고도 하며 주어진 키와 연관된 객체를 효율적으로 검색, 삽입, 삭제할 수 있다
- 딕셔너리를 레코드 데이터 타입또는 데이터 객체로 사용하는 것이 가능하다
- 딕셔너리로 사용하여 작성된 데이터 객체는 변경 가능하며 필드는 언제든지 자유롭게 수정, 추가, 삭제 될 수 있다 -> 버그 유발 가능성이 높다

### tuple: 불변 객체 그룹

- 임의의 객체를 그룹화하는 간단한 데이터 구조다
- 생성된 후에는 변경이 불가능 하다
- 튜플은 단점은 데이터 접근 방법이 인덱스 밖에 없다는 것이다 -> 따라서 수를 가능한 적게 유지 해야 한다

### 사용자 정의 클래스 작성: 코드가 늘어날수록 제어할 것도 늘어난다

- 클래스를 사용하면 데이터 객체에 대한 재사용 가능한 '청사진'을 정의하여 모든 객체가 동일한 필드 집합을 제공하도록 할 수 있다
- 하지만 너무 많은 접착 코드를 작성해야 한다
- 메서드를 사용하여 레코드 객체에 비즈니스 로직과 동작을 추가하려는 경우에는 언제나 유용한 선택지이다 -> 하지만 이렇게 사용하면 더이상 데이터 객체가 아니다

### collections.namedtuple: 편리한 데이터 객체

- 네임드튜플은 일반 튜플과 같이 변경할 수 있으며, 이름으로 데이터 접근이 가능하다
- 메모리 사용면에서도 일반 튜플만큼 효율적이다
- 딕셔너리와 같은 데이터 타입을 네임드튜플로 바꾸면 의도를 좀 더 명확하게 표현할 수 있다

### typing.NameTuple: 개선된 네임드 튜플

```python
from typing import NamedTuple


class Car(NamedTuple):
  color: str
  mileage: float


car = Car('red', 100)

car.mileage = 200  # 필드는 변경할 수 없다
Car('red', 'Not A Float')  # mypy 같은 별도 타입 확인 도구 없이는 타입 주석은 적용되지 않는다 -> 그냥 객체 생성이 된다 
```

- 파이썬 3.6에 추가된 이 클래스는 collections모듈의 namedtuple 클래스의 더 어린 형제이다
  - namedtuple과 매우 흡사하며 주요한 차이점은 새로운 레코드 타입을 정의하고 타입 힌트를 지원하도록 갱신된 구문ㅇ이다
  - mypy와 같은 별도의 타입 확이 ㄴ도구 없이는 적용되지 않는다
  - 하지만 도구 지원 없이도 다른 프로그래머에게 유용한 힌트를 제공할 수 있다

### struct.Struct: 직렬화된 C 구조체

- 파이썬 bytes 객체로 직렬화된 C 구조체와 파이썬 값 사이의 변환을 수행한다
  - 예를 들어 파일에 저장되거나 네트워크로부터 들어오는 이진 데이터를 처리하는데 사용할 수 있다
- 패스

### types.SimpleNamespace: 세련된 속성 접근

```python
from types import SimpleNamespace

car1 = SimpleNamespace(color='red', mileage=100)
car1.mileage = 12

```

- 파이썬에는 데이터 객체를 구현하기 위한 또 하나의 '난해한' 방법인 SimpleNamespace가 있다
  - 이 클래스는 파이썬 3.3에서 추가됐으며 네임스페이스의 속성에 접근할 수 있도록 해준다
- SimpleNamespace 인스턴스는 모든 키를 클래스 속성으로 노출한다
  - 즉 일반 딕셔너리에 사용하는 obj['key'] 대괄호 인덱스 문법대신 obj.key 와 같이 접근할 수 있다
