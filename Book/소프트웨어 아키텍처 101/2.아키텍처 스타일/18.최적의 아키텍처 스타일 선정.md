## 최적의 아키텍처 스타일 선정

- 최적의 아키텍처 스타일을ㄴ 없다 &rarr; 아키텍처 특성, 도메인 고려 사항, 전략적 목표, 그 밖의 다양한 것들의 트레이드오프를 고려하고 분석해서 결정해야 한다

## 아키텍처 '유행'은 계속 변한다

- 사람들이 좋아하는 아키텍처 스타일은 여러 가지 팩터들로 인해 그때그때 계속 변한다

### 과거를 돌아보다

- 새로운 아키텍처 스타일은 과거의 경험과 쓰라린 상처를 되돌아보면서 시작된다
- 새로운 아키텍처 설계는 과거 아키텍처 스타일에서 발견된 결함이 반영된 경우가 많다

### 생태계의 변화

- 수년 전만 해도 쿠버네티스가 무엇인지 거의 아무도 몰랐지만 지금은 전 세계 수천 명 개발자가 참석하는 콘퍼런스도 여럿 개최된다

### 새로운 기능

- 새로운 기능이 출현하면 아키텍처는 단순히 어떤 도구를 다른 도구로 대체하는 정도가 아닌, 완전히 새로운 패러다임으로 전환될 수 있다
- 아키텍트는 새로운 도구는 물론 새로운 패러다임 역시 예의주시해야 한다 &rarr; 게임 체인저가 될 만한 변경 사항이 있을지도 모른다

### 가속

- 생태계는 끊임없이 변할 뿐만 아니라 그 변화의 속도도 계속 빨라지고 있다
- 새로운 도구는 새로운 엔지니어링 프랙티스를 창출하고 이는 다시 새로운 설계와 기능으로 이어진다

### 도메인 변경

- 비지니스가 계속 진화하고 타 회사와 합병되면서 개발자가 소프트웨어를 개발하는 도메인 역시 변화한다

### 기술 변화

- 기술이 진화할수록 조직은 최소한 그 변화의 흐름의 일부라도 따라 잡으려고 한다

### 외부 팩터

- 주변 많은 요인들이 조직의 변화를 가져오는 경우도 있다
    - 아키텍트와 개발자 모두 완벽하게 만족하는 도구의 라이선스가 비싼 경우

## 결정 기준

- 도메인 설계 구조의 원인이 될 만한 모든 요소를 종합적으로 고려해야 한다
- 기본적으로 아키텍트는 주어진 도메인, 그리고 시스템을 성공적으로 구착하는 데 필요한 다른 모든 구조적 요소들을 설계한다

### 도메인

- 도메인에서 중요한 여러 가지 양상, 특히 어느 부분이 운영 아키텍처 특성에 영향을 미치는지 파악해야 한다
    - 도메인 전문가일 필요는 없지만 중요한 파트에 대해서 최소한의 지식은 있어야 한다

### 구조에 영향을 미치는 아키텍처 특성

- 아키텍트는 도메인과 다른 요소를 지원하는 데 필요한 아키텍처 특성을 정확하게 밝혀내야 한다

### 데이터 아키텍처

- 아키텍트와 DBA는 서로 머리를 맞대고 데이터베이스, 스키마 등 데이터에 관한 문제를 의논해야 한다
- 현재 사용 중인 데이터 아키텍처와 상호작용할 경우, 아키텍트는 반드시 데이터 설계가 아키텍처 설계에 미치는 영향도를 미리 파악해야 한다

### 조직 문제

- 갖가지 외부 팩터들도 설계에 영향을 준다
    - 특정 클라우드 벤더사의 이용료가 이상적인 설계를 가로막는 장애물이 되거나
    - 회사가 인수 합병에 참여할 계획을 수립하여 개발에 영향을 미치는 경우

### 프로세스, 팀, 운영 문제에 관한 지식

- 개발 프로세스, 운영팀과의 소통, QA 프로세스 등 프로젝트와 관련되 다양한 팩터들도 아키텍처 설계에 영향을 끼친다

### 도메인/아키텍처 동형성

- 아키텍처의 토폴로지와 잘 맞는 문제 영역이 있다
    - 마이크로 커널 아키텍처 스타일은 아키텍처적으로 플러그인 형태의 커스터마이징이 가능한 맞춤성이 필요한 시스템과 완벽하게 잘 어울린다
    - 무수히 많은 개별 연산이 필요한 게놈 분석 시스템은 무수히 많은 개별 프로세서를 제공하는 공간 기반 아키텍터가 좋다
- 반대로, 문제영역과 아키텍처 스타일이 불협화음이 나는 경우도 있다
    - 규모가 큰 모놀리식 구조로 확장성이 우수한 시스템을 설계하기가 어렵다
    - 의미적으로 커플링된 곳이 도처에 널려 있는 문제 영역도 고도로 분리된 분산 아키텍처와 안 맞는다

### 모놀리스냐 분산이냐

- 퀀텀 개념을 이용하여 단일 아키텍처 특성만으르도 설게에 부족함이 없는지, 아니면 시스템 파트별로 상이한 아키텍처 특성이 필요한지 판단해야 한다
    - 전자는 모놀리가 적합, 후자는 분산 아키텍처가 적합

### 데이터를 어디에 둘 것인가

- 일반적으로 모놀리식 아키텍처는 하나 또는 소수의 관계형 데이터베이스를 전제로 하지만, 분산 아키텍처는 아키텍트가 어느 서비스가 어떤 데이터를 저장할지 결정해야 한다
- 즉, 워크플로를 구축하기 전에 전체 아키텍처의 데이터 흐름에 대해 충분히 숙고해야 한다
- `구조와 행위를 모두 고려하여 최적은 조합을 찾아내기 위해 설계를 무한반복하는 것도 두려워해선 안된다`

### 서비스 간 통신은 동기, 비동기 중 어떤 스타일로 할 것인가?

- 동기 통신은 대부분 더 간편하긴 하지만 확장성, 안전성, 그 밖의 다른 아키텍처 특성에 부정적인 영향을 미칠 수 있다
- 비동기 통신은 성능, 확장성 측면에서 우월하나, 데이터 동기화, 데드락, 경합 조건, 디버깅 등 처리할게 많다
- 가급적 설계 구현, 디버깅 문제가 비교적 적은 동기 통신을 기본으로 하되, 필요한 경우에 비동기 통신을 함께 사용하는 것이 좋다

## 모놀리스 사례 연구: 실리콘 샌드위치

- 실리콘 샌드위치 카타의 아키텍처 특성을 조사한 후 이 시스템은 단일 퀀텀으로 구현해도 충분하다고 결정했다
    - 하지만 실리콘 샌드위치를 도메인 분할된 컴포넌트와 기술 분할된 컴포넌트, 이렇게 두 가지 상이한 컴포넌트로 설계했다. 트레이드 오프를 보자

### 모듈러 모놀리스

<img src = "../img/IMG_5949.jpg" width = "1000" height = "800">

- 위 이미지는 모듈러 모놀리스 단일 퀀텀으로 배포된 단일 데이터베이스 기반의 도메인 중심 시스템이다
    - 총 비용을 줄이기 위해 단일 웹 기반 유저인터페이스로 구현한 단일 관계형 데이터베이스 기반의 모놀리스이다
    - 추후를 위해 아키텍트는 도메인 컴포넌트 단위로 테이블과 기타 데이터베이스 자산을 분리하고 나중에 요구사항이 발생하면 분산 아키텍처로 쉽게 마이그레이션이 될 수 있도록 설계해야 한다
- 아키텍처 스타일 자체는 원래 커스터마이징을 할 수 없기 때문에 아키텍트는 원하는 기능을 도메인 설계의 일부로 달여 넣어야 한다
    - 여기서 아키텍트는 개발자가 개별적으로 커스터마이징한 결과물을 업로드할 수 있도록 오버라이드 엔드포인트를 설계한다
    - 이런식으로 각 도메인 컴포넌트가 커스ㅓ마이징 가능한 각각의 특성을 오버라이드 컴포넌트를 통해 참조할 수 있게 설게해야 완벽한 피트니스 함수가 만들어 진다

### 마이크로 커널

<img src = "../img/IMG_5950.jpg" width = "800" height = "1000">

- 실리콘 샌드위치에서 식별된 아키텍처 특성 중 하나가 맞춤성이었다
    - 아키텍트는 도메인/아키텍처 동형성을 검토후 위 이미지와 같이 마이크로 커널 형태로 구현할 수도 있다
- 위 이미지에서 코어 시스템은 도메인 컴포넌트와 단일 관계형 데이터베이스로 구성된다
    - 이전 설계와 마찬가지로, 도메인과 데이터를 신중하게 동기ㅗ하하면 향후 분산 아키텍처로 코어 마이그레이션할 수 있따
    - 커스터마이징은 각각 하나의 플러그인(해당 데이터베이스가 포함된) 다닝ㄹ 플러그인 세트 내부의 공통 플러그인들(제각기 자체 데이터를 보유한)일련의 로컬 플러기인 형태로 나타나나
    - 어느 플러그인도 다른 것들과 커플링될 일은 없으므로 각 플러그인은 따로 떨어져 자신의 데이터를 유지할 수 있따
- 프런트엔드를 위한 백엔드(BFF, Backend for Frontend)패턴을 응용해서 API레이어를 마이크로 커널 어댑터로 사용하는 독특할 설계 방법도 있다
    - 일반적인 정보는 백엔드가 제공하고 BFF어댑터는 이 정보를 프론트엔드 장치에 적합한 포맷으로 바꾸는 방식이다
    - iOS용 BFF는 백엔드에서 일반 출력 데이터를 가져와 데이터 포맷, 페이지네이션, 레이턴시, 기타 iOS 네이티브 애플리케이션이 원하는 사양에 맞게 변환한다
    - 이런식으로 BFF어댑터를 만들면 마이크로커널 스타일만의 풍부한 유저 인터페이스가 가능하고 향후 다른 장치들까지 확장 지원이 간으하다
- 모듈러 모놀리스, 마이크로커널, 어느 쪽이든 어멍난 성능이나 탄력성을 요하지 않고 오래 걸릴 작업이 없으므로 통신으 동기방식으로도 충분하다

### 분산 아키텍처 사례 연구: GGG

- GGG카타는 아키텍처는 여러 부분마다 상이한 아키텍처 특성을 필요로 한다
    - 가용성, 확장성 같은 아키텍처 특성이 입찰자와 경매인 등의 역할마다 다르다
    - GGG는 어느 정도 야심 찬 수준의 규모, 탄력성, 성능 그 밖의 까다로운 운영 아키텍처 특성이 요구사항에 명시되어 있다
    - 내부의 세부적인 수준까지 고도의 커스터마이징이 가능한 패턴을 선택해야 한다
    - 후보로는 저수준의 이벤트 기반 또는 마이크로서비스가 있다
        - 이중 마이크로 서비스가 운영 아키텍처 특성을 보다 잘 지원한다
        - 순수한 이벤트 기반 아키텍처는 대부분 운영 아키텍처 특성에 따라 나누지 않고 통신 스타일, 즉 오케스트레이션 방식이냐 코레오그래피 방식이냐에 따라 구분된다

<img src = "../img/IMG_5951.jpg" width = "1000" height = "800">

- 위 이미지는 마이크로서비스를 사용하여 구현한 GGG 아키텍처이다
- 마이크로서비스에서 요구사항에 명시된 성능을 달성하기는 쉽지 않지만, 성능 요건을 수용하도록 설계함으로써 아키텍처 곳곳의 약점을 보완할 수 있다
    - 마이크로서비스는 원래 속성상 높은 수준의 확장성을 제공하지만, 아키텍트는 오케이스트레이션을 너무 많이 사용하거나, 과도하게 데이터를 분리하는 등 성능에 영향을 미치는 갖가지 문제를 해결해야 한다
- 위 이미지에서 식별된 각각의 컴포넌트는 아키텍처의 서비스가 되어 컴포넌트와 서비스 세분도가 꼭맞다. 아래는 세가지 고유한 유저 인터페이스 이다

#### 인터페이스

- 입찰자 : 온라인 경매에 참가한 수많은 입찰자
- 경매인 : 경매 당 한 사람
- 스트리머:  입찰자에게 동영상 및 입찰 스트리밍을 담당하는 서비스, 일긱 전용 스트림으로 업데이트가 필요한 경우 최적화는 사용할 수 없다

#### 다음은 아키텍처 설계에 등장하는 서비스들이다

- BidCapture : 온라인 입찰자의 입찰을 캡쳐해서 BidTrackter로 비동기 전송한다. 온라인 입찰의 관문 역할을 할 뿐 퍼시스턴스 로직은 없는 서비스이다
- BidStreamer : 온라인 입찰자에게 입찰 정보를 고성능 읽기 전용 스트림으로 스트리밍한다
- BidTracker
    - AuctioneerCapture, BidCapture 양쪽에서 입찰을 추적한다
    - 서로 다른 두 정보 스트림을 하나로 합하여 간으한 한 실시간에 가깝게 입찰을 정렬하는 텀포넌트이다
    - 이 서비스의 두 인바운드 커넥션은 모두 비동기라서 개발자는 메시지 큐를 버퍼로 사용해 완전히 다른 속도로 메시지 흐름을 처리할 수 있다
- AuctioneerCapture : 경매인을 위해 입찰을 캡쳐한다. 8.7장에서 퀀텀 분석 결과에 따라 아키텍처 특성이 완전히 다르므로 BidCapture와 AuctioneerCapture로 분리했다
- AuctionSession : 각 경매의 워크플로를 관리한다
- Payment : AcutionSession이 경과하여 경매가 완료된 후 결제 정보를 처리하는 서드파트 결제 서비스
- VideoCapture : 라이브 경매의 비디오 스트림을 캡쳐한다
- VideoStreamer : 경매 동영상을 온라인 입찰자에게 스트리밍 한다

<img src = "../img/IMG_5952.jpg" width = "1000" height = "800">

- 위 이미지는 최종 분설 결과이며, 5개 퀀텀으로 마무리 했다
- 이 아키텍처에서 동기 통신 스타일과 비동기 통신 스타일을 주의 깊게 식별했다
    - 비동기 통신을 선택한 것은 주로 서비스마다 상이한 운영 아키텍처 특성을 감안한 결과이다
    - 에를 들어, 결제 서비스가 새 결제 정보를 500밀리초마다 하나씩 처리 가능하고 아주 많은 경매가 동시에 종료되는 일이 흔한 상황에서 서비스 간에 도익 통신을 하면 타임아웃과 여러 가지 안정성 문제가
      발생할 수 있다. 이럴 때 아키텍트는 메시지 큐를 사용하여 취약성이 드러나 아키텍처의 주요 파트에 안정성을 확보할 수 있다
- 설계는 대략 각 서비스에 대응되는 Payment, Actioneer, Bidder,m BidderStreams, BidTracker 퀀텀을 포함한다
    - 이미지에는 여러 인스턴스가 컨테이너 스택으료 표시되어 있다
    - 아키텍트는 컴포넌트 설계 단위부터 퀀텀 분석 기법을 활용하여 서비스, 데이터, 통신 경계를 보다 쉽게 식별할 수 있다 





