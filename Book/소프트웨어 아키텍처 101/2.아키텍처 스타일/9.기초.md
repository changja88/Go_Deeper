## 기초

- 아키텍처 스타일 = 아키텍처 패턴 = 아키텍처 특성을 다루는 컴포넌트의 명명된 관계

## 9.1 기초 패턴

- 소프트웨어 아키텍처의 역사를 통틀어 끊임없이 나타나고 또 나타나는 패턴들이 있는데, 이런 패턴들은 코드 배포, 또는 아키텍처의 다른 부분을 구성하는 시야를 넓혀준다

### 9.1.1 진흙잡탕

- 뭐 하나 뚜렷한 아키텍처 구조가 전무한 상태를 진흙잡탕 이라고 표현 한다
- 보통 실제 내부 구조라 할 만한 것은 하나도 없는, 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션을 가리킨다
    - 보통 이렇게 별 대수롭지 않게 시작한 애플리케이션 나중에 규모가 커지면서 처치 곤란한 상태가 된다

### 9.1.2 유니터리 아키텍처 (Unitary)

- 유니터리(단일, 통일) 시스템은 임베디드 시스템과 그 밖에 매우 제약이 많은 극소수 환경을 제외하면 거의 쓰이지 않는다

### 9.1.3 클라이언트/서버

- 시간이 갈수록 단일 시스템에서 여러 기능을 분리할 필요성이 대두되었고 그 분리 방법은 많은 아키텍처 스타일의 기초가 되었다
    - `실제로 대부분의 아키텍처 스타일은 시스템에 있는 여러 부분을 효과적으로 분리하는 방법을 다룬다`
- 프론트엔드와 백엔드로 기술적으로 기능을 분리한 2티어 또는 클라이언트/서버 아키텍처는 대표적인 기본 아키텍처 스탈이다
- 이 아키텍처는 시대와 컴퓨팅파워에 따라 여러가지 형태로 존재해왔다
- 데스크톱 + 데이터베이스 서버
    - 리치 데스크톱 애플리케이션 + 스탠드얼론 데이터베이스 서버
    - 프레젠테ㅣ션 로직은 데스크톱에 두고(양과 복잡도 모두) 계산량이 많은 액션은 사양이 탄탄한 데이터베이스 서버에서 실행
    - ex) 윈도우 + 단독, 독립형 데이터 베이스
- 브라우저 + 웹 서버
    - 웹 브라우저가 &rarr; 웹 서버 &rarr; 데이터베이스 서버
    - 클라이언트는 데스크톱보다 훨씬 가벼운 브라우저로 대체되었고 내외부 방화벽 모두 더 넓은 범위로 배포가 가능해졌다
    - 데이터베이스는 웹 서버와 분리되어 있지만 두 서버 모두 운영 센터 내부의 동급 머신에서 운용되고 유저 인터페이스는 브라우저에서 실행되므로 여전이 이구조를 2티어 아키텍처로 보는 경우도 있다
- 3티어
    - 고성능 데이터베이스 서버를 사용하는 데이터 베이스 티어,
    - 애플리케이션 서버가 관리하는 애플리케이션 티어,
    - 처음에는 HTML로 시작하여 기능이 점점 많아져 온갖 자바스크립트ㅏ 코드로 가득찬 프론트엔드 티어
    - 3티어 아키텍처는 분산 아키텍처에 적합한 공통 객체 요청 브로커 아키텍처(CORBA), 분산 컴포넌트 객체 모델(DCOM)같은 네티워크 수준의 프로토콜과 잘 맞는다
    - 이 아키텍처는 미래의 대세가 될것 같았지만 사실 잠ㅈ깐 떳다가 졌다...

## 9.2 모놀리식 대 분산 아키텍처

- 아키텍처 스타일은 크게 아래 두가지 이다
    - 모놀리식 &rarr; 전체 코드를 단일 단위로 배포
    - 분산형 &rarr; 원격 액세스 프로토콜을 통해 여러 단위로 배포
- 이 책에서는 다음과 같은 아키텍처 스타일을 알아 본다
- 모놀리식
    - 레이어드 아키텍처(10장)
    - 파이프라인 아키텍처(11장)
    - 마이크로커널 아키텍처(12장)
- 분산형
    - 서비스 기반 아키텍처(13장)
    - 이벤트 기반 아키텍처(14장)
    - 공간 기반 아키텍처(15장)
    - 서비스 지향 이키텍처(16장)
    - 마이크로서비스 아키텍처(17장)
- 분산 아키텍처 스타일은 모놀리식 아키텍처 스타일에 비해 성능, 확장성, 가용성 측면에서 훨씬 강력하지만, 이런 파워에도 분명한 트레이드오프(오류)가 있다

### 9.2.1 오류#1: 네트워크는 믿을 수 있다

<img src = "./IMG_5693.jpg" width = "800" height = "300">

- `개발자, 아키텍트 모두 네트워크는 믿을 수 있다고 전제하지만 실제로는 전혀 그렇지 않다`
- 분산 아키텍처는 특성상 서비스를 오가는, 또 서비스 간에 이동하는 네트워크에 의존하므로 이것은 아주 중요한 문제이다
- 위 이미지에서 서비스 B는 완전히 정상이지만 네트워크 문제 때문에 서비스A는 서비스B에 닿지 못한다

### 9.2.2 오류 #2: 레이턴스는 0이다

<img src = "./IMG_5694.jpg" width = "900" height = "400">

- 위 이미지를 보면, 메서드나 함수를 이용해 다른 컴포넌트를 로컬에서 호출하면 소요시간은 대게 나노 초 내지 밀리초 단위로 측정 되지만, 동일한 호출일 (REST, 메시징, RPC 등의) 원격 액세스 프로토콜을
  통해서 수행하면 서비스 액새스 시간이 밀리초로 측정 된다
- `따라서 t_remote 는 항상 t_local 보다 클 수밖에 없고 모든 분산 아키텍처에서 레이턴스는 0이 아니다`
- 때문에 아키텍트는 어떤 분산 아키텍처를 구축하든지 간에 평균 레이턴시는 반드시 알아야 하며, 이것이 분산 아키텍처가 실형 가능한지 판단하는 유일한 방법이다
- `평균 레이턴시가 60밀리초에 불과해도(괜찮은 수치)95번째 백분위수는 400밀리초일 수 있다 보통 이런 긴 꼬리(long tatil)레이턴시가 분산 아키텍처 성능을 저해하는 주범이다`

### 9.2.3 오류 #3: 대역폭은 무한하다

<img src = "./IMG_5695.jpg" width = "900" height = "400">

- 모놀리식 아키텍처는 비즈니스 요청을 처리하는 데 그리 큰 대역폭이 필요하지 않으므로 대역폭이 문제될 일은 별로 없다
- 하지만 위 이미지처럼 마이크로서비스 분산 아키텍처에서 시스템이 자잘한 배포 단위(서비스)로 쪼개지면 이 서비스들 간에 주고받는 통신이 대역폭을 상당히 점유하여 네트워크가 느려지고 결국 레이턴시(오류2)와 신뢰성(
  오류1)에도 영향을 미친다
- 시스템 커플링은 분산 아키텍처에서 상당히 많은 대역폭을 차지한다. 다음과 같은 방법으로 해결할 수 있다
    - 프라이빗 REST API 엔드포인트를 둔다
    - 계약에 필드 셀렉터를 사용한다
    - GraphQL로 계약을 분리한다
    - 컨슈머 주도 계약(consumer-driven contract, CDC)와 값 주도 계약(value-driven VDC)를 병용한다
    - 내부 메시징 엔드포인트를 사용한다
    - 어떤 기법을 적용하든, 분산 아키텍처의 서비스 또는 시스템 간에 최소한의 데이터만 주고받도록 하는 것이 이 오류를 바로잡는 최선의 길이다

### 9.2.4 오류 #4: 네트워크는 안전하다

<img src = "./IMG_5696.jpg" width = "900" height = "400">

- 아키텍트와 개발자는 대부분 가상사설망(VPN), 신뢰할 수 있는 네트워크, 방화벽에 너무 익숙해진 나머지, 네트워크가 안전하지 않다는 사실을 망각하는 경향이 있따
    - 보안은 분산 아키텍처에서 훨씬 더 어려운 문제이다
    - 위 이미지 처럼 분산 배포된 각 엔드포인트는 알려지지 않은 또는 악의적인 요청이 해당 서비스로 유입되지 않게 철저한 보안 대책을 강구해야 한다
    - 모놀리식에서 분산 아키텍처로 옮아가면서 더 넓은 영역이 악의적인 외부인의 위협과 공격에 노출된다

### 9.2.5 오류 #5: 토폴로지는 절대 안 바뀐다

<img src = "./IMG_5697.jpg" width = "900" height = "400">

- 토폴로지 : 망구성방식
- 네트워크를 구성하는 모든 라우터, 허브, 스위치, 방화벽, 네트워크, 어플라이언스 등 전체 네트워크 토폴로지가 불변일 거란 가정은 섣부른 오해이다
- 아키텍트는 운영자, 네트워크 관리자와 항시 소통을 하면서 무엇이, 언제 변경되는지 알고 있어야 한다

### 9.2.6 오류 #6: 관리자는 한 사람뿐이다

<img src = "./IMG_5698.jpg" width = "900" height = "400">

- 아키텍트는 언제나 한 사람의 관리자와만 협의하고 소통하면 된다는 오류에 빠지곤 한다. 대기업에서 일하는 네트워크 관리자는 보통 수십 명에 이른다
- 분산 아키텍처는 복잡할 수밖에 없고 모든 것을 정상 궤도에 올려놓으려면 상당히 많은 조율 과정이 불가피하다
- 모놀리식 애플리케이션은 단일 단위로 배포하기 때문에 이 정도의 소통과 협력까지는 필요하지 않다

### 9.2.7 오류 #7: 운송비는 0이다

<img src = "./IMG_5699.jpg" width = "1000" height = "300">

- 많은 아키텍트들이 이 오류를 레이턴스와 혼동한다. 여기서 운송비는 레이턴시가 아니라, 단순한 REST 호출을 하는데 소요되는 진짜 비용(돈)을 말한다
- 당연히 분산 아키텍처는 모든 것이 더 많이 동원되므로 모놀리식 아키텍처보다 비용이 훨씬 많이 든다

### 9.2.8 오류 #8: 네트워크는 균일하다

<img src = "./IMG_5700.jpg" width = "1000" height = "300">

- 아키텍트, 개발자는 대부분 네트워크가 균일하다. 즉 어느 네트워크 하드웨어 업체 한곳에서 모든 장비를 다 만들었다고 착각한다
    - 온갖 종류의 하드웨어가 서로 다 잘 맞물려 동작하는 건 아니라는 말이다
- 실제로 간혹 네트워크 패킷이 유실되는 사고도 심심찮게 발생한다
    - 결국 네트워크 신뢰성, 레이턴시, 대역폭도 차례로 영향을 받는다

### 9.2.9 다른 분산 아키텍처 고려 사항

- 다음은 모놀리식 아키텍처에는 없지만 분산 아키텍처를 설계 할때 맞닥뜨리게 될 이슈와 해결해야 할 난제들이다
- 분산 로깅
    - 분산 아키텍처는 애플리케이션과 시스템 로그가 분산되어 있으므로 어떤 데이터가 누락된 근본 원인을 밝혀내기가 대단히 어렵고 시간도 많이 걸린다
    - 스플렁크 같은 로깅 통합 도구를 사용하면 다양한 소스와 시스템에서 통합된 로그 및 콘솔 데이터를 취합할 수 있지만 복잡한 분산 로그를 확인하기에는 역부족이다
- 분산 트랜잭션
    - 모놀리식 아키텍처 세계에서 아키텍트, 개발자는 직관적이고 관리가 편한 트랜잭션을 당연시 한다
    - 퍼시스턴스 프레임워크가 대신 실행하는 표준 커밋/롤백 기능은 ACID(원자성)트랜잭션을 걸어 업데이트 시 데이터 일관성과 무결성을 강제한다. 하지만 분산 아키텍처는 사정이 다르다
    - 분산 아키텍처는 최종 일관성이라는 개념을 바탕으로 별도로 분리된 배포 단위에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화 한다
        - 확장성, 성능, 가용성을 얻는 대가로 데이터 일관성과 무결성을 희생하는 트레이드오프인 셈이다
    - 분산 트랜잭션을 관리하는 한 가지 방법으로 트랜잭셔널 사가(transactional saga)가 있다
        - 사가는 보상을 위해 이벤트를 소싱하거나 트랜잭션 상태를 관리하기 위해 유한 생태 기계(finite state machine)을 활용한다
    - 사가 이외에 BASE 트랜잭션도 사용한다
        - BASE는 (BA)sicavailability(기본 가용성),(S)oft state(소프트 상태), (E)ventual consistency(최종 일관성)dlek
        - BASE 트랜잭션은 어떤 소프트웨어 조각이 아니라, 일종의 기법이다
        - 소프트 상태는 소스 -> 타깃으로의 데이터 전달과 데이터 소스 간 비일관성을 말한다
        - 시스템 또는 서비스의 기본 가용성에 따라 시스템은 아키텍처 패턴과 메시징을 사용하여 결국 언제가 일관되게 맞춰질 것이다
- 계약 관리 및 버저닝
    - 계약 생성, 유지보수, 버저닝 역시 분산 아키텍처에서 다소 까다롭다
    - 계약은 클라이언트와 서비스 모두 합의한 행위와 데이터이다
    - 분산 아키텍처에서는 분리된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 떄문에 계약 유지보수가 특히 어렵다
    - 버전 구식화(데프리케이션)에 플요ㅕ한 통신 모델은 더 더욱 복잡하다 