## 카이크로서비스 아키텍처 스타일

- 마이크로서비스는 최근 엄청난 탄력을 받고 있는, 아주 평판이 좋은 아키텍처 스타일이다
- 토폴로지와 철학, 두 다기 관점으로 나누어 특성을 개괄한다

### 역사

- 대부분의 아키텍처 스타일은 반복적으로 나타나는 패턴을 청므 발견한 아키텍트의 이름을 딸서 명명한다
    - 즉, 다음에 유행할 아키텍처 스타일을 결정하는 비밀 아키텍트 그룹 따위가 있는 게 아니라, 외려 소프트웨어 개발 생태계가 변화하면서 많은 아키텍트들은 공통의 결정에 이르는 것이 일반적이다
    - 이런 변화의 물경에 대응하면서 장점을 취하는 최선은 방법이 다른 사람들이 흉내내는 아키텍처 스타일이 된다
- 하지만 이런 점에서 마이크로서비스는 사뭇 다르다
    - 사용 초기부터 이름이 붙여졌고 마틴 파울러와 제임스 루이스가 쓴 Microservices라는 유명한 블로그 게시글 덕분에 널리 퍼졌다
    - 이게 동의한 많은 아키텍트들이 아키텍처를 정의하고 그 하부에 내재된 철학을 이해하는데 더움을 주었다
- 마이크로서비스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계(DDD)사상의 영향을 많이 받았다
    - 특히 디커플링 스타일을 나타낸 경게 콘텍스트(bounded context)개념은 마이크로서비스에 결정적인 영향을 미쳤다
    - 개발자가 정의한 도메인에는 코드, 데이터베이스 스키마 같은 아티팩트에서 식별되는 수많은 엔티티와 행위가 포함된다
    - 예를 들어, CatalogCheckout 도메인은 카탈로그 항목, 고객, 결제 등의 개념을 갖고 있다
    - 전통적인 모놀리식 아키텍처에서 개발자는 이런 수많은 개념을 공유하고 재사용 가능한 클래스를 만들어 데이터베이스에 접속했다
    - 경계 콘텍스트 내부에서는 코드, 데이터 스키마 같은 내부 요소들이 함께 연결되어 작동하지만, 외부에 있는 것(데이터베이스, 클래스)들은 전형 커플링되지 않는다
    - `재사용은 유익하지만 커플링이 문제이다. 재사용을 선호하는 시스템을 설계하다 보면 결국 상속이나 조합을 이용하여 재사용하기 위해 커플링이 맺어지게 된다`
    - `그러나 고도의 디커플링이 아키텍트의 목표라면 재사용보다 중복을 우선할 것이다`
    - `마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링이다`

### 토폴로지

<img src = "../img/IMG_5869.jpg" width = "1000" height = "600">

- 위 이미지 처럼 마이크로서비스는 단일 목적만 가지기 때문에 오케스트레이션 기반의 서비스 지향 아키텍처와 같은 분산 아키텍처보다 서비스 규모가 훨씬 작다
    - 실제로 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트 등 서비스가 독립적으로 작동되는 데 필요한 모든 것들이 준비되어 있다

### 분산

- 마이크로서비스는 분산 아키텍처를 형성한다
- 서비스를 이 정도로 디커플링하면 애플리케이션을 호스트하는 육중한 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제를 간단히 해결 할 수 있다
    - 애플리케이션 서비를 이용해 다수의 애플리케이션을 관리할 때에도 네트워크 대역폭, 메모리, 디스크 공간 등 여러 가지 해택을 운영 측면에서 재사용할 수 있다. 그러나 지원해야 할 애플리케이션이 계속 늘어나면
      려국 일 부 리소는 공유 인프라의 제약을 받을 수밖에 없다. 또 공유 애플리케이션 간의 잘못된 분리도 문제가 되는 경우가 있다
    - 위 문제는 마이크로서비스에서는 각 서비스를 자체 프로세스로 분리하면 모두 자연스럽게 해소된다
- 분산 속성 탓에 성능은 다소 부정적이다
    - 아무래도 네트워크 호출은 메서드 호출보다 오래 걸리고 앤드포인트마다 보안 검증 절차를 거치면 그만큼 처리 시간이 소요되므로 시스템을 설계하는 아키텍트는 서비스 세분도에 대해 심사숙고 해야 한다
- 분산 아키텍처의 일종이므로 아키텍트는 개발자가 서비스 경계를 넘나드는 트랜잭션을 사용하지 않도록 권고해야 한다
- `즉, 이 아키텍처는 서비스를 얼마나 세분화할 것인가를 잘 결정하는 것이 성공의 관건이다`

### 경계 콘텍스트

- 마이크로서비스의 근본 철학은 경계 콘텍스트(bounded context)개념이다
    - 서비스마다 도메인이나 워크플로를 모델링하는 개념이다
    - 클래스, 기타 부속 컴포넌트, 데이터베이스 스키마 등 애플리케이션 작동에 필요한 모든 것들이 각 서비스에 들어간다
    - `따라서 커플링을 가급적 삼가므로 공유/재사용으로 인한 커플링보다는 중복이 낫다고 여긴다`
- 각각의 마이크로서비스는 어느 한 도메인이나 그 서브도메인을 나타낸다
    - `결국 도메인 주도 설게의 논리적인 개념을 물리적으로 구현한 것이다`

### 세분도

- 아키텍트는 마이크로서비스의 알맞은 세분도를 찾기 위해 고심하다가 종종 서비스를 너무 잘게 나누는 실수를 한다. 그래서 뭔가작업을 하려면 서비스 간 통신 링크를 다시 구축해야 하는 지경에 이른다
- 서비스 경계는 도메인이나 워크플로를 캡처하는 것이 목표이다
- 다음은 아키텍트가 적절한 경계를 찾는데 데 도움이 될만한 가이드라인이다

#### 목적

- 가장 확실한 경계는 바로 이 아키텍처 스타일의 본래 의도인 도메인이다
- 각 마이크로서비스가 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공하는 것이 가장 이상적인 모습이다

#### 트랜잭션

- 여러 엔티티가 함께 개입하여 작동되는 트랜잭션은 아키텍트에게 좋은 서비스 경계 후보이다
- 분산 아키텍처에서 트랜잭션은 문제가 될 소지가 있으므로 그런 문제를 방지할 수 있도록 설계하는 것이 바람직하다

#### 코레오그래피

- 도메인 격리는 아주 잘 되어 있지만 서로 광범위한 통신을 해야 제대로 작동되는 서비스 세트를 구축할 경우, 통신 오버헤드를 줄이기 위해서 더 큰 서비스로 다시 뭉치는 것을 고려해야 할 수도 있다
- 좋은 서비스 설계안을 도출하는 유일한 방법은 이터레이션이다
    - 처음 한 번 시도로는 완벽한 세분도, 데이터 종속성, 통신 스타일을 찾아내기 어렵지만, 여러 가지 옵션을 반복해서 적용해 보면 좋은 방향으로 설게를 다듬어갈 수 있다

### 데이터 격리

- 마이크로서비스는 경계 콘텍스트 개념에 따라 데이터를 격리해야 한다
    - 대부분의 다른 아키텍처는 데이터를 단일 데이터베이스에 저장하지만, 마이크로서비스 아키텍처는 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링은 없애려고 한다
- `데이터 격리는 서비스 세분도를 살필 때 반드시 고려해야 할 팩터이다`
    - 엔티티 함정에 유의하여 서비스를 단순히 데이터베이스에 있는 엔티티와 비슷하게 모델링해서는 안된다
- 시스템 내부 값들을 관계형 데이터베이스로 통합하여 단일 진실 공급원을 만드는 일에 익숙하겠지만, 마이크로서비스 에서는 이렇게 하면 안된다
    - 어렇게 하면 아키텍처 전체에 데이터를 분산시킬 수 있을지 결정해야 한다
- 이 정도 수준이 데이터 격리만으로도 골치가 아프지만 긍정적인 부분도 있다
    - 이제 여러 팀이 단일 데이터베이스의 속박에서 벗어나게 되어 각 서비스마다 단가, 스토리지 종류, 그 밖의 여러 요소들을 저울질하여 가장 적합한 도구를 선택할 수 있다
    - 또 고도로 분리된 시스템에서 다른 팀에 영향을 끼치지 않고 그때그때 상황에 맞게 더 적합한 데이터베이스를 선택할 수 있고 구현체 세부에 얽매이지 않는 것도 이점이다

### API 레이어

- 마이크로서비스 다이어그램을 보면 대부분 필수는 아니지만 여러 시스템 컨슈머 사이에 API레에이(유저 인터페이스 또는 다른 시스템의 호출)가 있다
    - API레이어는 프록시를 경유하여 간접화하거나 네이밍 서비스 같은 운영 장치에 물려서 유용한 작업을 수행하기 좋은 위치에 있기 때문에 이 많이 쓰인다
- `API레이어는 다양한 용도로 활용할 수 있지만 이 아키텍처의 기본 철학에 충실하려면 API레이어를 중재자나 오케스트레이션 도구로 사용하지 말아야 한다`
    - 모든 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 하며, 오케스트레이션 등의 다른 로직을 중재자에 넣는 것은 규칙 위반이다
    - 이는 아키텍처의 기술 분할과 도메이 분할의 차이점을 잘 보여준다
    - `중재자는 기술 분할된 아키텍처에서 사용하지만, 마이크로서비스느느 확실히 도메인에 따라 분할된다`

### 운영 재사용

- 마이크로서비스가 커플링보다 복제를 선호한다. 그러면 모니터링, 로깅, 회로 차단기 등의 운영 관심사와 같이 실제로 커플링이 더 유리한 부분은 어떻게 처리해야 할까?
    - 전통적인 서비스 지향 아키텍처의 철학에 따르면 도메인이든 운영이든 가급적 많은 기능을 재사용하는 것이 좋다
    - 하지만 마이크로서비스 아키텍트는 이 두가지 관심사를 분리하고자 하나
- 여러 마이크로서비스를 구축한 이후에 잘 살펴보면 각 마이크로서비스에 공통적인 요소가 있고 그 유사성을 활용하면 더 유리한 부분이 있음을 알게 된다
    - 예를 들어 서비스 팀마다 자체 모니터링 체제를 구축하도록 허용하면 팀별로 알아서 잘하리라 장담할 수 있을까? 업그레이드 문제는? 모니터링 도구 업그레이드는 팀별 책임으로 부과해야 할까?
    - 이 문제를 해결하는 방법이 바로 사이드카 패턴(sidecar pattern)이다

<img src = "../img/IMG_5870.jpg" width = "800" height = "500">

- 이미지처럼 공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고, 해당 팀이나 공유 인프라팀이 소유할 수 있도록 한다
- 사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리한다
    - 따라서 가령 모니터링 도구를 업그레이드할 때가 되면 공유 인프라팀이 사이드카를 업데이트하는 방식으로 각 마이크로서비스는 신기능을 받아 사용할 수 있다
- 각 서비스에는 공통 사이드카가 포함돼 있으므로 서비스 메시(service mesh)를 구축하면 로깅, 모니터링 등의 관심사를 아키텍처 전체적으로 일원화하여 제어할 수 있다
    - 공통 사이드가 컴포넌트는 모든 마이크로서비스에 대해 일관된 운영 인터페이스를 제공한다 (아래 그림)

<img src = "../img/IMG_5871.jpg" width = "800" height = "500">

- 서비스 메시 자체는 개발자가 서비스를 전체적으로 액세스할 수 있는 콘솔 역할을 한다 (아래 그림)

<img src = "../img/IMG_5872.jpg" width = "600" height = "400">

- 위 이미지에서 보다시피, 전체 메시에서 각 서비스는 하나의 노드이다
    - 서비스 메시는 각 팀이 모니터링 레벨, 로깅, 그 밖의 공통 운영 관심사 등 운영과 커플링된 부분을 글로벌하게 제어하는 콘솔이다
- 아키텍트는 마이크로서비스 아키텍처에 탄력성을 부여하는 수단으로 서비스 디스커버리(service discovery)를 사용한다
    - 어느 하나의 서비스를 직접 호출하는게 아니라, 모든 요청이 서비스 디스커버리 도구를 거치도록 하면 요청 수와 빈도를 모니터링할 수 있고 필요시 서비스 인스턴스를 늘려 확장성/탄력성을 줄 수 있다
    - 보통 서비스 메시 안에 서비스 디스커버리를 포함시켜 모든 마이크로서비스의 일부로 만드는 경우가 많다
    - 서비스 디스커버리는 대개 API레이어가 호스트하므로 유저 인터페이스나 다른 호출부 시스템에 모두 한곳을 통해 일관되고 탄력있게 서비스를 발견/생성할 수 있다

### 프런트 엔드 (프론트엔드 스타일/백엔드 아님)

- 마이크로서비스는 디커플링을 선호하기 때문에 백엔드 역시 유저 인터페이스(프론트엔드)와 분리되는 모습이 가장 좋다
- 초창기에는 DDD원칙에 출실하게 경계 콘텍스트의 일부로 포함되어 있었지만, 웹 애플리케이션 및 여타 제약조건에서 필요로 하는 분할의 실용성 때문에 이 목표는 달성하기 어렵다
    - 때문에 아키텍처의 유저 인터페이스는 보통 두 가지 스타일로 나타난다

<img src = "../img/IMG_5873.jpg" width = "600" height = "400">

- 위 이미지는 첫번째 스타일이며, 모놀리식 스타일이다
    - 유저 요청을 처리하기 위해 단일 유저 인터페이스가 API레이어를 통해 호출하는 모놀리식 프론트엔드 이다
    - 이 프런트엔드 리치 데스크톱(rich-desktop), 모바일, 웹 애플리케이션의 형태로 구현한다
    - 예를 들어 요즘은 자바스크립트 웹 프레임워크를 응용한 단일 유저 인터페이스로 개발하는 웹 애플리케이션이 대세이다

<img src = "../img/IMG_5874.jpg" width = "600" height = "400">

- 위 이미지는 두번째 스타일이며, 마이크로프론트엔드 스타일이다
    - 유저 인터페이스 레벨의 컴포넌트를 백엔드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리한다
    - 각 서비스는 자기 서비스에 해당하는 유저 인터페이스를 내보내고(emit), 프런트엔드는 그렇게 내보내진 유저 인터페이스 컴포넌트를 조정한다
    - 이런 식으로 유저 인터페이스에서 백엔드 서비스에 이르기까지 서비스 경계를 분리함으로써 전체 도메인을 단일 팀 내부에 통합시킨다
    - 마이크로프런트엔드 패턴은 개발자가 리엑트같은 컴포넌트 기반 웹 프레임워크를 사용하거나, 이 패턴을 지원하는 여러 오픈 소스 프레임워크 중 하나를 선택하는 등의 다양한 방법으로 구현할 수 있다

## 통신

- 마이크로서비스를 구축하는 아키텍트는 데이터 격리와 통신 모두에 영향을 미치는 적절한 세분도를 찾아야 한다
    - 올바른 통신 스타일을 발견하는 것 또한 팀이 서비스를 디커플링하면서 유용ㅇ한 방향으로 조정하는데 도움이 된다
    - 아키텍트는 동기로 할지, 비동기로 할지, 근본적인 통신 방식을 결정해야 한다
    - 일반적으로 마이크로서비스 아키텍처는 '프로토콜 인지 이종 간 상호 운용성(protocol-aware heterogeneous interoperability'를 활용한다

#### 프로토콜 인자(protocol-aware)

- 마이크로서비스는 운영 커플링을 방지하고자 중앙 통합 허비를 갖고 있지 않기 때문에 각 서비스는 다른 서비스를 호출하는 방법을 알고 있어야 한다
- 즉, 서비스는 다른 서비스를 호출할 때 어떤 프로토콜을 사용할지 알아야(또는 발견해야)한다
- 아키텍트는 여러 서비스가 상태방을 호출하는 방식(REST레벨, 메시지 큐등)을 표준화한다

#### 이종(heterogeneous)

- 마이크로서비스는 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있다
- 이종이란, 서비스마다 사용하는 플랫폼이 저마다 다른 폴리글랏(polyglot)환경을 완벽하게 지원한다는 뜻이다

#### 상호 운용성(interoperability)

- 여러 서비스가 서로 호출한다는 뜻이다
- 마이크로서비스에서 트랜잭셔널 메서드 호출은 권장하지 않지만, 어쨋거나 서비스 네트워크를 통해 다른 서비스를 호출하여 정보를 주고받으면서 협력해야 한다

#### 강화된 이종성(enforced heterogeneity)

- 마이크로서비스 스타일의 선구자였던 아키텍트가 고안한 방법이다
    - A팀은 자바, B팀은 닷넷 과 방식을 사용하면 클래스를 공유하는 일 따위는 절대 생기지 않게 할 수 있따
- 이 접근 방식은 단일 기술 스택으로 표쥰화를 고집하는 여느 엔터프라이즈 거번스 정책과는 정 반대이다
    - 마이크로서비스의 목표는 복잡다기한 생태계를 만든느 것이 아니라 문제의 범위를 최대한 좁혀 올바른 확장 기술을 선택하는 것이다
    - 모든 서비스가 대용량 관계형 데이터베이스를 필요로 하는 것은 아닌데 소규모 팀까지 무리하게 표준을 일관 적용ㅎ아면 이득은 거의 없고 속도만 더져진다
    - 고도의 디커플링을 추구하는 것이 마이크로서비스의 근본 사상이다

- 비동기 통신은 이벤트와 메시지를 주로 사용하며 내부적으로 이벤트 기반 아키텍처를 활용한다
    - 브로커 팬턴과 중재자 패턴은 마이크로서비스에서 각각 코레오그래피 패턴과 오케스트레이션 패턴으로 나타난다

### 코레오그래피와 오케스트레이션

- 코레오그래피(choreography)는 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일하다
    - 즉, 이 아키텍처는 중앙의 중재자가 따로 없고 경계 콘텍스트 철학에 출실하다
    - 따라사 아키텍트는 서비스 간에 분리된 이벤트를 구현하는 것을 자연스럽게 생각한다
- 도메인/아키텍처 동형성(domain/arhcitecture isomorphism)은 특정한 문제에 어떤 아키텍처 스타일이 얼마나 적합한지 평가할 때 아키텍트가 잘 살펴보아야 할 핵심 특성이다
    - 이 용어는 아키텍처의 형상(shape)이 특정 아키텍처 스타일에 어떻게 매핑되는지를 기술한다
    - 예를 들어, 실리콘 샌드위치(아래그림)의 기술 분할된 아키텍처는 구조상 맞춤성을 지원하고, 마이크로커널 아키텍처 스타일 역시 동일한 일반적인 구조를 갖고 있다
    - 그러므로 고도의 맞춤성이 필요한 문제는 마이크로커널 아키텍처로 구현하는 게 더 간편한다

<img src = "../img/IMG_5902.jpg" width = "600" height = "400">

- 마찬가지로, 마이크로서비스 아키텍트는 디커플링을 추구하므로 마이크로서비스이 형상은 브로커 이벤트 기반 아키텍처를 닮았고 두 팬턴은 서로 공생 관계이다
    - 코레오그래피에서 각 서비스는 중앙 중재자 없이 자신이 필요에 따라 다른 서비스를 호출한다 (아래그림)

<img src = "../img/IMG_5875.jpg" width = "600" height = "400">

- 위 이미지에서 유저는 유저 위시 리스트의 상제 정보를 요청한다
    - 하지만 피룡한 정보가 전 부다 CustomerWishList서비스에 있는 건 아니어서 CustomerDemegraphics서비스를 호출해 모자란 정보를 보충한 결과를 유저에게 반환한다
- 마이크로서비스 아키텍처는 서비스 지향 아키텍처처럼 전역 중재자를 따로 두지 않으므로 여러 서비스를 조정해야 할 경우 아래 그림처럼 스스로 로컬 중재자를 만들 수 있다

<img src = "../img/IMG_5876.jpg" width = "600" height = "400">

- 위 이미지에서 개발자는 주어진 고객의 전체 정보를 조회하는 호출을 조정하는, 이 일만 담당하는 서비스를 만든다
    - 유저가 중재자를 호출하면 이 중재자는 다른 서비스를 호출한다
- 어느 솔루션이든 완벽한 정답은 없고 각각 일장일단이 있다
    - 코로오그래피 아키텍트는 최대한 디커플링한다는 아키텍처 스타일의 철학을 고집함으로써 가장 많은 이점을 이끌어내려고 한다
    - 하지만, 에러 처리, 조정 같은 공통적인 문제는 코레오그래피 환경에서 훨씬 더 복잡해진다

<img src = "../img/IMG_5877.jpg" width = "600" height = "400">

- 위 이미지는 더 복잡한 워크플로의 예이다
    - 처음 호출된 섭시느느 자신의 다른 도메인 책임과 더불어 여러 타 서비스를 전체적으로 조정하는 중재재 역할도 겸한다
    - 이런 패턴을 `프런트 컨트롤러 패턴(front controller pattern)`이라고 한다
    - 어떤 서비스가 명목상 더 복잡한 중재자 노릇을 하는 셈인데, 이 패턴은 서비스 복잡도가 증가하는 단점이 있다

<img src = "../img/IMG_5878.jpg" width = "600" height = "400">

- 위이미지 처럼복잡한 비즈니스 프로세스는 위 이미지 처럼 오케스트레이션을 사용하는 방법도 있다
    - 비즈니스 워크플로에 필요한 복잡한 처리를 담당하면서 조정 역할도 수행하는 중재자를 두면 서비스간 커플링은 발생하지만 어느 한 서비스가 조정 작업을 전담하므로 다른 서비스는 거의 영향을 받지 않는다
    - 사실 도메인/워크플로는 내재적으로 커플링되는 경우가 많다
    - 아키텍트가 할일은 도메인과 아키텍처 두 마리 토끼를 모두 쫓는 방향으로 커플링을 가장 잘 나태낼 수 있는 방법을 찾는 것이다

### 트랜잭션과 사가

- 마이크로서비스 아키텍트는 극도의 디커플링을 갈망하지만 여러 서비스에 걸친 트랜젹선을 어떻게 조정하는 게 좋을지 고심에 빠질 때가 많다
    - 특히 분산 애플리케이션에서는 데이터 베이스 역시 동일한 수준의 디커플링이 필요하므로 모놀리식 애플리케이션에서 별 문자가 아니던 원자성 문제도 대두된다
- 서비스 경계를 넘나드는 트랜잭션은 그 자체로 마이크로서비스 아키텍처의 핵심 디커플링 원칙에 위배된다
    - 가장 나쁜 형태의 동적 커네이선스, 값 커네이선스를 유발한다
    - 여러 서비스에 걸쳐 트랜잭션을 걸고 싶어하는 경우 "그렇게 하지 말라!"라고 충고하고 싶다. 대신 컴포넌트 세분도를 바로 잡아야 한다
    - 이런 경우 십중팔구 설계를 지나치게 세분화한 경우가 많다
    - 하지만 예외는 있다
        - 이런 경우 트레이드 오프를 감수하고 트랜잭션 오케스트레이션을 처리하는 패턴이 있다

<img src = "../img/IMG_5879.jpg" width = "600" height = "400">

- 위 이미지는 사가 패턴(saga pattern)이다
    - 서비스는 여러 서비스 호출에 대해 중재자 노릇을 하면서 트랜잭션을 조정한다
    - 중재자는 트랜잭션을 구성하는 파트를 하니씩 호출 하여 성공/실패 여부를 기록하고 그 결과에 따라 흐름을 조정 한다
    - 만사가 계획대로 되면 서비스의 모든 값과 해당 데이터베이스 레코드는 동기 업데이트 된다
    - 어느 한 파트라도 실패하면 중재자는 전테 트랜잭션 파트가 모두 성공하지 못하게 해야 한다

<img src = "../img/IMG_5880.jpg" width = "600" height = "400">

- 위 이미지에서는 첫 번째 파트는 성공했지만 두 번째 파트가 실패한 경우, 중재자는 지금까지 성공한 모든 트랜잭션 파트에게 과거에 처리했던 내용을 언두(undo)하라는 요청을 보낸다
    - 이런 종류의 트랜잭션 조정을 `보상 트랜잭션 프레임 워크(compensating transaction framwork)`라고 한다
    - 이 패턴은 전체가 다 성송했다고 중재자가 알릴 때까지 중재자로부터 받은 각 요청을 보류 상태로 두는 식으로 구현 한다
    - 하지만 여기에 비동기 요청이 끼어들고, 특히 보류된 트랜잭션 상태에 따라 새로운 요청이 등장하면서 설계가 무척 복잡해 진다
    - 또 네트워크 레벨에서도 조정 트랙픽이 꽤 많이 발생한다
- 트랜잭션 작업마다 do/undo 로직을 개발하는 식으로 보상 트랜잭션 프레임워크를 구현할 수도 있다
    - 이렇게 하면 트랜잭션 수행 중 조정은 덜 필요하지만, 언두 작업은 두 작업보다 엄청나게 복잡해셔 설계, 구현, 디버깅 작업량 역시 2배이상 증가할 것이ㅏㄷ
- 여러 서비스에 트랜잭션을 걸어주는 것이 기술적으로 불가능한 건 아니지만, 이럴 거면 굳이 마이크로서비스 패턴을 선택할 이유가 없다
    - 정말 필요한 경우에만 사가 패턴을 조금씩 사용하는 것을 권한다

## 아키텍처 특성 등급

<img src = "../img/IMG_5881.jpg" width = "600" height = "700">

- 자동화 배포, 시험성, 그 밖에 이 등급표에 없는 것들을 비롯한 현대 엔지니어링 프랙티스를 이 아키텍처가 매우 훌륭하게 지원한다
- 마이크로서비스는 분산 아키텍처라서 런타임에 여러 조작ㄱ들이 연결되고 그로 인해 많은 결합에 시달린다
    - 따라서 서비스 간 통신을 과용하면 내고장성, 신뢰성이 위협을 받는다
    - 하지만 정상적인 상황에서 독립적인 단일 목적의 서비스는 내고장성이 높은 편이다
- 주안점은 확장성, 탄력성, 진화성이다
    - 지금까지 개발된 가장 확정성이 우수한 시스템 중에는 이 아키텍처 스탕리을 활용해서 성고을 거둔 사례가 많다
- 고도의 디커플링을 선호하기 때문에 아키텍처 레벨에서도 요즘처럼 점진적으로 변화하는 비즈니스 프랙티스를 훌륭하게 지원한다
- 성문 문제가 불거질 때가 많다
    - 분산 아키텍처 특성상 작업을 완료하기 위해 잦은 네트워크 호출을 해야 하므로 성능 오버헤드가 높고, 엔드 포인트마다 신원 및 접근 권한을 확인하는 보안 체크도 해야 한다
    - 과도한 네트워크 호출을 줄이고 성능을 개선하기 위해 데이터 캐시, 데이터 복제 등의 기술을 많이 사용한다
    - 커플링이 적을수록 통신 속도가 증가하고 병목이 줄기 때문에 오케스트레이션보다는 코레오그래피를 더 많이 사용한다 