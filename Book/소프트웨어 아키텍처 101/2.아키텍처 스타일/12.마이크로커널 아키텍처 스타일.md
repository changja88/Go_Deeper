## 마이크로커널 아키텍처 스타일

- 수십년전에 만들어진 플러그인 아키텍처(plug-in architecture)라고도 하는 마이크로커널 아키텍처(microkernel architecture)는 오늘날에도 널리 쓰이고 있다
- 이 아키텍처 스타일은 (단일 모놀리식 배포 단위로 패키징해서 다운로드 및 설치가 가능하며, 보통 고객 사이트에서 서드파티 제품으로 설치되는)제품 기반 애플리케이션에 적합하며 비제품 고객 비즈니스 애플리케이션에서도
  많이 사용된다

### 토폴로지

<img src = "../img/IMG_5756.jpg" width = "600" height = "400">

- 마이크로커널 아키텍처 스타일은 코어 시스템(core system)과 플러그인 컴포넌트(plug-in component)라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모놀리식 아키텍처이다
- 애플리케이션 로직은 독립적인 컴포넌트와 기본 코어 시스템에 골고루 분산되어 확장성, 적응성, 애플리케이션 기능분리, 커스텀 처리 등을 수행한다

### 코어 시스템

- 코어 시스템은 시스템을 싱행시키는 데 필요한 최소한의 기능으로 정의한다
    - ex) 이클립스 코어 시스템은 파일을 열고, 텍스트를 고치는 에디터에 불과하지만, 플로그인을 추가해야 비로소 쓸 만한 제품이 된다
- 코어시스템은 처리가 거의/전혀 필요 없는 애플리케이션을 관통하는 정상 경로(happy path)라고 정의할 수 있다
- 코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성은 물론 시험성도 좋아진다

```
public void assessDevice(String deviceID){
    if(deviceID.equals("iPhone6s)) assessIPhone6s();
    else if(deviceID.equals("iPad1)) assessiPad1();
    else if(deviceId.equals('Galaxy5) assessGalaxy5();
    ...
}
```

- 제품을 구분하여 접근하기 위해서는 위와 같은 코드가 필요하다.
    - 클라이언트에 종속된 코드를 순환 복잡도가 높은 코어 시스템에 두는 대신, 각 제품마다 플러그인 컴포넌트를 따로 만들어 감정하면 더 효율적이다
    - 개별 클라이언트 플러그인 컴포넌트를 만들어 끼우면 나머지 처리 흐름과 무관한 로직을 따로 떼어낼 수 있어 차후 확장도 가능하다
    - 마이크로커널 아키텍처는 위 코드를 아래와 같이 코어 시스템이 해당 제품의 플러그인을 찾아 호출하는 방식으로 고칠 수 있다(아래코드)

```
public void assessDevice(String deviceID){
    String pulgin = pluginRegistry.get(deviceID);
    Class<?> theClass = Class.forName(plugini);
    Constructor<?> constructor = theClass.getConstructor();
    DevicePlugin devicePlugin = (DevicePlugin)constructor.newInstance();
    DevicePlugin.assess();
}
```

- `즉, 일체의 복잡한 규칙과 로직을, 코어 시스템에서 일반화하여 실행 가능한, 독립적인 스탠드얼론 플러그인 컴포넌트에 담는다`

<img src = "../img/IMG_5757.jpg" width = "1000" height = "400">

- 코어 시스템은 규모와 복잡도에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있다
- 경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나누어 서비스별 도메인에 특정한 플로그인 컴포넌트를 둘 수도 있다
    - 예를 들어 Payment Processing이 코어 시스템을 나타내는 도메인이라면, 결제 도메인에 특정한 각 결제수단(신용카드, 페이팔, 선불카드)이 플로그인 컴포넌트가 된다
    - 어떤 경우에도 전테 모놀리스 애플리케이션은 하나의 데이터베이스를 공유하는 것이 보통이다

<img src = "../img/IMG_5759.jpg" width = "1000" height = "800">\
- 코어 시스템의 프레젠테이션 레이어는 코어 시스템에 내장하거나 별도의 UI로 구현하고 코어 시스템은 백엔드 서비스를 제공한다 
- 실제로 별도의 UI를 마이크로 커널 아키텍처 스타일로 구현할 수도 있다

### 플러그인 컴포넌트

- 플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 코어 시스템을 개선/확장 하기 위한 커스텀 코드가 구현된 `스탠드얼론` 컴포넌트이다
    - 변동성이 매우 큰 코드를 분리하여 애플리케이션 내부의 유지보수성, 시험성을 높이며, 이상적인 플러그인은 상호 독립적이며 의존성이 없다
- 플러그인 컴포넌트와 코어 시스템은 일반적으로 점대점(point-to-point)통신을 한다
    - 즉 코어 시스템에 플러그인을 연결하는 '파이프' 대부분 플러그인의 진입점 클래스를 호출하는 메서드나 함수이다
- 플러그인은 컴파일 기반 또는 런타임기반으로 만들 수 있다
    - 런타임 플러그인 컴포넌트는 런타임에 코어 시스템이나 다른 플러그인을 재배포하지 않고도 바로 추가/삭제가 가능하다
    - 자바 OSGI(Open Service Gateway Initiative), 펜로즈(Penrose), 직소(Jigsaw)등의 프레임워크를 사용한다
    - 컴파일 기반의 플러그인은 편하지만, 변경, 추가, 삭제 시 전체 애플리케이션을 재배포해야 한다

<img src = "../img/IMG_5760.jpg" width = "700" height = "400">

- 점대점 플로그인 컴포넌트는 (JAR, DIL, GEM)같은 공유 라이브러리, 패키지명(자바), 네임스페이스(C#)으로 구현할 수 있다

<img src = "../img/IMG_5762.jpg" width = "800" height = "400">

- 위 이미지처럼 플러그인이 코어 시스템과 반드시 점대점 통신을 해야 하는 것은 아니다
    - 각 플러그인을 스탠드 얼론 서비스로 만들어 REST나 메시징 등 다른 방법으로 기능을 호출하는 방법도 있다
    - 언뜻 보기에는 전체 확장성을 개선하는 좋은 방법 같지만, 코어 시스템이 모놀리식이므로 여전히 단일 아키텍처 퀀텀이며, 모든 요청이 코어를 거쳐 각 플러그인 서비스로 흘러가는 구조이다
    - 플러그인을 개별 서비스로 구현해서 원격 엑세스 하는 방법도 있다
        - 이 방법은 커플링이 확 낮아져 확장성과 처리량이 개선되고 OSGI, 직소 등의 특수한 프레임워크 없이도 런테임 변경이 가능한 장점이 있다
        - 또한 비동기 통신도 가능해진다
        - 단점으로는 마이크로커널 아키텍처를 모놀리식이 아닌 분산 아키텍처로 바꿔야 하는데 있다
            - 구현/배포가 쉽지 않아진다
            - 전반적으로 복잡도와 비용이 높아 진다
            - 플러그인이 무응답이거나 작동되지 않은 경우

<img src = "../img/IMG_5763.jpg" width = "900" height = "400">

- 플러그인이 데이터베이스에 직접 접속할 일은 거의 없으며 이는 디커플링을 위함이다
    - 코어 시스템이 그 역할을 담당하며 필요한 데이터를 모두 가져와 각 플러그인에게 전달한다
    - 데이터베이스를 변경하는 행위는 코어 시스템에게만 영향을 미친다
    - 따라서 각 플러그인은 자기만 액세스 가능한 데이터 저장소를 따로 가질 수 있다

### 레지스트리

- 코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알고 있어야 한다
    - 일반적인 구현방법은 플러그인 레지스트리(registry)를 경유하는 방법이다
- 레지스트리
    - 플러그인 명칭, 데이터 계약 (플러그인에서 코어 시스템으로 접속하는 방법별)세부 원격 액세스 프로토콜 등 정보가 있다
    - ex) 세무 플러그인에는 서비스명(AuditChecker), 데이터 계약(입력 데이터, 출력 데이터), 계약 포맷(XML) 정보가 담긴 레지스트리가 있다
    - 간단하게 내부에 맵 구조로 존재할 수도 있고
    - (아파치 주키퍼나 콘술처럼) 레지스트리 및 디스커버리 도구가 외부에 배포된 시스템에 내장된 복잡한 형태일 수도 있다
    - 아래 코드는 내부 구현 형태이다

```
Map<String, String> registry = new HashMap<String, String>();
static{
    // 점대점 액세스 에제 코드
    registry.put("iPhone6s", "Iphone6sPlugin");
    // 메시징 예제 코드
    registry.put("iPhone6s", "iphone6s.queue");
    // REST형 예제 코드
    registry.put("iPhone6s", "https://atlas:443/assess/iphone6s");
}
```

### 계약

- 플러그인과 코어 시스템 간의 게약은 보통 플러그인 도메인 단위로 표준화되어 있고 플러그인이 수행하는 기능 및 입출력 데이터 계약에 명시되어 있다
- 서드파티와 같이 플러그인 계약을 바꿀 수 없을 때는 보통 커스텀 계약을 사용하며, 일반적으로 코어 시스템이 각 플러그인별 코드를 필요로 하지 않도록 플러그인 계약과 커스텀 계약 간의 어댑터를 만든다
- 플러그인 계약은 플러그인과 코어 시스템이 서로 주고받는 XML, JSON, 또는 객체로 구현다 (아래코드)

```
public interface AssessmentPlugin{
    public AssessmentOutput assess();
    public String register();
    public deregister();
}
public class AssessmentOutput(){
    public String assessmentReport;
    public Boolean resell;
    public Double value;
    public resellPrice;
}
```

- 위 코드는 표준 자바 인터페이스 AssessmentPlugin으로 구현한 게약이며, 플러그인 컴포넌트가 출력하리라 기대하는 데이터(AssessmentOutput)을 정의하고 있다
- 주의해서 봐야 할 점은, 코어 시스템은 단지 감정 리포트를 출력하거나 유저에게 보여주는 일만 할 뿐, 감정 리포트의 세부 내용을 포맷팅하고 이해하는 것은 코어 시스템의 책임이 아니다
    - assessmentReport가 AssessmentOutput(플러그인)에 있다

### 실제 용례

- 이클립스, 지라, 젠킨스, 크롬, 파이어폭스 등이 마이크로커널 아키텍처를 사용하여 개발 되었다
- 마이크로커널 아키텍처는 대규모 비즈니스 애플리케이션에도 적용할 수 있다
- ex) 보험 회사
    - 보험금 청구 프로세스는 관할 구역마다 보험금 청구시 허용/금지된 규치고가 규정이 제각기앋
    - 아주 크고 복잡한 규칙 엔진을 이용해서 복잡한 로직을 처리하지만, 자칫 이 규칙 엔진이진흙잡탕이 되어 규칙 하나를 변경하면 다른 규칙들을 연쇄적으로 빙구로 만들 수도 있다
    - 이런 경우 마이크로커널 아키텍처 패턴이 활용 될 수 있다
    - 관할 구역별 보험금 청구 규칙을 별도의 스탠드얼론 플러그인 컴포넌트에 보관한다

### 아키텍처 특성 등급

<img src = "../img/IMG_5764.jpg" width = "500" height = "600">

- 레이어드 아키텍처처럼 단순성과 전체 비용이 주요 강점이다
- 고질적인 모놀리식 배포 탓에 탄력성, 내고장성, 확장성이 문제가 될 때가 많다
- 모든 요청은 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가므로 퀀텀은 언제나 1이다
- `도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일이다`
- 기능을 독립적인 플러그인으로 분리가 가능하기 때문에 시험성, 배포성, 신뢰성은 평균보다 높다 