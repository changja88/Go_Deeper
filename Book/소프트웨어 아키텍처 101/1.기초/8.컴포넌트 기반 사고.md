## 컴포넌트 기반 사고

- (내 생각)
    - 컴포넌트를 구성 할 때 가장 중요한 것은 세분도를 확인 하는 것이다
    - 세분도(granularity)라는 것은 컴포넌트가 너무 충분히 잘게 나누어 졌는가를 확인 하는 것이다
    - 예를 들어서 '권한 부여' 컴포넌트 라고 했을 때 너무 덩어리지지는 않았는가? 를 고민해 봐야한다

- `3장에서 모듈을 연관된 코드의 묶음이라고 했지만, 아키텍트는 보통 모듈을 물리적으로 구현한 컴포넌트로 생각한다`
- 개발자는 모듈을 물리적으로 패키징한다. 물리적으로 패키징한 것을 컴포넌트라고 한다. 이장에서는 컴포넌트에 관한 아키텍처 고려 사항을 알아본다

## 8.1 컴포넌트 범위

- 가장 단순한 컴포넌트는 클래스보다 한 단계 높은 수준의 모듈로 코드를 래핑한 것이다. 이 단순한 래퍼를 보통 라이브러리라고 한다
- `컴포넌트는 아키텍처에서 서브시스템이나 레이어 형태로도 나타나며, 많은 이벤트 프로세서를 위한 배포가능한 작업 단위이다`
- `서비스는 또 다른 종류의 컴포넌트로서 자신의 주소 공간에서 실행되며 TCP/IP같은 저수준 네트워크 프로토콜이나 고수준 포맷을 통해 통신한다. 마이크로서비스 아키텍처에서 서비스는 배포 가능한 독립적인 단위를 형성한다`

<img src = "../img/IMG_5675.jpg" width = "600" height = "400">

- 아키텍트가 반드시 컴포넌트를 사용해야 하는 것은 아니다. 컴포넌트는 언어가 제공하는 저수준이 아닌, 더 높은 수준에서 모듈성을 가지는 것이 더 유용할 떄가 많다
- 마이크로서비스의 경우 아키텍처에서 단순성은 아키텍처 원칙 중 하나이므로 위 이미지 처럼 컴포넌트가 될 정도의 충분한 코드로 구성하거나, 적은 양의 코드만 담도록 단순하게 설계하는 것이 좋다

### 내 생각

- 모듈은 논리적, 물리적 범위를 모두 포함하는 뜻이고, 컴포넌트는 물리적 범위만 포함하는 것

## 8.2 아키텍트 역할

- 아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 일을 한다
- 컴포넌트는 아키텍트에게 최하위 소프트웨어 시스템이다. 컴포넌트의 구현은 기술 리더나 개발자가 담당한다
    - 아키텍트는 클래스 설게에 참여해서도 안되고 시스템의 세세한 설계 결정에 관여해서도 안된다

### 8.2.1 아키텍처 분할

<img src = "../img/IMG_5676.jpg" width = "600" height = "400">
<img src = "../img/IMG_5677.jpg" width = "600" height = "400">

- 컴포넌트는 일반적인 적재(containership)메커니즘을 의미하므로 아키텍트는 재량껏 어떤 유형의 분할도 할 수 있다
- 아키텍처 스타일은 2부에서 자세히 다룬다. 여기에서는 최상위 분할 이라는 중요한 스타일만 설명한다
- 레이어드 아키텍처와 모듈러식 아키텍처는 최상위 분할이고, 최상위 분할은 근본적인 이키텍처 스타일과 코드 분할 방법을 결정짓기 때문에 아키텍트에게 중요하다

### 8.2.3 분할 사례 연구: 실리콘 샌드위치

- 컴포넌트 도출 시 아키텍트는 기본적으로 최상위 분할을 어떻게 할지 결정해야 한다

<img src = "../img/IMG_5679.jpg" width = "900" height = "400">

- 위 이미지는 실리콘 샌드위치를 도메인 분할 방식으로 설계한 것이다
- 도메인/워크플로 별로 각각 purchase, promotion, makeorder, manageinventory, recipes, delivery, location 컴포넌트를 도출 했고,
- 공통 기능과 로컬 변형을 다루는 갖가지 유저 정의 코드를 처리하는 서브컴포넌트를 이들 컴포넌트 안에 두었다

<img src = "../img/IMG_5680.jpg" width = "900" height = "400">

- 위 이미지는 공통 및 로컬 파트를 각 파티션으로 분리한 설계이다
- 최상위 컴포넌트는 Common과 Local이고 워크프로는 Purchase와 Delivery로 처리한다
- 어느 설계가 더 좋을까? 당연히 경우에 따라 다르다
- 도메인 분할 : 도메인 분할 아키텍처는 최상위 컴포넌트를 워크플로 및(또는) 도메인에 따라 나눈다
    - 장점
        - 세부 구현보다 비즈니스 기능에 더 가깝게 모델링 된다
        - 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉽다
        - 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다
        - 메시지 흐름이 문제 영역과 일치한다
        - 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다
    - 단점
        - 유저 정의 코드가 여기저기 널려 있다
- 기술 분할 : 기술 분할 아키텍처는 최상위 컴포넌트를 개별 워크플로가 아닌, 기술적인 능력에 따라 분리하므로 모델-뷰-컨트롤러(MVC)또는 상황에 맞게 레이어로 나타낼 수 있다
    - 장점
        - 커스텀 코드가 명확하게 분리된다
        - 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있따
    - 단점
        - 전역 커플링이 더 높다. 따라서 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 다른 모든 컴포넌트가 영향을 받을 가능성이 높다
        - 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다
        - 일반적으로 데이터 레벨의 커플링이 높다. 이런 시스템은 대게 애플리케이션 아키텍트, 데이터 이키텍트가 서로 협력하여 단일 데이터베이스를 구성하고 여기에 각종 도메인을 포함시키기 때문에 나중에
          아키텍트 분산 시스템으로 아키텍처를 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어렵다

## 8.3 개발자 역할

- 개발자는 아키텍트와 공동 설계한 컴포넌트를 바탕으로 클래스, 함수, 서브컴포넌트로 더 잘게 나눈다
- 일반적으로 클래스, 함수 설계는 아키텍트, 기술 리더, 개발자의 공동 책임이지만 대부분 개발자가 담당한다
- 개발자는 아키텍트가 설계한 컴포넌트가 최종판이라고 생각해서는 안된다. 점점 다듬어 개선해야 한다

## 8.4 컴포넌트 식별 흐름

<img src = "../img/IMG_5681.jpg" width = "900" height = "400">

- 컴포넌트 식별은 피드백을 통해 다음어가는 과정을 반복하는 것이 좋다

### 8.4.1 초기 컴포넌트 식별

- 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다

### 8.4.2 요구 사항을 컴포넌트에 할당

- 컴포넌트에 요구사항을 대입해서 잘 맞는지 확인해야 한다
- 이과정에서 컴포넌트를 새로 만들거나 기존 컴포넌트를 통합하고 하는일이 너무 많은 컴포넌트는 분해할 수 있다

### 8.4.3 역할 및 책임 분석

- 컴포넌트에 스토리를 대입할 때 아키텍트는 요구사항을 파악하는 단게에서 밝혀진 역할과 책임도를 살펴보고 세분도가 적합한지 확인한다
- `아키텍트가 하는 가장 어려준 일 중 하나가 컴포넌트의 세분도를 정확히 짚어내는 것이다. 그래서 이터레이션 과정이 필요하다`
- 세분도: 세분화한 정도, 즉 얼마나 잘게 나누었는가

### 8.4.4 아키텍처 특성 분석

- 요구사항을 대입할 때 앞서 식별한 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴봐야 한다

### 8.4.5 컴포넌트 재구성

- 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 한다
- 컴포넌트 설계를 반복하는 접근 방식이 중요한다
    - 차후 재설계를 하게 만들지 모를 모든 발견과 특이 사례를 전부 다 고려하기란 사실상 불가능 하다
    - 아키텍처와 갭라작 애플리케이션 구축에 점점 더 깊이 빠질수록 서로 기능과 역할을 어떻게 조정하면 좋을지 서로 다른 시각으로 바라보게 된다

## 8.5 컴포넌트 세분도

- 컴포넌트에서 가장 적당한 세분도를 찾는 것은 아키텍트의 가장 어려운 작업 중 하나이다
    - 컴포넌트를 너무 잘게 나누어 설계하면 컴포넌트 간 통신이 너무 많아지고
    - 너무 크게 나누면 내부적으로 커플링이 증가해서 배포, 테스트가 어려워 지고 모듈성 관점에서도 부정적인 영향을 미친다

## 8.6 컴포넌트 설계

- 컴포넌트 설계에 왕도는 없다. 일반적인 방법과 하지 말아야 할 사항을 알려주겠다

## 8.6.1 컴포넌트 발견

- 아키텍트는 개발자, 비즈니스 분서가, 도메인 전문가와 협력해서 시스템에 관한 일반적인 지식과 시스템을 어떻게 분할할지 결정하고 그에 따라 초기 컴포넌트를 설계한다

<img src = "../img/IMG_5682.jpg" width = "900" height = "400">

- 엔티티 함정
    - 컴포넌트를 확정하는 문제는 정답은 없지만, `엔티티 함정` 안티패턴은 자주 나오니 조심해야 한다
    - 예를 들어 위 이미지 처럼 설계했다고 했을 경우
        - 이것은 아키텍처가 아니다
        - 이것은 프레임워크를 데이터베이스에 컴포넌트 관계형으로 매핑한 것에 불과하다
        - 다시말해 단순 CRUD기능만 필요한 시스템은 아키텍트가 프레임워크를 내려 받아 데이터베이스에서 직접 유저 인터페이스를 생성할 수 있다
        - `엔티티 함정은 아키텍트가 데이터베이스 관계를 애플리케이션의 워크플로로 오해할 때 벌어진다`
        - 엔티티 함정에 빠져 생성된 컴포넌트는 너무 큼지막하게 나뉘어지기 때문에 소스 코드의 전체적인 구조와 패키징 관점에서 개발팀에게 지침이 될 만한 것이 하나도 없다
- `액터/액션 접근법 (actor/actions approach)`
    - 아키텍트가 요구사항을 컴포넌트에 매핑할 때 즐겨 쓰는 방법이다
    - `애플리케이션에서 뭔가 일을 하는 액터와 그들이 수행하는 액션을 식별하고 시스템의 대표적인 유저와 이들이 시스템에서 어떤 종류의 일을 하는지 찾아내는 기법이다`
    - 이 방법은 선행 설계(upfront design)를 매우 선호하는 공식적인 프로세스와 맞물려 인기를 얻었다
- `이벤트 스토밍 (event storming)`
    - 이벤트 스토밍은 도메인 주도 설계에서 사용되는 컴포넌트 발견 기법이다
    - 이벤트 스토밍을 하는 프로젝트는 다양한 컴포넌트가 메시지나 이벤트를 이용해 서로 통신한다고 가정한다. 따라서 팀은 요구사항과 식별된 역할에 따라서 시스템에서 어떤 이벤트가 일어나는지 파악하고 컴포넌트를
      이벤트와 메시지 핸들러 중심으로 구축한다
    - 이 방법은 최종 일관적인 시스템에서 사용할 메시지를 아키텍트가 정의하는 데 도움이 되므로 이벤트와 메시지를 사용하는 마이크로서비스 같은 분산 아키텍처에서 주효하다
- `워크플로 접근법(workflow apporach)`
    - 워크플로 접근법은 이벤트 스토밍의 대안으로서 DDD나 메시징을 사용하지 않는, 더 일반화한 방법이다
    - 워크플로 기반의 컴포넌트 모델링은 이벤트 스토밍과 비슷하지만 메시지 기반 시스템을 구축하는 데 있어서 명시적은 제약조건은 없다
    - 워크플로 접근법은 핵심 역할을 식별하고 이 역할이 관연하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 컴포넌트를 구축한다

## 8.7 컴포넌트 발굴 사례 연구: GGG

<img src = "../img/IMG_5686.jpg" width = "900" height = "600">

- 특별한 제약이 없고 범용적인 컴포넌트 분할을 고려하고 있다면 액터/액션 접근법이 일반적으로 괜찮은 솔루션이다
- 이 예제에서는 액터/액션을 적용 했다
- 액터/액션 세트는 다음과 같다
    - Bidder : 라이브 동용상 스트림과 라이브 입찰 스트림을 보고 입찰한다
    - Auctionner : 라이브 입찰을 시스템에 입력하고, 온라인 입찰을 수신하며, 아이템을 팔린 것으로 표시한다
    - System : 경매를 시작하고, 결제를 처리하고, 입찰자 활동을 추적한다
    - 이를 바탕으로 컴포넌트 세트를 구성하면 위 이미지(왼쪽)와 같다
- 이미지에서 각 역할 및 액션은 어느 한 컴포넌트에 매핑되어 서로 협력하면서 정보를 주고받는다. 다음은 이 솔루션에 맞게 식별한 컴포넌트들 이다
    - VideoStreamer : 유저에서 라이브 경매를 스트리밍한다
    - BidStreamer : 입찰이 발생하면 즉시 유저에게 스트리밍한다. VideoStreamer와 BidStreamer는 입찰자에게 읽기 전용 경매 뷰를 제공한다
    - BidCapture : 경매인 입찰자 양쪽에서 입찰을 캡쳐한다
    - BidTracker : 입찰을 추적하는 기록 시스템 역할을 한다
    - AuctionSession : 경매 세션을 시작/종료한다. 입찰자가 경매를 끝내면 결제를 처리하고 그 결과를 입찰자에게 알려주는 등 후속 조치를 한다
    - Payment : 신용카드 결제를 처리하는 서드파티 결제 프로세서
- 물론 이게 최종본은 아니도 지속적으로 발전해야 한다

## 8.8 아키텍처 퀀텀 딜레마: 모놀리식이냐, 분산 아키텍처냐

- `초기 컴포넌트 설계를 마친 아키텍트는 중요한 결정(모놀리식 아키텍처로 갈 것인가, 분산 아키텍처로 갈 것인가를)에 직면한다`
- 아키텍처 스타일은 저마다 다양한 트레이드오프가 있다. 그러나 근본적인 결정은 설계 프로세스 중 식별된 아키텍처 퀀텀 수에 좌우된다
    - 만약 시스템이 단일 퀀텀(즉, 한세트의 아키텍처 특성)만으로 가능하다면 모놀리스 아키텍처가 장점이 더 많다
    - 반면 컴포넌트마다 아키텍처 특성이 달라지는 경우에는 이를 수용할 수 있는 분산 아키텍처가 필요하다 
- `아키텍처 퀀텀을 활용하면 초기 설계 단게에서 아키텍처의 근본적인 설계특성(모놀리스냐 분산이냐)를 결정할 수 있다`