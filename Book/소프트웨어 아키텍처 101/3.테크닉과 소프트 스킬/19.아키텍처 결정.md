## 아키텍처 결정

- 아키텍트는 아키텍처 결정을 내리지만, 기술이 아키텍처 특성에 영향을 미치는 경우 기술 결정역시 역할이 될 수 있다
- 어떤 맥락이든지 아키텍트가 내린 올바른 결정은 개발팀이 정확한 기술을 선택할 수 있는 발판이 된다

## 아키텍처 결정 안티패턴

- 안티패턴이란
    - 처음에는 좋은 생각처럼 보이지만 이 내 곧 문제가 되는 애물단지라고 정의한다
    - 부정적인 결과를 내는 반복 가능한 프로세스
- 자주 발생하는 안티패턴
    - 네 패를 먼저 보여주지마 (Covering Your Assets)
    - 무한반복 회의 (Groundhog Day)
    - 이메일 기반 아키텍처 (email-driven architecture)
    - 보통 안티패턴은 누적되어 발전하는 경향이 있다. 1번 극복하면 2번 시작. 결국 모두 극복해야 한다

### '네 패를 먼저 보여 주지마' 안티패턴

- 아키텍트가 잘못된 선택을 하는 것을 두려워한 나머지 아키텍처 결정을 회피하거나 미루는 현상을 말한다

#### 극복 방법

- 1> 어떤 중요한 아키텍처 결정을 내리기 전, 마지막으로 책임질 수 있는 순간(last responsible momnet)까지 기다리는 것이다
    - 자신의 결정을 정당화하고 검증하기 위해 충분한 정보를 수집할 때까지 기다리지만, 개발팀을 마냥 붙잡아 두거나 분석 마지 안티패턴에 빠질 정도로 오래 기다리지는 않음을 의미한다
- 2> 개발팀과 지속적으로 협력하면서 아키텍트가 결정한 내용을 원래 의도한 대로 추진한다
    - 세부적인 기술에 관한 모든 이슈를 아키텍트 혼자 전부 다 알 수는 없기 때문에 개발팀의 협력은 절대적으로 필요하다
    - 그래야 나중에 문제가 생겨도 재빠르게 대응할 수 있다

### '무한반복 회의' 안티패턴

- '네 패를 먼저 보여주지마' 안티패턴을 극복하면 이어서 '무한반복 회의' 안티패턴으로 이어진다
- 발생하는 이유는 아키텍트가 자신이 내린 결정을 정당화하는 데 실패했기 때문이다
    - `어떤 아키텍처 결정이건 그것을 정당화할 때에는 비즈니스 가치를 제시하는 것이 중요하다`
    - 그렇게 해야 그 아키텍처 결정을 정말 다른 무엇보다 우선해야 하는지 한 번 더 돌아볼 수 있다
    - 가장 일반적인 비즈니스 정당화로는 비용, 출시 시기, 유저 만족도, 전략적 포지셔닝 등이 있다

### '이메일 기반 아키텍처' 안티패턴

- 이제 '이메일 기반 아키텍처'가 등장할 차례이다
    - 사람들이 아키텍처 결정을 놓치거나 잊어버리고 심지어는 그렇게 결정됐다는 사실조차 알지 못해 아키텍처 결정을 구현하지 못하는 상태이다
    - 즉, 아키텍처 결정을 효과적으로 전달하는 문제와 관련된 안티패턴이다
    - 이메일은 훌륭한 소통 수단이지만 문서 저장 체계로는 형편없다

#### 극복방법

- 1> 이메일 본문에 아키텍처 결정을 포함시키지 않는다
    - 이메일 본문에는 아키텍처 결정의 본질과 맥락 정도만 언급하고 세부 정보는 단일 기록 시스템에 보관하고 링크만 첨부한다
- 2> 아키텍처 결정에 정말 관심있는 사람에게만 통지한다
    - 그 사람에게 직접적인 영향이 없다면 굳이 그 사람을 성가시게할 이유가 없다

## 아키텍처적으로 중요한

- 아키텍처 결정에 기술적인 내용이 포함되면 그것은 아키텍처 결정이 아니라, 기술 결정이라고 단정짓는 아키텍트들이 많지만 반드시 그런 것은 아니다
    - 아키텍트가 어떤 기술을 사용하기로 결정을 했고 그 기술을 어떤 아키텍처 특성을 직접 지원하기 위해 선택한 것이라면 이는 아키텍처 결정이 맞다
- 아키텍처적으로 중요한 결정이란 구조, 비기능 특성, 의존성, 인터페이스, 구현 기술에 영향을 미치는 결정이다
    - 구조(structure)는 사용 중인 아키텍처의 패턴이나 스타일에 영향을 미치는 결정들이다. 일례로 마이크로서비스 간에 데이터를 공유하기로 한 결정은 마이크로서비스의 경계 콘텍스트는 물론 애플리케이션
      구조에도 영향을 미친다
    - 비기능 특성(nonfunctional characteristic)은 개발 또는 유지보수 중인 애플리케이션이나 시스템이 중요한 아키텍처 특성들이다. 만약 어떤 기술을 선택하느냐에 따라 성능이 달라지고 성능이
      애플리케이션의 중요한 팩터일 경우, 아키텍처 결정이다
    - 의존성(dependency)은 전체 확장성, 모듈성, 민첩성, 시험성, 안전성 등에 영향을 미치는 시스템 내부의 컴포넌트와 서비스 간의 커플링 지점을 가리킨다
    - 인터페이스(interface)는 게이트웨이, 통합 헙, 서비스 버스, API 프록시를 통해 서비스와 컴포넌트에 액세스하고 조정하는 수단ㅇ늘 말한다. 계약 버저닝, 버전 구식화 전략 등 계약에 정의된 내용이
      곧 인터페이스이다. 인터페이스는 시스템을 사용하는 다른 부분에도 영향을 미치므로 아키텍처적으로 매우 중요하다
    - 구현 기술(construction technique)은 원래 그 자체는 기술적인 것이지만, 아키텍처의 많은 부분에 영향을 미치는 플랫폼, 프레임워크, 도구, 프로세스에 관한 결정이다

## 아키텍처 결정 레코드

- 아키텍처 결정을 가장 효과적으로 문서화하는 방법은 바로 아키텍처 결정 레코드(ADR, Architecture Decision Record)이다
- ARD은 마이클 나이가드의 블로그 게시글에 처음 소개됐고 이후 쏘우트웍스 기술 레이더에서 채택됨으로 표시됐다
- ADR은 아키텍처 결정이 기술된(보통 한 두 페이저)짧은 텍스트 파일로, 일반 텍스트로 작성할 수도 있지만 대게 아스키독(AscillDoc)이나 마크다운같은 텍스트 문서 포맷또는 위키 페이지 템플릿으로 작성한다
- ADR을 관리하는 도구도 있다
    - '테스트 주도 개발로 배우는 객체 지향 설계와 실천'의 공저자인 냇 프라이스는 ADRD-tools라는 전용 오픈소스 도구를 개발했다

### 기본구조

- ADR의 구조는 제목, 상태, 콘텍스트, 결정, 결과 5개의 섹션으로 구성된다. 여기에 컴플라이언스(compliance)와 노트(Notes)라는 추가 섹션을 덧붙인다
    - 필요시 섹션을 추가하는 방법으로 기본 구조를 확장하는 식으로 템플릿을 간명하게 유지할 수 있다

#### 제목

- ADR 제목은 일련 번화와 함께 아키텍처 결정을 짧고 간결하게 기술한다
- 예를 들어 주문 서비스와 결제 서비스가 서로 비동기 메시징을 사용하기로 결정했다면 '42. 주문 서비스와 결제 서비스 간의 비동기 메시징 사용' 정도의 제목을 쓴다

#### 상태

- ADR 상태는 제안됨(Proposed), 수락됨(Accepted), 대체됨(Superseded)로 표시한다
- '제안됨'은 해당 결정이 상위 레벨의 의사 결정권자 또는 아키텍처 거버넌스 협의체의 승인을 득해야 하는 상태이다
    - 즉, 제안됨 상태의 ADR은 다른 ADR로 대체되는 일 없이 수락됨 상태가 될 때까지 계속 수정된다
- '수람됨'은 결정이 승인되어 구현할 준비가 된 상태이다
- '대체됨'은 결정이 번복되어 다른 ADR에 의해 대체된 상태로, 이전 ADR 상태는 수락됨 상태여야 한다
    - 이상태는 어떤 결정이 내려졌고, 당시 왜 그런 결정을 했는지, 새로운 결정은 무엇이고 어쩌나 변경을 하게 됐는지 등에 관한 이력을 보관하는 강력한 수단이다
    - 일반적으로 어떤 ADR이 대체되면 그 ADR을 대체한 결저잉 병기되며, 반대로 다른 ADR을 대체한 결정은 자신이 대체한 ADR이 병기된다
    - 예를 들어 ADR 42는 이미 전에 승인됐지만 이후 결제 서비스의 구현체 및 위치가 바뀌어 두 서비스 간 통신을 REST로 변경하기로 했다면(ADR 68)상태는 다음과 같다
    - ```
      ADR 42. 주문 서비스와 결제 서비스 간의 비동기 메시징 사용
      상태: 68로 대체됨
      ADR 68. 주문 서비스와 결제 서비스 간의 REST 사용
      상태: 수락됨. 42를 대체함
      ```

#### 콘텍스트

- ADR 콘텍스트 섹션은 불가항력적인 요소를 특정한다. 다시 말해 '어떤 사정 때문에 그렇게 결정할 수밖에 없었나?'에 관한 것이다
    - 특수한 상황이나 문제점을 이야기하고 다른 대안에 대해 상술한다
    - 각 대안을 상세히 분석한 문서가 필요한 경우, 콘텍스트 섹션 대신 ADR에 대한 섹션을 추가한다
- 아키텍처를 문서화하는 수단이기도 하다. 콘텍스트를 기술함으로써 곧 아키텍처를 기술하는 것이다

#### 결정

- ADR 결제 섹션에는 아키텍처 결정과 그렇게 결정하게 된 사유를 전부 밝힌다
- 결정 섹션의 가장 큰 강점은 아키텍트가 방법보다 이유에 더 무게를 실을 수 있따는 것이다
    - 사실 왜 그런 결정을 내렸는지 이해하는 것이 그것이 어떻게 작동되는지 이해하는 것보다 훨씬 더 중요하다

#### 결과

- ADR결과 역시 아주 강력한 섹션이다. 이섹션에서는 아키텍처 결정의 전체적인 영향도를 기술한다
- 아키텍처 결정이 어떤 영향을 미치는지 구체적으로 기술함으로써 아키텍트는 결정의 장점보다 그 영향이 더 중요한지 되돌아보게 된다
- 아키텍처 결정에 관한 트레이드오프는 물론, 분석 결과도 문서화할 수 있으므로 유용하다

#### 컴플라이언스(준수)

<img src = "../img/IMG_5957.jpg" width = "600" height = "400">

- ADR의 컴플라이언스 섹션은 표준 섹션은 아니지만 반드시 추가하라고 권장한다
- 이 섹션은 컴플라이언스 관점에서 아키텍트가 아키텍처 결정을 어떻게 측정/관리하는게 좋을지 생각하게 만든다
    - 피트니스 함수로 자동화할지 수동으로 할지 결정해야 한다
    - 피트니스 함수 : 특정 아키텍처 특성이 제대로 지켜지고 있는지 평가하는 다양한 수단
- 위 이미지에서 자바 아크유니(ArchUnit)이나 C# 넷아크테스트(NetArchTest)를 사용해서 측정 관리를 자동화할 수 있다

```
@Test
public vodi shared_services_should_reside_int_services_layer(){
    classes().that().areAnnotatedWith(SharedService.class)
      .should().resideInAPackage("..services..")
      .because("비즈니스 레이어에서 비즈니스 객체가 사용흔 모든 공유 객체는 공유 서비스 레이어에 두고 공유 기능을 분리하여 구현한다)
      .check(myClasses);
}
```

- 위 자동화 피트니스 함수를 사용하려면 새로운 자바 어노테이션(@SharedServices)를 만들어 이 어노테이션을 모든 공유 클래스에 추가해야 한다
    - 이 섹션에는 어떤 테스트를 하고 그 테스트를 어디에서 찾을 수 있는지, 테스트는 언제 어떻게 실행되는지도 기정한다

#### 노트

- 노트 섹션역시 표준 섹션은 아니지면 가급적 추가하는게 좋다. 이 섹션에는 다음과같은 ADR에 관한 다양한 메타데이터가 포함된다
    - 원저자, 승인일, 승인자, 대체일, 최종 수정일, 수정자, 최종 수정내역

### ADR 저장

- ADR은 어딘가에 저장해야한다. 저장 위치와 상관없이 각 아키텍처 결정은 자체 파일이나 위키 페이지도 갖고 있어야 한다
- 일부 아키텍트들은 ADR을 소스 코드와 함께 깃 리포지터리에 보관하는 것을 선호한다
    - 규모가 큰 조직에서는 주의 사항이 있다
    - 1> 아키텍처 결정을 확인해야 하는데 어떤 이들은 깃 리포지터리에 엑세스할 수 없는 경우가 있다
    - 2> 애플리케이션 깃 리포를 벗어나 콘텍스트가 있는 ADR을 깃에 저장하는 것은 적절하지 않다
    - 그러므로 위키나 다른 문서에서 쉽게 접근 가능한 공유 파일 서버의 공유 디렉터리가 가장 적합하다

### ADR로 문서화

- 문서화는 언제나 어려운 주제이다
- 일부 아키텍처 도식화 표준(사이먼 브라운 사의 C4모델, 오픈 그룹의 아키메이트 표준)이 있긴 하지만, 아직 이렇다할 문서화 표준은 없다. 그래서 ADR이 더 필요하다
- ADR이 최고다 이걸 써라

### 예시

<img src = "../img/IMG_5959.jpg" width = "600" height = "400">
<img src = "../img/IMG_5958.jpg" width = "600" height = "800">

- 이벤트 기반 마이크로서비스 사용, 입찰자와 경매인 유저 인터페이스의 분할, 비디오 캡쳐를 위한 실시간 전송 프로토콜 사용, 단일 API레이어 사용. 이런 결정은 사실 경매 시스템 구축에 필요한 수십 가지 아키텍처
  결정 중 일부에 지나지 않는다. 아키텍트는 어떤 시스템에서 확정한 아키텍처 결정들이 아무리 뻔하더라도 하나하니 그 사유를 밝히고 문서화 해야한다
- 위 이미지는 BidCapture, BidStreamer, BidTracker서비스 간에 메시지 발행/구독을 응용한 GGG 경매 시스템의 아키텍처 결정사례이고 오른쪽은 ADR문서이다 
