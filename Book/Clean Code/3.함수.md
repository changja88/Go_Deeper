## 함수

### 작게 만들어라

- 함수를 만드는 첫째 규칙은 "작게!"다. 함수를 만드는 두번째 규칙은 "작게"다
- 얼마나 작게 만들어야 할까

```
public static String renderPageWithSetupAndTeardowns(
    PageData pageData, boolean isSuite
)throws Eception{
    boolen is TestPage = pageDate.hasAttribute("Test");
    if(isTestPage){
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageCount = new StringBuffer();
        includedSetupPages(testPage, newpageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
        pageData.setContent(newPageContent.toString());
    }
    return pageDatea.getHtml();
} 
```

- 위 함수도 이미 70줄 짜리 함수를 줄였지만 부족하다. 아래처럼 더 줄여야 한다

```
public static String renderPageWithSetupAndTeardowns(
    PageData pageData, boolean isSuite
)throws Exception{
    if(isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite);
    return pageDate.getHtml();
}
```

- 블록과 들여쓰기
    - if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다
        - 대게 여기에서 함수를 호출 하기 때무닝고, 그러변 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면 코드를 이해기 쉬워진다
    - 즉, 중첩 구조가 생길 만큼 함수가 커져서는 안 된다는 뜻이며, 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다

### 한 가지만 해라!

- `함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야한다. 그 한 가지만을 해야 한다`
- 그렇다면 '한 가지'란 뭘까?
    - 위에 있는 함수는 1> 페이지가 테스트 페이지인지 판단한다 2> 그렇다면 설정 페이지와 해제 페이지를 넣는다 3> 페이지를 HTML로 렌더링 한다
    - 위 함수는 한가지를 하는 것일까? 세 가지 일을 하는 것일까?
    - `지정된 이름 아래에서 추상화 수준이 하나인 "단계"만 수행 한다면, 그 함수는 하는일이 한 가지라고 할 수 있다`
- 다른 방법으로는 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하고 있다고 볼 수 있다

### 함수 당 추상화 수준은 하나로!

- 위에서 아래로 코드 읽기: 내려가기 규칙
    - 코드는 위에서 아래로 이야기처럼 읽혀야 좋다
    - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다
    - 즉 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단게식 낮아진달 &rarr; 내려가기 규치

### Switch 문

```
public Money calculatePay(Employee e) throw InvalidEmployeeType{
    switch(e.type){
        case COMMISSIONED: return calculateComissionedPaye(e);
        case HOURLY : return calculateHourlyPay(e);
        case SALARIED : return calculateSalariedPay(e);
        default : new InvaliedEmployeeType(e.type);
    }
}
```

- 위 코드의 문제점
    - 코드가 길다
    - SRP, OCP를 지키고 있지 않다

```
public abstract class Employee{
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
}
public interface EmployeeFactory{
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
public class EmployeeFactoryImpl implements EmployeeFactory{
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
        switch(r.type){
            case COMMISSIONED: return calculateComissionedPaye(e);
            case HOURLY : return calculateHourlyPay(e);
            case SALARIED : return calculateSalariedPay(e);
            default : new InvaliedEmployeeType(e.type);
        }
    }
}
```

- 위와 같이 해결 할 수 있다 &rarr; 스위치 문은 다형적 객체를 생성하는 코드에서만 참아준다

### 서술적인 이름을 사용하라!

- 이름이 길어도 괜찮다
    - 길고 서술적인 이름이 짧고 어려운 이름보다 좋다
    - 길고 서술적인 이름이 길고 서술적인 주석보다 좋다
    - 함 수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다
    - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다

### 함수 인수

- 함수에서 이상적인 인수 개수는 0개(무항)이다
    - 인수는 개념을 이해하기 어렵게 만들기 때문이다
    - includeSetupPageInto(new PageContent) 보다 includeSetupPageInto()가 더 이해하기 쉽다
- 함수 이름과 인수 사이에 추상화 수준이 다르면 안된다
    - includeSetupPageInto(newPageContent)는 함수 이름과 인수 사이에 추상화 수준이 다르다
    - 추가로 현 시점에서 별로 중요하지 않은 세부 사항 즉, StringBuffer를 알아야 한다
- 많이 쓰는 단항 형식
    - 함수에 인수 1개를 넘기는 가장 흔한 경우는 두 가지이다
    - 1> 하나는 인수에 질문을 던지는 경우 &rarr; boolean fileExist("MyFile")
    - 2> 인수를 뭔가로 변환해 결과를 반환하는 경우
        - InputStream fileOpen("myFile")
        - 변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다
        - StringBuffer transform(StringBuffer in)이 void transform(StringBuffer out)보다 좋다
    - 3> 이벤트
        - 입력 인수로 시스템의 상태를 바꾼다
        - 이벤트라는 사실이 코드이 명확히 드러나야 한다
    - 함수 이름을 지을 대는 두 경우를 분명히 구분해야 한다(`명령과 조회를 분리해야 한다`)
    - 위 경우가 아니라면 단항 함수는 가급적 피하는 것이 좋다
        - void includeSetupPageInto(String Buffer pageText)는 피하는 것이 좋다
    