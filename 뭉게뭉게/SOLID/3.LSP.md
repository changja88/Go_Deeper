## 리스코프 치환 원칙(LSP, Liskov substitution principle)

```
자식 객체가 부모객체를 대체할 수 있어야 한다
```

## 대체 할 수 있다?

- A가 B를 대체를 할 수 있다는 말은
    - A가 하던 기능을 B도 할수 있어야 한다는 말이다
    - A가 calculate()라는 기능이 있다면 B에도 calculate()라는 기능이 있어야 한다는 말이다
    - 잘보면 "대체"라고 했지 "동일" 이라고 하지 않았다
    - 결국 A처럼 B도 calculate()라는 기능이 있으면 된다는 거지 그 결과가 A의 calculate()의 결과와 동일할 필요가 없다는 뜻이고,
    - (하지만, 동일할 필요가 없다는 뜻이지 당연히 지마음데로 calculate()라는 이름에서 알수 없는 아주 엉뚱한 짓을 하면 당연히 안된다)
    - 이는 똑같은 메시지(명령, 함수)호출에 대해서 서로 다른 응답이 가능해야 함을 의미한다
    - 이를 한마디로 하면 "다형성"이다

## 자식 객체가 부모 객체를?

- 위에서 다형성이라는 것은 똑같은 메시지에 대해서 서로 다른 응답이 가능 한것이라고 했다
    - 그럼 다형성이라는 것을 OOP에서 구현하는 방법은 두가지가 있다
    - 가장 일반적으로는 인터페이스를 구현하는 클래스는가 있다
    - 두번째로는 부모클래스를 상속 받는 자식 클래스가. 자식클래스는 부모클래스의 기능을 물려 받을 수 있다
    - 즉, 자식클래스, 부모클래스도 동일한 함수가 있기 때문에 똑같은 메시지에 대해서 서로 다른 응답이 가능 하기때문에 다형성을 만들 수 있다
    - 하지만 중요한점은 `할 수 도` 있다는 것이다

### 할 수 도에 대한건...나중에..

## 결론

- Tool에 관한 것이다, 나머지 원칙을 지키는 HOW를 만들 때 이걸 써봐라
- 상속으로도 추상화를 구현할 수 있다
- 타입 시스템을 통해서 추상화를 `할 수 도` 있고, 추상화를 통해서 다형성을 만들수 있으며, 다형성이라는 말 안에는 지마음데로가 아니라 사용자가 기대하는 행동을 수행해야 라는 뜻
