## 개방-폐쇄 원칙 (OCP, Open-Closed Principle)

```
- 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
- 쉽게 말하면 기존 코드를 변경하지 않고 새로운 확장(기능을 추가하거나 수정) 할 수 있어야 한다

(끝까지 들으면 아마 공감하지 않을까 합니다)
개인적으로는 개방-폐쇄 원칙은 지켜야할 원칙이라기 보다는
- 좋은 코드가 가지고 있는 특징,
- 또는 리펙토링할 여지가 있는지 확인을 하는 좋은 원칙,
- 또는 나머지 SOLID 원칙이 지켜지고 있는지 확인 할 수 있는 원칙 이라고 생각 합니다
```

### 함수 수준

- 불가능 함
- 함수가 SRP를 지키고 있는 한, 애초에 함수는 하나의 기능만을 가지고 있기 때문에 수정을 하기 위해서는 무조건 원래 코드에 수정을 할 수밖에 없음

### 모듈 수준

- 아래 상황에서 코드는 얼마나 많이 수정해야할까?
    - 기존: 재무재표를 보여주는 웹페이지가 있고 음수는 빨간색으로 표기된다
    - 요구사항: 흑백 프린터로 출력을 해야한다 + 페이지 번호가 있어야한다 + 머리글과 바닥글이 있어야 한다 + 음수는 괄호로 감싸야한다
- 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 최소화될 것이다 &rarr; 이상적인 변경량은 0이다
- 어떻게 해야할까?
    - 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고 &rarr; SRP
    - 이들 요소 사이의 의존성을 체계화 &rarr; DIP
    - 함으로써 변경량을 최소화할 수 있다
- 단일 책임 원칙을 적용하면 데이터 흐름을 아래와 같은 형태로 만들 수 있다
  ```mermaid
  graph LR
      A(재무데이터) --> B[재무 분석기] --> C(보고서용 재무 데이터)
      C --> D[보고서를 웹에 표시]
      C --> E[보고서를 프린터로 출력]
  
  ```
    - 위를 보면 두개의 책임으로 분리된다
        - 보고서용 데이터를 계산하는 책임
        - 데이터를 웹으로 보여주거나 프린트하는 책임
    - 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야한다
        - `이를 위한 컴포넌트를 구성할때 모든 컴포넌트 관계는 단방향으로 이루어 져야 한다`
            - 이는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려져야한다
            - `A컴포넌트에서 발생한 변경으로 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야한다`
                ```mermaid
                graph LR
                    A(Financial Report Controll) --> B(Financial Report Interactor)
                    C(Financial Database) --> B
                    D(Screen Presenter) --> A
                    E(print Presenter) --> A
                    F(PDF View) --> E
                    G(Web View) --> D
                ```
            - Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다
                - interactor가 업무 규칙을 포함하기 때문이다.
                - 애플리케이션에서 가장 높은 수준의 정책을 포함한다.
                - Interactor이외의 모든 컴포넌트는 모두 주변 적인 문제를 처리한다. 가장 중요한 문제는 Interactor가 담당한다
            - `즉, 수준(level)이 높을 수록 최고의 보호를 받는다 &rarr; 이것이 아키텍처 수준에서 OCP가 동작하는 방식이다`
                - 이키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화 한다
                - 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호 할 수 있다
- ????
    - 뭔가 이상하지 않아?
    - 위에 표 화살표 방향 말했니?

## 결론

- What에 관한 것, 이렇게 되어야 한다
- `개방-폐쇄 원칙은 '분리'에 관한 것이다`
    - 분리 되어 있는 것들을 `연결` 하기 위해서 `의존성`이라는 것을 사용한다
    - 결국, 개방-폐쇄 원칙은 어떻게 분리시키고, 분리시켜 놓은 것들을 어떻게 연결시킬 것인가에 대한 고민이다

### 아키텍처 수준

## 공통 폐쇄 원칙 (CCP, Common Closure Principle)

- 동일