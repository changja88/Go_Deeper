## 총정리

| 패턴 이름                    |     수호 원칙      | 목적                                                              | 정의                                                                                                                              |
|--------------------------|:--------------:|-----------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
| Strategy Pattern         |      OCP       | 달라지는 부분을 찾아내고, 달라지지 않는 않부분으로부터 분리 시킨다                           | 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다                                                                                        |
| Observer Pattern         | Loose Coupling | 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨한 결합을 하는 디자인을 사용한다                  | 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다                                                       |
| Decorator Pattern        |      OCP       | OCP 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다              | 객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다                                                     |
| Factory Method Pattern   |      OCP       | 객체 생성의 캡슐화                                                      | 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하게 만든다                                                    |
| Abstract Factory Pattern |      OCP       | 의존성 뒤집기 원칙을 따르면 구상 형식에 대한 의존을 피하고 추상화를 지향할 수 있다                 | 추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다                                                          |
| Singleton Pattern        |                | 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다                 | 싱글턴 패턴은 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴이다                                                             |
| Command Pattern          |      OCP       | 요청을 하는 객체와 그 요청을 수행하는 객체를 분리 시킨다 (매소드 캡슐화)                      | 커맨드 패턴을 이용하면 요구 사항을 객체로 캡슐화 할 수 있으며, 매개변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수도 있다       또한 요청 내역을 큐에 저장하거나 로그로 기록할 수도 있으며, 작업취소 기능도 지원한다 |
| Adapter Pattern          |                | 어답터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸수 있다           | 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다                                                                                   |
| Facade Pattern           |    최소 지식 원칙    | 사용하기 쉬운 인터페이스를 제공함과 동시에 클라이언트와 구성요소들로 이루어진 서브시스템을 분리시킨다         | 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다. 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 쉽게 사용할 수 있다                                           |
| Template Pattern         |    할리우드 원칙     | 템플릿 메소드를 제공해서 서브클래스가 구현할 수 있도록 하게 해준다                           | 메소드에서 알고리즘의 골격을 정의한다. 알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다. 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로  유지하면서 서브클래스에서 특정 단계를 재정의할 수 있습니다         |
| Iterator Pattern         |    최소 지식 원칙    | 클래스를 바꾸는 이유는 한가지 뿐이어야 한다                                        | 바뀌는 부분을 캡슐화하라 -> 서로 다른 컬렉션 타입 때문에 반복 작업을 하는 방법이 다른 것을 일관화 시킨다                                                                   |컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공한다|
| Composite Pattern        |    최소지식 원칙     | 복합 객체와 개별 객체에 대해 똑같은 작업을 적용할 수 있다. 즉, 복합객체와 개별 객체를 구분할 필요가 없어진다 | 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들수 있다.이 패턴을 이용하면 클라이언트에서 개별 객체와 다른 객체들로 구성된 복합객체를 똑같은 방법으로 다룰 수 있다                         |
| State Pattern            |      OCP       | 변하는 부분을 캡슐화 한다                                                  | 객체의 내부 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있따. 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다                                                            |